{"Albums":[],"Articles":[],"Attachments":[],"Blogs":[],"BlogPosts":[],"Body":"\/*! jQuery UI - v1.14.1 - 2025-03-30\r\n * https:\/\/jqueryui.com\r\n * Includes: widget.js, position.js, data.js, disable-selection.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets\/draggable.js, widgets\/droppable.js, widgets\/resizable.js, widgets\/selectable.js, widgets\/sortable.js, widgets\/mouse.js, effect.js, effects\/effect-blind.js, effects\/effect-bounce.js, effects\/effect-clip.js, effects\/effect-drop.js, effects\/effect-explode.js, effects\/effect-fade.js, effects\/effect-fold.js, effects\/effect-highlight.js, effects\/effect-puff.js, effects\/effect-pulsate.js, effects\/effect-scale.js, effects\/effect-shake.js, effects\/effect-size.js, effects\/effect-slide.js, effects\/effect-transfer.js\r\n * Copyright OpenJS Foundation and other contributors; Licensed MIT *\/\r\n\r\n(function(factory) {\r\n    &quot;use strict&quot;;\r\n\r\n    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {\r\n\r\n        \/\/ AMD. Register as an anonymous module.\r\n        define([&quot;jquery&quot;], factory);\r\n    } else {\r\n\r\n        \/\/ Browser globals\r\n        factory(jQuery);\r\n    }\r\n})(function($) {\r\n    &quot;use strict&quot;;\r\n\r\n    $.ui = $.ui || {};\r\n\r\n    var version = $.ui.version = &quot;1.14.1&quot;;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Widget 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Widget\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Provides a factory for creating stateful widgets with a common API.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/jQuery.widget\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/widget\/\r\n\r\n\r\n    var widgetUuid = 0;\r\n    var widgetHasOwnProperty = Array.prototype.hasOwnProperty;\r\n    var widgetSlice = Array.prototype.slice;\r\n\r\n    $.cleanData = (function(orig) {\r\n        return function(elems) {\r\n            var events, elem, i;\r\n            for (i = 0;\r\n                (elem = elems[i]) != null; i++) {\r\n\r\n                \/\/ Only trigger remove when necessary to save time\r\n                events = $._data(elem, &quot;events&quot;);\r\n                if (events &amp;&amp; events.remove) {\r\n                    $(elem).triggerHandler(&quot;remove&quot;);\r\n                }\r\n            }\r\n            orig(elems);\r\n        };\r\n    })($.cleanData);\r\n\r\n    $.widget = function(name, base, prototype) {\r\n        var existingConstructor, constructor, basePrototype;\r\n\r\n        \/\/ ProxiedPrototype allows the provided prototype to remain unmodified\r\n        \/\/ so that it can be used as a mixin for multiple widgets (#8876)\r\n        var proxiedPrototype = {};\r\n\r\n        var namespace = name.split(&quot;.&quot;)[0];\r\n        name = name.split(&quot;.&quot;)[1];\r\n        if (name === &quot;__proto__&quot; || name === &quot;constructor&quot;) {\r\n            return $.error(&quot;Invalid widget name: &quot; + name);\r\n        }\r\n        var fullName = namespace + &quot;-&quot; + name;\r\n\r\n        if (!prototype) {\r\n            prototype = base;\r\n            base = $.Widget;\r\n        }\r\n\r\n        if (Array.isArray(prototype)) {\r\n            prototype = $.extend.apply(null, [{}].concat(prototype));\r\n        }\r\n\r\n        \/\/ Create selector for plugin\r\n        $.expr.pseudos[fullName.toLowerCase()] = function(elem) {\r\n            return !!$.data(elem, fullName);\r\n        };\r\n\r\n        $[namespace] = $[namespace] || {};\r\n        existingConstructor = $[namespace][name];\r\n        constructor = $[namespace][name] = function(options, element) {\r\n\r\n            \/\/ Allow instantiation without &quot;new&quot; keyword\r\n            if (!this || !this._createWidget) {\r\n                return new constructor(options, element);\r\n            }\r\n\r\n            \/\/ Allow instantiation without initializing for simple inheritance\r\n            \/\/ must use &quot;new&quot; keyword (the code above always passes args)\r\n            if (arguments.length) {\r\n                this._createWidget(options, element);\r\n            }\r\n        };\r\n\r\n        \/\/ Extend with the existing constructor to carry over any static properties\r\n        $.extend(constructor, existingConstructor, {\r\n            version: prototype.version,\r\n\r\n            \/\/ Copy the object used to create the prototype in case we need to\r\n            \/\/ redefine the widget later\r\n            _proto: $.extend({}, prototype),\r\n\r\n            \/\/ Track widgets that inherit from this widget in case this widget is\r\n            \/\/ redefined after a widget inherits from it\r\n            _childConstructors: []\r\n        });\r\n\r\n        basePrototype = new base();\r\n\r\n        \/\/ We need to make the options hash a property directly on the new instance\r\n        \/\/ otherwise we&#039;ll modify the options hash on the prototype that we&#039;re\r\n        \/\/ inheriting from\r\n        basePrototype.options = $.widget.extend({}, basePrototype.options);\r\n        $.each(prototype, function(prop, value) {\r\n            if (typeof value !== &quot;function&quot;) {\r\n                proxiedPrototype[prop] = value;\r\n                return;\r\n            }\r\n            proxiedPrototype[prop] = (function() {\r\n                function _super() {\r\n                    return base.prototype[prop].apply(this, arguments);\r\n                }\r\n\r\n                function _superApply(args) {\r\n                    return base.prototype[prop].apply(this, args);\r\n                }\r\n\r\n                return function() {\r\n                    var __super = this._super;\r\n                    var __superApply = this._superApply;\r\n                    var returnValue;\r\n\r\n                    this._super = _super;\r\n                    this._superApply = _superApply;\r\n\r\n                    returnValue = value.apply(this, arguments);\r\n\r\n                    this._super = __super;\r\n                    this._superApply = __superApply;\r\n\r\n                    return returnValue;\r\n                };\r\n            })();\r\n        });\r\n        constructor.prototype = $.widget.extend(basePrototype, {\r\n\r\n            \/\/ TODO: remove support for widgetEventPrefix\r\n            \/\/ always use the name + a colon as the prefix, e.g., draggable:start\r\n            \/\/ don&#039;t prefix for widgets that aren&#039;t DOM-based\r\n            widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\r\n        }, proxiedPrototype, {\r\n            constructor: constructor,\r\n            namespace: namespace,\r\n            widgetName: name,\r\n            widgetFullName: fullName\r\n        });\r\n\r\n        \/\/ If this widget is being redefined then we need to find all widgets that\r\n        \/\/ are inheriting from it and redefine all of them so that they inherit from\r\n        \/\/ the new version of this widget. We&#039;re essentially trying to replace one\r\n        \/\/ level in the prototype chain.\r\n        if (existingConstructor) {\r\n            $.each(existingConstructor._childConstructors, function(i, child) {\r\n                var childPrototype = child.prototype;\r\n\r\n                \/\/ Redefine the child widget using the same prototype that was\r\n                \/\/ originally used, but inherit from the new version of the base\r\n                $.widget(childPrototype.namespace + &quot;.&quot; + childPrototype.widgetName, constructor,\r\n                    child._proto);\r\n            });\r\n\r\n            \/\/ Remove the list of existing child constructors from the old constructor\r\n            \/\/ so the old child constructors can be garbage collected\r\n            delete existingConstructor._childConstructors;\r\n        } else {\r\n            base._childConstructors.push(constructor);\r\n        }\r\n\r\n        $.widget.bridge(name, constructor);\r\n\r\n        return constructor;\r\n    };\r\n\r\n    $.widget.extend = function(target) {\r\n        var input = widgetSlice.call(arguments, 1);\r\n        var inputIndex = 0;\r\n        var inputLength = input.length;\r\n        var key;\r\n        var value;\r\n\r\n        for (; inputIndex &lt; inputLength; inputIndex++) {\r\n            for (key in input[inputIndex]) {\r\n                value = input[inputIndex][key];\r\n                if (widgetHasOwnProperty.call(input[inputIndex], key) &amp;&amp; value !== undefined) {\r\n\r\n                    \/\/ Clone objects\r\n                    if ($.isPlainObject(value)) {\r\n                        target[key] = $.isPlainObject(target[key]) ?\r\n                            $.widget.extend({}, target[key], value) :\r\n\r\n                            \/\/ Don&#039;t extend strings, arrays, etc. with objects\r\n                            $.widget.extend({}, value);\r\n\r\n                        \/\/ Copy everything else by reference\r\n                    } else {\r\n                        target[key] = value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    };\r\n\r\n    $.widget.bridge = function(name, object) {\r\n        var fullName = object.prototype.widgetFullName || name;\r\n        $.fn[name] = function(options) {\r\n            var isMethodCall = typeof options === &quot;string&quot;;\r\n            var args = widgetSlice.call(arguments, 1);\r\n            var returnValue = this;\r\n\r\n            if (isMethodCall) {\r\n\r\n                \/\/ If this is an empty collection, we need to have the instance method\r\n                \/\/ return undefined instead of the jQuery instance\r\n                if (!this.length &amp;&amp; options === &quot;instance&quot;) {\r\n                    returnValue = undefined;\r\n                } else {\r\n                    this.each(function() {\r\n                        var methodValue;\r\n                        var instance = $.data(this, fullName);\r\n\r\n                        if (options === &quot;instance&quot;) {\r\n                            returnValue = instance;\r\n                            return false;\r\n                        }\r\n\r\n                        if (!instance) {\r\n                            return $.error(&quot;cannot call methods on &quot; + name +\r\n                                &quot; prior to initialization; &quot; +\r\n                                &quot;attempted to call method &#039;&quot; + options + &quot;&#039;&quot;);\r\n                        }\r\n\r\n                        if (typeof instance[options] !== &quot;function&quot; ||\r\n                            options.charAt(0) === &quot;_&quot;) {\r\n                            return $.error(&quot;no such method &#039;&quot; + options + &quot;&#039; for &quot; + name +\r\n                                &quot; widget instance&quot;);\r\n                        }\r\n\r\n                        methodValue = instance[options].apply(instance, args);\r\n\r\n                        if (methodValue !== instance &amp;&amp; methodValue !== undefined) {\r\n                            returnValue = methodValue &amp;&amp; methodValue.jquery ?\r\n                                returnValue.pushStack(methodValue.get()) :\r\n                                methodValue;\r\n                            return false;\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n\r\n                \/\/ Allow multiple hashes to be passed on init\r\n                if (args.length) {\r\n                    options = $.widget.extend.apply(null, [options].concat(args));\r\n                }\r\n\r\n                this.each(function() {\r\n                    var instance = $.data(this, fullName);\r\n                    if (instance) {\r\n                        instance.option(options || {});\r\n                        if (instance._init) {\r\n                            instance._init();\r\n                        }\r\n                    } else {\r\n                        $.data(this, fullName, new object(options, this));\r\n                    }\r\n                });\r\n            }\r\n\r\n            return returnValue;\r\n        };\r\n    };\r\n\r\n    $.Widget = function( \/* options, element *\/ ) {};\r\n    $.Widget._childConstructors = [];\r\n\r\n    $.Widget.prototype = {\r\n        widgetName: &quot;widget&quot;,\r\n        widgetEventPrefix: &quot;&quot;,\r\n        defaultElement: &quot;&lt;div&gt;&quot;,\r\n\r\n        options: {\r\n            classes: {},\r\n            disabled: false,\r\n\r\n            \/\/ Callbacks\r\n            create: null\r\n        },\r\n\r\n        _createWidget: function(options, element) {\r\n            element = $(element || this.defaultElement || this)[0];\r\n            this.element = $(element);\r\n            this.uuid = widgetUuid++;\r\n            this.eventNamespace = &quot;.&quot; + this.widgetName + this.uuid;\r\n\r\n            this.bindings = $();\r\n            this.hoverable = $();\r\n            this.focusable = $();\r\n            this.classesElementLookup = {};\r\n\r\n            if (element !== this) {\r\n                $.data(element, this.widgetFullName, this);\r\n                this._on(true, this.element, {\r\n                    remove: function(event) {\r\n                        if (event.target === element) {\r\n                            this.destroy();\r\n                        }\r\n                    }\r\n                });\r\n                this.document = $(element.style ?\r\n\r\n                    \/\/ Element within the document\r\n                    element.ownerDocument :\r\n\r\n                    \/\/ Element is window or document\r\n                    element.document || element);\r\n                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);\r\n            }\r\n\r\n            this.options = $.widget.extend({},\r\n                this.options,\r\n                this._getCreateOptions(),\r\n                options);\r\n\r\n            this._create();\r\n\r\n            if (this.options.disabled) {\r\n                this._setOptionDisabled(this.options.disabled);\r\n            }\r\n\r\n            this._trigger(&quot;create&quot;, null, this._getCreateEventData());\r\n            this._init();\r\n        },\r\n\r\n        _getCreateOptions: function() {\r\n            return {};\r\n        },\r\n\r\n        _getCreateEventData: $.noop,\r\n\r\n        _create: $.noop,\r\n\r\n        _init: $.noop,\r\n\r\n        destroy: function() {\r\n            var that = this;\r\n\r\n            this._destroy();\r\n            $.each(this.classesElementLookup, function(key, value) {\r\n                that._removeClass(value, key);\r\n            });\r\n\r\n            \/\/ We can probably remove the unbind calls in 2.0\r\n            \/\/ all event bindings should go through this._on()\r\n            this.element\r\n                .off(this.eventNamespace)\r\n                .removeData(this.widgetFullName);\r\n            this.widget()\r\n                .off(this.eventNamespace)\r\n                .removeAttr(&quot;aria-disabled&quot;);\r\n\r\n            \/\/ Clean up events and states\r\n            this.bindings.off(this.eventNamespace);\r\n        },\r\n\r\n        _destroy: $.noop,\r\n\r\n        widget: function() {\r\n            return this.element;\r\n        },\r\n\r\n        option: function(key, value) {\r\n            var options = key;\r\n            var parts;\r\n            var curOption;\r\n            var i;\r\n\r\n            if (arguments.length === 0) {\r\n\r\n                \/\/ Don&#039;t return a reference to the internal hash\r\n                return $.widget.extend({}, this.options);\r\n            }\r\n\r\n            if (typeof key === &quot;string&quot;) {\r\n\r\n                \/\/ Handle nested keys, e.g., &quot;foo.bar&quot; =&gt; { foo: { bar: ___ } }\r\n                options = {};\r\n                parts = key.split(&quot;.&quot;);\r\n                key = parts.shift();\r\n                if (parts.length) {\r\n                    curOption = options[key] = $.widget.extend({}, this.options[key]);\r\n                    for (i = 0; i &lt; parts.length - 1; i++) {\r\n                        curOption[parts[i]] = curOption[parts[i]] || {};\r\n                        curOption = curOption[parts[i]];\r\n                    }\r\n                    key = parts.pop();\r\n                    if (arguments.length === 1) {\r\n                        return curOption[key] === undefined ? null : curOption[key];\r\n                    }\r\n                    curOption[key] = value;\r\n                } else {\r\n                    if (arguments.length === 1) {\r\n                        return this.options[key] === undefined ? null : this.options[key];\r\n                    }\r\n                    options[key] = value;\r\n                }\r\n            }\r\n\r\n            this._setOptions(options);\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOptions: function(options) {\r\n            var key;\r\n\r\n            for (key in options) {\r\n                this._setOption(key, options[key]);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOption: function(key, value) {\r\n            if (key === &quot;classes&quot;) {\r\n                this._setOptionClasses(value);\r\n            }\r\n\r\n            this.options[key] = value;\r\n\r\n            if (key === &quot;disabled&quot;) {\r\n                this._setOptionDisabled(value);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOptionClasses: function(value) {\r\n            var classKey, elements, currentElements;\r\n\r\n            for (classKey in value) {\r\n                currentElements = this.classesElementLookup[classKey];\r\n                if (value[classKey] === this.options.classes[classKey] ||\r\n                    !currentElements ||\r\n                    !currentElements.length) {\r\n                    continue;\r\n                }\r\n\r\n                \/\/ We are doing this to create a new jQuery object because the _removeClass() call\r\n                \/\/ on the next line is going to destroy the reference to the current elements being\r\n                \/\/ tracked. We need to save a copy of this collection so that we can add the new classes\r\n                \/\/ below.\r\n                elements = $(currentElements.get());\r\n                this._removeClass(currentElements, classKey);\r\n\r\n                \/\/ We don&#039;t use _addClass() here, because that uses this.options.classes\r\n                \/\/ for generating the string of classes. We want to use the value passed in from\r\n                \/\/ _setOption(), this is the new value of the classes option which was passed to\r\n                \/\/ _setOption(). We pass this value directly to _classes().\r\n                elements.addClass(this._classes({\r\n                    element: elements,\r\n                    keys: classKey,\r\n                    classes: value,\r\n                    add: true\r\n                }));\r\n            }\r\n        },\r\n\r\n        _setOptionDisabled: function(value) {\r\n            this._toggleClass(this.widget(), this.widgetFullName + &quot;-disabled&quot;, null, !!value);\r\n\r\n            \/\/ If the widget is becoming disabled, then nothing is interactive\r\n            if (value) {\r\n                this._removeClass(this.hoverable, null, &quot;ui-state-hover&quot;);\r\n                this._removeClass(this.focusable, null, &quot;ui-state-focus&quot;);\r\n            }\r\n        },\r\n\r\n        enable: function() {\r\n            return this._setOptions({\r\n                disabled: false\r\n            });\r\n        },\r\n\r\n        disable: function() {\r\n            return this._setOptions({\r\n                disabled: true\r\n            });\r\n        },\r\n\r\n        _classes: function(options) {\r\n            var full = [];\r\n            var that = this;\r\n\r\n            options = $.extend({\r\n                element: this.element,\r\n                classes: this.options.classes || {}\r\n            }, options);\r\n\r\n            function bindRemoveEvent() {\r\n                var nodesToBind = [];\r\n\r\n                options.element.each(function(_, element) {\r\n                    var isTracked = $.map(that.classesElementLookup, function(elements) {\r\n                            return elements;\r\n                        })\r\n                        .some(function(elements) {\r\n                            return elements.is(element);\r\n                        });\r\n\r\n                    if (!isTracked) {\r\n                        nodesToBind.push(element);\r\n                    }\r\n                });\r\n\r\n                that._on($(nodesToBind), {\r\n                    remove: &quot;_untrackClassesElement&quot;\r\n                });\r\n            }\r\n\r\n            function processClassString(classes, checkOption) {\r\n                var current, i;\r\n                for (i = 0; i &lt; classes.length; i++) {\r\n                    current = that.classesElementLookup[classes[i]] || $();\r\n                    if (options.add) {\r\n                        bindRemoveEvent();\r\n                        current = $($.uniqueSort(current.get().concat(options.element.get())));\r\n                    } else {\r\n                        current = $(current.not(options.element).get());\r\n                    }\r\n                    that.classesElementLookup[classes[i]] = current;\r\n                    full.push(classes[i]);\r\n                    if (checkOption &amp;&amp; options.classes[classes[i]]) {\r\n                        full.push(options.classes[classes[i]]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (options.keys) {\r\n                processClassString(options.keys.match(\/\\S+\/g) || [], true);\r\n            }\r\n            if (options.extra) {\r\n                processClassString(options.extra.match(\/\\S+\/g) || []);\r\n            }\r\n\r\n            return full.join(&quot; &quot;);\r\n        },\r\n\r\n        _untrackClassesElement: function(event) {\r\n            var that = this;\r\n            $.each(that.classesElementLookup, function(key, value) {\r\n                if ($.inArray(event.target, value) !== -1) {\r\n                    that.classesElementLookup[key] = $(value.not(event.target).get());\r\n                }\r\n            });\r\n\r\n            this._off($(event.target));\r\n        },\r\n\r\n        _removeClass: function(element, keys, extra) {\r\n            return this._toggleClass(element, keys, extra, false);\r\n        },\r\n\r\n        _addClass: function(element, keys, extra) {\r\n            return this._toggleClass(element, keys, extra, true);\r\n        },\r\n\r\n        _toggleClass: function(element, keys, extra, add) {\r\n            add = (typeof add === &quot;boolean&quot;) ? add : extra;\r\n            var shift = (typeof element === &quot;string&quot; || element === null),\r\n                options = {\r\n                    extra: shift ? keys : extra,\r\n                    keys: shift ? element : keys,\r\n                    element: shift ? this.element : element,\r\n                    add: add\r\n                };\r\n            options.element.toggleClass(this._classes(options), add);\r\n            return this;\r\n        },\r\n\r\n        _on: function(suppressDisabledCheck, element, handlers) {\r\n            var delegateElement;\r\n            var instance = this;\r\n\r\n            \/\/ No suppressDisabledCheck flag, shuffle arguments\r\n            if (typeof suppressDisabledCheck !== &quot;boolean&quot;) {\r\n                handlers = element;\r\n                element = suppressDisabledCheck;\r\n                suppressDisabledCheck = false;\r\n            }\r\n\r\n            \/\/ No element argument, shuffle and use this.element\r\n            if (!handlers) {\r\n                handlers = element;\r\n                element = this.element;\r\n                delegateElement = this.widget();\r\n            } else {\r\n                element = delegateElement = $(element);\r\n                this.bindings = this.bindings.add(element);\r\n            }\r\n\r\n            $.each(handlers, function(event, handler) {\r\n                function handlerProxy() {\r\n\r\n                    \/\/ Allow widgets to customize the disabled handling\r\n                    \/\/ - disabled as an array instead of boolean\r\n                    \/\/ - disabled class as method for disabling individual parts\r\n                    if (!suppressDisabledCheck &amp;&amp;\r\n                        (instance.options.disabled === true ||\r\n                            $(this).hasClass(&quot;ui-state-disabled&quot;))) {\r\n                        return;\r\n                    }\r\n                    return (typeof handler === &quot;string&quot; ? instance[handler] : handler)\r\n                        .apply(instance, arguments);\r\n                }\r\n\r\n                \/\/ Copy the guid so direct unbinding works\r\n                if (typeof handler !== &quot;string&quot;) {\r\n                    handlerProxy.guid = handler.guid =\r\n                        handler.guid || handlerProxy.guid || $.guid++;\r\n                }\r\n\r\n                var match = event.match(\/^([\\w:-]*)\\s*(.*)$\/);\r\n                var eventName = match[1] + instance.eventNamespace;\r\n                var selector = match[2];\r\n\r\n                if (selector) {\r\n                    delegateElement.on(eventName, selector, handlerProxy);\r\n                } else {\r\n                    element.on(eventName, handlerProxy);\r\n                }\r\n            });\r\n        },\r\n\r\n        _off: function(element, eventName) {\r\n            eventName = (eventName || &quot;&quot;).split(&quot; &quot;).join(this.eventNamespace + &quot; &quot;) +\r\n                this.eventNamespace;\r\n            element.off(eventName);\r\n\r\n            \/\/ Clear the stack to avoid memory leaks (#10056)\r\n            this.bindings = $(this.bindings.not(element).get());\r\n            this.focusable = $(this.focusable.not(element).get());\r\n            this.hoverable = $(this.hoverable.not(element).get());\r\n        },\r\n\r\n        _delay: function(handler, delay) {\r\n            function handlerProxy() {\r\n                return (typeof handler === &quot;string&quot; ? instance[handler] : handler)\r\n                    .apply(instance, arguments);\r\n            }\r\n            var instance = this;\r\n            return setTimeout(handlerProxy, delay || 0);\r\n        },\r\n\r\n        _hoverable: function(element) {\r\n            this.hoverable = this.hoverable.add(element);\r\n            this._on(element, {\r\n                mouseenter: function(event) {\r\n                    this._addClass($(event.currentTarget), null, &quot;ui-state-hover&quot;);\r\n                },\r\n                mouseleave: function(event) {\r\n                    this._removeClass($(event.currentTarget), null, &quot;ui-state-hover&quot;);\r\n                }\r\n            });\r\n        },\r\n\r\n        _focusable: function(element) {\r\n            this.focusable = this.focusable.add(element);\r\n            this._on(element, {\r\n                focusin: function(event) {\r\n                    this._addClass($(event.currentTarget), null, &quot;ui-state-focus&quot;);\r\n                },\r\n                focusout: function(event) {\r\n                    this._removeClass($(event.currentTarget), null, &quot;ui-state-focus&quot;);\r\n                }\r\n            });\r\n        },\r\n\r\n        _trigger: function(type, event, data) {\r\n            var prop, orig;\r\n            var callback = this.options[type];\r\n\r\n            data = data || {};\r\n            event = $.Event(event);\r\n            event.type = (type === this.widgetEventPrefix ?\r\n                type :\r\n                this.widgetEventPrefix + type).toLowerCase();\r\n\r\n            \/\/ The original event may come from any element\r\n            \/\/ so we need to reset the target on the new event\r\n            event.target = this.element[0];\r\n\r\n            \/\/ Copy original event properties over to the new event\r\n            orig = event.originalEvent;\r\n            if (orig) {\r\n                for (prop in orig) {\r\n                    if (!(prop in event)) {\r\n                        event[prop] = orig[prop];\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.element.trigger(event, data);\r\n            return !(typeof callback === &quot;function&quot; &amp;&amp;\r\n                callback.apply(this.element[0], [event].concat(data)) === false ||\r\n                event.isDefaultPrevented());\r\n        }\r\n    };\r\n\r\n    $.each({\r\n        show: &quot;fadeIn&quot;,\r\n        hide: &quot;fadeOut&quot;\r\n    }, function(method, defaultEffect) {\r\n        $.Widget.prototype[&quot;_&quot; + method] = function(element, options, callback) {\r\n            if (typeof options === &quot;string&quot;) {\r\n                options = {\r\n                    effect: options\r\n                };\r\n            }\r\n\r\n            var hasOptions;\r\n            var effectName = !options ?\r\n                method :\r\n                options === true || typeof options === &quot;number&quot; ?\r\n                defaultEffect :\r\n                options.effect || defaultEffect;\r\n\r\n            options = options || {};\r\n            if (typeof options === &quot;number&quot;) {\r\n                options = {\r\n                    duration: options\r\n                };\r\n            } else if (options === true) {\r\n                options = {};\r\n            }\r\n\r\n            hasOptions = !$.isEmptyObject(options);\r\n            options.complete = callback;\r\n\r\n            if (options.delay) {\r\n                element.delay(options.delay);\r\n            }\r\n\r\n            if (hasOptions &amp;&amp; $.effects &amp;&amp; $.effects.effect[effectName]) {\r\n                element[method](options);\r\n            } else if (effectName !== method &amp;&amp; element[effectName]) {\r\n                element[effectName](options.duration, options.easing, callback);\r\n            } else {\r\n                element.queue(function(next) {\r\n                    $(this)[method]();\r\n                    if (callback) {\r\n                        callback.call(element[0]);\r\n                    }\r\n                    next();\r\n                });\r\n            }\r\n        };\r\n    });\r\n\r\n    var widget = $.widget;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Position 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\r\n     * https:\/\/api.jqueryui.com\/position\/\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Position\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Positions elements relative to other elements.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/position\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/position\/\r\n\r\n\r\n    (function() {\r\n        var cachedScrollbarWidth,\r\n            max = Math.max,\r\n            abs = Math.abs,\r\n            rhorizontal = \/left|center|right\/,\r\n            rvertical = \/top|center|bottom\/,\r\n            roffset = \/[\\+\\-]\\d+(\\.[\\d]+)?%?\/,\r\n            rposition = \/^\\w+\/,\r\n            rpercent = \/%$\/,\r\n            _position = $.fn.position;\r\n\r\n        function getOffsets(offsets, width, height) {\r\n            return [\r\n                parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width \/ 100 : 1),\r\n                parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height \/ 100 : 1)\r\n            ];\r\n        }\r\n\r\n        function parseCss(element, property) {\r\n            return parseInt($.css(element, property), 10) || 0;\r\n        }\r\n\r\n        function isWindow(obj) {\r\n            return obj != null &amp;&amp; obj === obj.window;\r\n        }\r\n\r\n        function getDimensions(elem) {\r\n            var raw = elem[0];\r\n            if (raw.nodeType === 9) {\r\n                return {\r\n                    width: elem.width(),\r\n                    height: elem.height(),\r\n                    offset: {\r\n                        top: 0,\r\n                        left: 0\r\n                    }\r\n                };\r\n            }\r\n            if (isWindow(raw)) {\r\n                return {\r\n                    width: elem.width(),\r\n                    height: elem.height(),\r\n                    offset: {\r\n                        top: elem.scrollTop(),\r\n                        left: elem.scrollLeft()\r\n                    }\r\n                };\r\n            }\r\n            if (raw.preventDefault) {\r\n                return {\r\n                    width: 0,\r\n                    height: 0,\r\n                    offset: {\r\n                        top: raw.pageY,\r\n                        left: raw.pageX\r\n                    }\r\n                };\r\n            }\r\n            return {\r\n                width: elem.outerWidth(),\r\n                height: elem.outerHeight(),\r\n                offset: elem.offset()\r\n            };\r\n        }\r\n\r\n        $.position = {\r\n            scrollbarWidth: function() {\r\n                if (cachedScrollbarWidth !== undefined) {\r\n                    return cachedScrollbarWidth;\r\n                }\r\n                var w1, w2,\r\n                    div = $(&quot;&lt;div style=&quot; +\r\n                        &quot;&#039;display:block;position:absolute;width:200px;height:200px;overflow:hidden;&#039;&gt;&quot; +\r\n                        &quot;&lt;div style=&#039;height:300px;width:auto;&#039;&gt;&lt;\/div&gt;&lt;\/div&gt;&quot;),\r\n                    innerDiv = div.children()[0];\r\n\r\n                $(&quot;body&quot;).append(div);\r\n                w1 = innerDiv.offsetWidth;\r\n                div.css(&quot;overflow&quot;, &quot;scroll&quot;);\r\n\r\n                w2 = innerDiv.offsetWidth;\r\n\r\n                if (w1 === w2) {\r\n                    w2 = div[0].clientWidth;\r\n                }\r\n\r\n                div.remove();\r\n\r\n                return (cachedScrollbarWidth = w1 - w2);\r\n            },\r\n            getScrollInfo: function(within) {\r\n                var overflowX = within.isWindow || within.isDocument ? &quot;&quot; :\r\n                    within.element.css(&quot;overflow-x&quot;),\r\n                    overflowY = within.isWindow || within.isDocument ? &quot;&quot; :\r\n                    within.element.css(&quot;overflow-y&quot;),\r\n                    hasOverflowX = overflowX === &quot;scroll&quot; ||\r\n                    (overflowX === &quot;auto&quot; &amp;&amp; within.width &lt; within.element[0].scrollWidth),\r\n                    hasOverflowY = overflowY === &quot;scroll&quot; ||\r\n                    (overflowY === &quot;auto&quot; &amp;&amp; within.height &lt; within.element[0].scrollHeight);\r\n                return {\r\n                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,\r\n                    height: hasOverflowX ? $.position.scrollbarWidth() : 0\r\n                };\r\n            },\r\n            getWithinInfo: function(element) {\r\n                var withinElement = $(element || window),\r\n                    isElemWindow = isWindow(withinElement[0]),\r\n                    isDocument = !!withinElement[0] &amp;&amp; withinElement[0].nodeType === 9,\r\n                    hasOffset = !isElemWindow &amp;&amp; !isDocument;\r\n                return {\r\n                    element: withinElement,\r\n                    isWindow: isElemWindow,\r\n                    isDocument: isDocument,\r\n                    offset: hasOffset ? $(element).offset() : {\r\n                        left: 0,\r\n                        top: 0\r\n                    },\r\n                    scrollLeft: withinElement.scrollLeft(),\r\n                    scrollTop: withinElement.scrollTop(),\r\n                    width: withinElement.outerWidth(),\r\n                    height: withinElement.outerHeight()\r\n                };\r\n            }\r\n        };\r\n\r\n        $.fn.position = function(options) {\r\n            if (!options || !options.of) {\r\n                return _position.apply(this, arguments);\r\n            }\r\n\r\n            \/\/ Make a copy, we don&#039;t want to modify arguments\r\n            options = $.extend({}, options);\r\n\r\n            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n\r\n                \/\/ Make sure string options are treated as CSS selectors\r\n                target = typeof options.of === &quot;string&quot; ?\r\n                $(document).find(options.of) :\r\n                $(options.of),\r\n\r\n                within = $.position.getWithinInfo(options.within),\r\n                scrollInfo = $.position.getScrollInfo(within),\r\n                collision = (options.collision || &quot;flip&quot;).split(&quot; &quot;),\r\n                offsets = {};\r\n\r\n            dimensions = getDimensions(target);\r\n            if (target[0].preventDefault) {\r\n\r\n                \/\/ Force left top to allow flipping\r\n                options.at = &quot;left top&quot;;\r\n            }\r\n            targetWidth = dimensions.width;\r\n            targetHeight = dimensions.height;\r\n            targetOffset = dimensions.offset;\r\n\r\n            \/\/ Clone to reuse original targetOffset later\r\n            basePosition = $.extend({}, targetOffset);\r\n\r\n            \/\/ Force my and at to have valid horizontal and vertical positions\r\n            \/\/ if a value is missing or invalid, it will be converted to center\r\n            $.each([&quot;my&quot;, &quot;at&quot;], function() {\r\n                var pos = (options[this] || &quot;&quot;).split(&quot; &quot;),\r\n                    horizontalOffset,\r\n                    verticalOffset;\r\n\r\n                if (pos.length === 1) {\r\n                    pos = rhorizontal.test(pos[0]) ?\r\n                        pos.concat([&quot;center&quot;]) :\r\n                        rvertical.test(pos[0]) ? [&quot;center&quot;].concat(pos) : [&quot;center&quot;, &quot;center&quot;];\r\n                }\r\n                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : &quot;center&quot;;\r\n                pos[1] = rvertical.test(pos[1]) ? pos[1] : &quot;center&quot;;\r\n\r\n                \/\/ Calculate offsets\r\n                horizontalOffset = roffset.exec(pos[0]);\r\n                verticalOffset = roffset.exec(pos[1]);\r\n                offsets[this] = [\r\n                    horizontalOffset ? horizontalOffset[0] : 0,\r\n                    verticalOffset ? verticalOffset[0] : 0\r\n                ];\r\n\r\n                \/\/ Reduce to just the positions without the offsets\r\n                options[this] = [\r\n                    rposition.exec(pos[0])[0],\r\n                    rposition.exec(pos[1])[0]\r\n                ];\r\n            });\r\n\r\n            \/\/ Normalize collision option\r\n            if (collision.length === 1) {\r\n                collision[1] = collision[0];\r\n            }\r\n\r\n            if (options.at[0] === &quot;right&quot;) {\r\n                basePosition.left += targetWidth;\r\n            } else if (options.at[0] === &quot;center&quot;) {\r\n                basePosition.left += targetWidth \/ 2;\r\n            }\r\n\r\n            if (options.at[1] === &quot;bottom&quot;) {\r\n                basePosition.top += targetHeight;\r\n            } else if (options.at[1] === &quot;center&quot;) {\r\n                basePosition.top += targetHeight \/ 2;\r\n            }\r\n\r\n            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);\r\n            basePosition.left += atOffset[0];\r\n            basePosition.top += atOffset[1];\r\n\r\n            return this.each(function() {\r\n                var collisionPosition, using,\r\n                    elem = $(this),\r\n                    elemWidth = elem.outerWidth(),\r\n                    elemHeight = elem.outerHeight(),\r\n                    marginLeft = parseCss(this, &quot;marginLeft&quot;),\r\n                    marginTop = parseCss(this, &quot;marginTop&quot;),\r\n                    collisionWidth = elemWidth + marginLeft + parseCss(this, &quot;marginRight&quot;) +\r\n                    scrollInfo.width,\r\n                    collisionHeight = elemHeight + marginTop + parseCss(this, &quot;marginBottom&quot;) +\r\n                    scrollInfo.height,\r\n                    position = $.extend({}, basePosition),\r\n                    myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());\r\n\r\n                if (options.my[0] === &quot;right&quot;) {\r\n                    position.left -= elemWidth;\r\n                } else if (options.my[0] === &quot;center&quot;) {\r\n                    position.left -= elemWidth \/ 2;\r\n                }\r\n\r\n                if (options.my[1] === &quot;bottom&quot;) {\r\n                    position.top -= elemHeight;\r\n                } else if (options.my[1] === &quot;center&quot;) {\r\n                    position.top -= elemHeight \/ 2;\r\n                }\r\n\r\n                position.left += myOffset[0];\r\n                position.top += myOffset[1];\r\n\r\n                collisionPosition = {\r\n                    marginLeft: marginLeft,\r\n                    marginTop: marginTop\r\n                };\r\n\r\n                $.each([&quot;left&quot;, &quot;top&quot;], function(i, dir) {\r\n                    if ($.ui.position[collision[i]]) {\r\n                        $.ui.position[collision[i]][dir](position, {\r\n                            targetWidth: targetWidth,\r\n                            targetHeight: targetHeight,\r\n                            elemWidth: elemWidth,\r\n                            elemHeight: elemHeight,\r\n                            collisionPosition: collisionPosition,\r\n                            collisionWidth: collisionWidth,\r\n                            collisionHeight: collisionHeight,\r\n                            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],\r\n                            my: options.my,\r\n                            at: options.at,\r\n                            within: within,\r\n                            elem: elem\r\n                        });\r\n                    }\r\n                });\r\n\r\n                if (options.using) {\r\n\r\n                    \/\/ Adds feedback as second argument to using callback, if present\r\n                    using = function(props) {\r\n                        var left = targetOffset.left - position.left,\r\n                            right = left + targetWidth - elemWidth,\r\n                            top = targetOffset.top - position.top,\r\n                            bottom = top + targetHeight - elemHeight,\r\n                            feedback = {\r\n                                target: {\r\n                                    element: target,\r\n                                    left: targetOffset.left,\r\n                                    top: targetOffset.top,\r\n                                    width: targetWidth,\r\n                                    height: targetHeight\r\n                                },\r\n                                element: {\r\n                                    element: elem,\r\n                                    left: position.left,\r\n                                    top: position.top,\r\n                                    width: elemWidth,\r\n                                    height: elemHeight\r\n                                },\r\n                                horizontal: right &lt; 0 ? &quot;left&quot; : left &gt; 0 ? &quot;right&quot; : &quot;center&quot;,\r\n                                vertical: bottom &lt; 0 ? &quot;top&quot; : top &gt; 0 ? &quot;bottom&quot; : &quot;middle&quot;\r\n                            };\r\n                        if (targetWidth &lt; elemWidth &amp;&amp; abs(left + right) &lt; targetWidth) {\r\n                            feedback.horizontal = &quot;center&quot;;\r\n                        }\r\n                        if (targetHeight &lt; elemHeight &amp;&amp; abs(top + bottom) &lt; targetHeight) {\r\n                            feedback.vertical = &quot;middle&quot;;\r\n                        }\r\n                        if (max(abs(left), abs(right)) &gt; max(abs(top), abs(bottom))) {\r\n                            feedback.important = &quot;horizontal&quot;;\r\n                        } else {\r\n                            feedback.important = &quot;vertical&quot;;\r\n                        }\r\n                        options.using.call(this, props, feedback);\r\n                    };\r\n                }\r\n\r\n                elem.offset($.extend(position, {\r\n                    using: using\r\n                }));\r\n            });\r\n        };\r\n\r\n        $.ui.position = {\r\n            fit: {\r\n                left: function(position, data) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        outerWidth = within.width,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = withinOffset - collisionPosLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                        newOverRight;\r\n\r\n                    \/\/ Element is wider than within\r\n                    if (data.collisionWidth &gt; outerWidth) {\r\n\r\n                        \/\/ Element is initially over the left side of within\r\n                        if (overLeft &gt; 0 &amp;&amp; overRight &lt;= 0) {\r\n                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                                withinOffset;\r\n                            position.left += overLeft - newOverRight;\r\n\r\n                            \/\/ Element is initially over right side of within\r\n                        } else if (overRight &gt; 0 &amp;&amp; overLeft &lt;= 0) {\r\n                            position.left = withinOffset;\r\n\r\n                            \/\/ Element is initially over both left and right sides of within\r\n                        } else {\r\n                            if (overLeft &gt; overRight) {\r\n                                position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                            } else {\r\n                                position.left = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                        \/\/ Too far left -&gt; align with left edge\r\n                    } else if (overLeft &gt; 0) {\r\n                        position.left += overLeft;\r\n\r\n                        \/\/ Too far right -&gt; align with right edge\r\n                    } else if (overRight &gt; 0) {\r\n                        position.left -= overRight;\r\n\r\n                        \/\/ Adjust based on position and margin\r\n                    } else {\r\n                        position.left = max(position.left - collisionPosLeft, position.left);\r\n                    }\r\n                },\r\n                top: function(position, data) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        outerHeight = data.within.height,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = withinOffset - collisionPosTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                        newOverBottom;\r\n\r\n                    \/\/ Element is taller than within\r\n                    if (data.collisionHeight &gt; outerHeight) {\r\n\r\n                        \/\/ Element is initially over the top of within\r\n                        if (overTop &gt; 0 &amp;&amp; overBottom &lt;= 0) {\r\n                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                                withinOffset;\r\n                            position.top += overTop - newOverBottom;\r\n\r\n                            \/\/ Element is initially over bottom of within\r\n                        } else if (overBottom &gt; 0 &amp;&amp; overTop &lt;= 0) {\r\n                            position.top = withinOffset;\r\n\r\n                            \/\/ Element is initially over both top and bottom of within\r\n                        } else {\r\n                            if (overTop &gt; overBottom) {\r\n                                position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                            } else {\r\n                                position.top = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                        \/\/ Too far up -&gt; align with top\r\n                    } else if (overTop &gt; 0) {\r\n                        position.top += overTop;\r\n\r\n                        \/\/ Too far down -&gt; align with bottom edge\r\n                    } else if (overBottom &gt; 0) {\r\n                        position.top -= overBottom;\r\n\r\n                        \/\/ Adjust based on position and margin\r\n                    } else {\r\n                        position.top = max(position.top - collisionPosTop, position.top);\r\n                    }\r\n                }\r\n            },\r\n            flip: {\r\n                left: function(position, data) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.left + within.scrollLeft,\r\n                        outerWidth = within.width,\r\n                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = collisionPosLeft - offsetLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                        myOffset = data.my[0] === &quot;left&quot; ?\r\n                        -data.elemWidth :\r\n                        data.my[0] === &quot;right&quot; ?\r\n                        data.elemWidth :\r\n                        0,\r\n                        atOffset = data.at[0] === &quot;left&quot; ?\r\n                        data.targetWidth :\r\n                        data.at[0] === &quot;right&quot; ?\r\n                        -data.targetWidth :\r\n                        0,\r\n                        offset = -2 * data.offset[0],\r\n                        newOverRight,\r\n                        newOverLeft;\r\n\r\n                    if (overLeft &lt; 0) {\r\n                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                            outerWidth - withinOffset;\r\n                        if (newOverRight &lt; 0 || newOverRight &lt; abs(overLeft)) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if (overRight &gt; 0) {\r\n                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                            atOffset + offset - offsetLeft;\r\n                        if (newOverLeft &gt; 0 || abs(newOverLeft) &lt; overRight) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                },\r\n                top: function(position, data) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.top + within.scrollTop,\r\n                        outerHeight = within.height,\r\n                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = collisionPosTop - offsetTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                        top = data.my[1] === &quot;top&quot;,\r\n                        myOffset = top ?\r\n                        -data.elemHeight :\r\n                        data.my[1] === &quot;bottom&quot; ?\r\n                        data.elemHeight :\r\n                        0,\r\n                        atOffset = data.at[1] === &quot;top&quot; ?\r\n                        data.targetHeight :\r\n                        data.at[1] === &quot;bottom&quot; ?\r\n                        -data.targetHeight :\r\n                        0,\r\n                        offset = -2 * data.offset[1],\r\n                        newOverTop,\r\n                        newOverBottom;\r\n                    if (overTop &lt; 0) {\r\n                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                            outerHeight - withinOffset;\r\n                        if (newOverBottom &lt; 0 || newOverBottom &lt; abs(overTop)) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if (overBottom &gt; 0) {\r\n                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                            offset - offsetTop;\r\n                        if (newOverTop &gt; 0 || abs(newOverTop) &lt; overBottom) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            flipfit: {\r\n                left: function() {\r\n                    $.ui.position.flip.left.apply(this, arguments);\r\n                    $.ui.position.fit.left.apply(this, arguments);\r\n                },\r\n                top: function() {\r\n                    $.ui.position.flip.top.apply(this, arguments);\r\n                    $.ui.position.fit.top.apply(this, arguments);\r\n                }\r\n            }\r\n        };\r\n\r\n    })();\r\n\r\n    var position = $.ui.position;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI :data 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: :data Selector\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Selects elements which have data stored under the specified key.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/data-selector\/\r\n\r\n\r\n    var data = $.extend($.expr.pseudos, {\r\n        data: $.expr.createPseudo(function(dataName) {\r\n            return function(elem) {\r\n                return !!$.data(elem, dataName);\r\n            };\r\n        })\r\n    });\r\n\r\n    \/*!\r\n     * jQuery UI Disable Selection 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: disableSelection\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Disable selection of text content within the set of matched elements.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/disableSelection\/\r\n\r\n    \/\/ This file is deprecated\r\n\r\n    var disableSelection = $.fn.extend({\r\n        disableSelection: (function() {\r\n            var eventType = &quot;onselectstart&quot; in document.createElement(&quot;div&quot;) ?\r\n                &quot;selectstart&quot; :\r\n                &quot;mousedown&quot;;\r\n\r\n            return function() {\r\n                return this.on(eventType + &quot;.ui-disableSelection&quot;, function(event) {\r\n                    event.preventDefault();\r\n                });\r\n            };\r\n        })(),\r\n\r\n        enableSelection: function() {\r\n            return this.off(&quot;.ui-disableSelection&quot;);\r\n        }\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Focusable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: :focusable Selector\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Selects elements which can be focused.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/focusable-selector\/\r\n\r\n\r\n    \/\/ Selectors\r\n    $.ui.focusable = function(element, hasTabindex) {\r\n        var map, mapName, img, focusableIfVisible, fieldset,\r\n            nodeName = element.nodeName.toLowerCase();\r\n\r\n        if (&quot;area&quot; === nodeName) {\r\n            map = element.parentNode;\r\n            mapName = map.name;\r\n            if (!element.href || !mapName || map.nodeName.toLowerCase() !== &quot;map&quot;) {\r\n                return false;\r\n            }\r\n            img = $(&quot;img[usemap=&#039;#&quot; + mapName + &quot;&#039;]&quot;);\r\n            return img.length &gt; 0 &amp;&amp; img.is(&quot;:visible&quot;);\r\n        }\r\n\r\n        if (\/^(input|select|textarea|button|object)$\/.test(nodeName)) {\r\n            focusableIfVisible = !element.disabled;\r\n\r\n            if (focusableIfVisible) {\r\n\r\n                \/\/ Form controls within a disabled fieldset are disabled.\r\n                \/\/ However, controls within the fieldset&#039;s legend do not get disabled.\r\n                \/\/ Since controls generally aren&#039;t placed inside legends, we skip\r\n                \/\/ this portion of the check.\r\n                fieldset = $(element).closest(&quot;fieldset&quot;)[0];\r\n                if (fieldset) {\r\n                    focusableIfVisible = !fieldset.disabled;\r\n                }\r\n            }\r\n        } else if (&quot;a&quot; === nodeName) {\r\n            focusableIfVisible = element.href || hasTabindex;\r\n        } else {\r\n            focusableIfVisible = hasTabindex;\r\n        }\r\n\r\n        return focusableIfVisible &amp;&amp; $(element).is(&quot;:visible&quot;) &amp;&amp;\r\n            $(element).css(&quot;visibility&quot;) === &quot;visible&quot;;\r\n    };\r\n\r\n    $.extend($.expr.pseudos, {\r\n        focusable: function(element) {\r\n            return $.ui.focusable(element, $.attr(element, &quot;tabindex&quot;) != null);\r\n        }\r\n    });\r\n\r\n    var focusable = $.ui.focusable;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Form Reset Mixin 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Form Reset Mixin\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Refresh input widgets when their form is reset\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/form-reset-mixin\/\r\n\r\n\r\n    var formResetMixin = $.ui.formResetMixin = {\r\n        _formResetHandler: function() {\r\n            var form = $(this);\r\n\r\n            \/\/ Wait for the form reset to actually happen before refreshing\r\n            setTimeout(function() {\r\n                var instances = form.data(&quot;ui-form-reset-instances&quot;);\r\n                $.each(instances, function() {\r\n                    this.refresh();\r\n                });\r\n            });\r\n        },\r\n\r\n        _bindFormResetHandler: function() {\r\n            this.form = $(this.element.prop(&quot;form&quot;));\r\n            if (!this.form.length) {\r\n                return;\r\n            }\r\n\r\n            var instances = this.form.data(&quot;ui-form-reset-instances&quot;) || [];\r\n            if (!instances.length) {\r\n\r\n                \/\/ We don&#039;t use _on() here because we use a single event handler per form\r\n                this.form.on(&quot;reset.ui-form-reset&quot;, this._formResetHandler);\r\n            }\r\n            instances.push(this);\r\n            this.form.data(&quot;ui-form-reset-instances&quot;, instances);\r\n        },\r\n\r\n        _unbindFormResetHandler: function() {\r\n            if (!this.form.length) {\r\n                return;\r\n            }\r\n\r\n            var instances = this.form.data(&quot;ui-form-reset-instances&quot;);\r\n            instances.splice($.inArray(this, instances), 1);\r\n            if (instances.length) {\r\n                this.form.data(&quot;ui-form-reset-instances&quot;, instances);\r\n            } else {\r\n                this.form\r\n                    .removeData(&quot;ui-form-reset-instances&quot;)\r\n                    .off(&quot;reset.ui-form-reset&quot;);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Legacy jQuery Core patches 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Legacy jQuery Core patches\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Backport `.even()`, `.odd()` and `$.escapeSelector` to older jQuery Core versions (deprecated)\r\n\r\n\r\n    \/\/ Support: jQuery 2.2.x or older.\r\n    \/\/ This method has been defined in jQuery 3.0.0.\r\n    \/\/ Code from https:\/\/github.com\/jquery\/jquery\/blob\/e539bac79e666bba95bba86d690b4e609dca2286\/src\/selector\/escapeSelector.js\r\n    if (!$.escapeSelector) {\r\n        $.escapeSelector = function(id) {\r\n            return CSS.escape(id + &quot;&quot;);\r\n        };\r\n    }\r\n\r\n    \/\/ Support: jQuery 3.4.x or older\r\n    \/\/ These methods have been defined in jQuery 3.5.0.\r\n    if (!$.fn.even || !$.fn.odd) {\r\n        $.fn.extend({\r\n            even: function() {\r\n                return this.filter(function(i) {\r\n                    return i % 2 === 0;\r\n                });\r\n            },\r\n            odd: function() {\r\n                return this.filter(function(i) {\r\n                    return i % 2 === 1;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    ;\r\n    \/*!\r\n     * jQuery UI Keycode 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Keycode\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Provide keycodes as keynames\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/jQuery.ui.keyCode\/\r\n\r\n\r\n    var keycode = $.ui.keyCode = {\r\n        BACKSPACE: 8,\r\n        COMMA: 188,\r\n        DELETE: 46,\r\n        DOWN: 40,\r\n        END: 35,\r\n        ENTER: 13,\r\n        ESCAPE: 27,\r\n        HOME: 36,\r\n        LEFT: 37,\r\n        PAGE_DOWN: 34,\r\n        PAGE_UP: 33,\r\n        PERIOD: 190,\r\n        RIGHT: 39,\r\n        SPACE: 32,\r\n        TAB: 9,\r\n        UP: 38\r\n    };\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Labels 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: labels\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Find all the labels associated with a given input\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/labels\/\r\n\r\n\r\n    var labels = $.fn.labels = function() {\r\n        var ancestor, selector, id, labels, ancestors;\r\n\r\n        if (!this.length) {\r\n            return this.pushStack([]);\r\n        }\r\n\r\n        \/\/ Check control.labels first\r\n        if (this[0].labels &amp;&amp; this[0].labels.length) {\r\n            return this.pushStack(this[0].labels);\r\n        }\r\n\r\n        \/\/ If `control.labels` is empty - e.g. inside of document fragments - find\r\n        \/\/ the labels manually\r\n        labels = this.eq(0).parents(&quot;label&quot;);\r\n\r\n        \/\/ Look for the label based on the id\r\n        id = this.attr(&quot;id&quot;);\r\n        if (id) {\r\n\r\n            \/\/ We don&#039;t search against the document in case the element\r\n            \/\/ is disconnected from the DOM\r\n            ancestor = this.eq(0).parents().last();\r\n\r\n            \/\/ Get a full set of top level ancestors\r\n            ancestors = ancestor.add(ancestor.length ? ancestor.siblings() : this.siblings());\r\n\r\n            \/\/ Create a selector for the label based on the id\r\n            selector = &quot;label[for=&#039;&quot; + CSS.escape(id) + &quot;&#039;]&quot;;\r\n\r\n            labels = labels.add(ancestors.find(selector).addBack(selector));\r\n\r\n        }\r\n\r\n        \/\/ Return whatever we have found for labels\r\n        return this.pushStack(labels);\r\n    };\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Scroll Parent 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: scrollParent\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Get the closest ancestor element that is scrollable.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/scrollParent\/\r\n\r\n\r\n    var scrollParent = $.fn.scrollParent = function(includeHidden) {\r\n        var position = this.css(&quot;position&quot;),\r\n            excludeStaticParent = position === &quot;absolute&quot;,\r\n            overflowRegex = includeHidden ? \/(auto|scroll|hidden)\/ : \/(auto|scroll)\/,\r\n            scrollParent = this.parents().filter(function() {\r\n                var parent = $(this);\r\n                if (excludeStaticParent &amp;&amp; parent.css(&quot;position&quot;) === &quot;static&quot;) {\r\n                    return false;\r\n                }\r\n                return overflowRegex.test(parent.css(&quot;overflow&quot;) + parent.css(&quot;overflow-y&quot;) +\r\n                    parent.css(&quot;overflow-x&quot;));\r\n            }).eq(0);\r\n\r\n        return position === &quot;fixed&quot; || !scrollParent.length ?\r\n            $(this[0].ownerDocument || document) :\r\n            scrollParent;\r\n    };\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Tabbable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: :tabbable Selector\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Selects elements which can be tabbed to.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/tabbable-selector\/\r\n\r\n\r\n    var tabbable = $.extend($.expr.pseudos, {\r\n        tabbable: function(element) {\r\n            var tabIndex = $.attr(element, &quot;tabindex&quot;),\r\n                hasTabindex = tabIndex != null;\r\n            return (!hasTabindex || tabIndex &gt;= 0) &amp;&amp; $.ui.focusable(element, hasTabindex);\r\n        }\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Unique ID 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: uniqueId\r\n    \/\/&gt;&gt;group: Core\r\n    \/\/&gt;&gt;description: Functions to generate and remove uniqueId&#039;s\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/uniqueId\/\r\n\r\n\r\n    var uniqueId = $.fn.extend({\r\n        uniqueId: (function() {\r\n            var uuid = 0;\r\n\r\n            return function() {\r\n                return this.each(function() {\r\n                    if (!this.id) {\r\n                        this.id = &quot;ui-id-&quot; + (++uuid);\r\n                    }\r\n                });\r\n            };\r\n        })(),\r\n\r\n        removeUniqueId: function() {\r\n            return this.each(function() {\r\n                if (\/^ui-id-\\d+$\/.test(this.id)) {\r\n                    $(this).removeAttr(&quot;id&quot;);\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Mouse 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Mouse\r\n    \/\/&gt;&gt;group: Widgets\r\n    \/\/&gt;&gt;description: Abstracts mouse-based interactions to assist in creating certain widgets.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/mouse\/\r\n\r\n\r\n    var mouseHandled = false;\r\n    $(document).on(&quot;mouseup&quot;, function() {\r\n        mouseHandled = false;\r\n    });\r\n\r\n    var widgetsMouse = $.widget(&quot;ui.mouse&quot;, {\r\n        version: &quot;1.14.1&quot;,\r\n        options: {\r\n            cancel: &quot;input, textarea, button, select, option&quot;,\r\n            distance: 1,\r\n            delay: 0\r\n        },\r\n        _mouseInit: function() {\r\n            var that = this;\r\n\r\n            this.element\r\n                .on(&quot;mousedown.&quot; + this.widgetName, function(event) {\r\n                    return that._mouseDown(event);\r\n                })\r\n                .on(&quot;click.&quot; + this.widgetName, function(event) {\r\n                    if (true === $.data(event.target, that.widgetName + &quot;.preventClickEvent&quot;)) {\r\n                        $.removeData(event.target, that.widgetName + &quot;.preventClickEvent&quot;);\r\n                        event.stopImmediatePropagation();\r\n                        return false;\r\n                    }\r\n                });\r\n\r\n            this.started = false;\r\n        },\r\n\r\n        \/\/ TODO: make sure destroying one instance of mouse doesn&#039;t mess with\r\n        \/\/ other instances of mouse\r\n        _mouseDestroy: function() {\r\n            this.element.off(&quot;.&quot; + this.widgetName);\r\n            if (this._mouseMoveDelegate) {\r\n                this.document\r\n                    .off(&quot;mousemove.&quot; + this.widgetName, this._mouseMoveDelegate)\r\n                    .off(&quot;mouseup.&quot; + this.widgetName, this._mouseUpDelegate);\r\n            }\r\n        },\r\n\r\n        _mouseDown: function(event) {\r\n\r\n            \/\/ don&#039;t let more than one widget handle mouseStart\r\n            if (mouseHandled) {\r\n                return;\r\n            }\r\n\r\n            this._mouseMoved = false;\r\n\r\n            \/\/ We may have missed mouseup (out of window)\r\n            if (this._mouseStarted) {\r\n                this._mouseUp(event);\r\n            }\r\n\r\n            this._mouseDownEvent = event;\r\n\r\n            var that = this,\r\n                btnIsLeft = event.which === 1,\r\n                elIsCancel = typeof this.options.cancel === &quot;string&quot; ?\r\n                $(event.target).closest(this.options.cancel).length :\r\n                false;\r\n            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\r\n                return true;\r\n            }\r\n\r\n            this.mouseDelayMet = !this.options.delay;\r\n            if (!this.mouseDelayMet) {\r\n                this._mouseDelayTimer = setTimeout(function() {\r\n                    that.mouseDelayMet = true;\r\n                }, this.options.delay);\r\n            }\r\n\r\n            if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {\r\n                this._mouseStarted = (this._mouseStart(event) !== false);\r\n                if (!this._mouseStarted) {\r\n                    event.preventDefault();\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            \/\/ Click event may never have fired (Gecko &amp; Opera)\r\n            if (true === $.data(event.target, this.widgetName + &quot;.preventClickEvent&quot;)) {\r\n                $.removeData(event.target, this.widgetName + &quot;.preventClickEvent&quot;);\r\n            }\r\n\r\n            \/\/ These delegates are required to keep context\r\n            this._mouseMoveDelegate = function(event) {\r\n                return that._mouseMove(event);\r\n            };\r\n            this._mouseUpDelegate = function(event) {\r\n                return that._mouseUp(event);\r\n            };\r\n\r\n            this.document\r\n                .on(&quot;mousemove.&quot; + this.widgetName, this._mouseMoveDelegate)\r\n                .on(&quot;mouseup.&quot; + this.widgetName, this._mouseUpDelegate);\r\n\r\n            event.preventDefault();\r\n\r\n            mouseHandled = true;\r\n            return true;\r\n        },\r\n\r\n        _mouseMove: function(event) {\r\n\r\n            \/\/ Only check for mouseups outside the document if you&#039;ve moved inside the document\r\n            \/\/ at least once.\r\n            if (this._mouseMoved &amp;&amp; !event.which) {\r\n\r\n                \/\/ Support: Safari &lt;=8 - 9\r\n                \/\/ Safari sets which to 0 if you press any of the following keys\r\n                \/\/ during a drag (#14461)\r\n                if (event.originalEvent.altKey || event.originalEvent.ctrlKey ||\r\n                    event.originalEvent.metaKey || event.originalEvent.shiftKey) {\r\n                    this.ignoreMissingWhich = true;\r\n                } else if (!this.ignoreMissingWhich) {\r\n                    return this._mouseUp(event);\r\n                }\r\n            }\r\n\r\n            if (event.which || event.button) {\r\n                this._mouseMoved = true;\r\n            }\r\n\r\n            if (this._mouseStarted) {\r\n                this._mouseDrag(event);\r\n                return event.preventDefault();\r\n            }\r\n\r\n            if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {\r\n                this._mouseStarted =\r\n                    (this._mouseStart(this._mouseDownEvent, event) !== false);\r\n                if (this._mouseStarted) {\r\n                    this._mouseDrag(event);\r\n                } else {\r\n                    this._mouseUp(event);\r\n                }\r\n            }\r\n\r\n            return !this._mouseStarted;\r\n        },\r\n\r\n        _mouseUp: function(event) {\r\n            this.document\r\n                .off(&quot;mousemove.&quot; + this.widgetName, this._mouseMoveDelegate)\r\n                .off(&quot;mouseup.&quot; + this.widgetName, this._mouseUpDelegate);\r\n\r\n            if (this._mouseStarted) {\r\n                this._mouseStarted = false;\r\n\r\n                if (event.target === this._mouseDownEvent.target) {\r\n                    $.data(event.target, this.widgetName + &quot;.preventClickEvent&quot;, true);\r\n                }\r\n\r\n                this._mouseStop(event);\r\n            }\r\n\r\n            if (this._mouseDelayTimer) {\r\n                clearTimeout(this._mouseDelayTimer);\r\n                delete this._mouseDelayTimer;\r\n            }\r\n\r\n            this.ignoreMissingWhich = false;\r\n            mouseHandled = false;\r\n            event.preventDefault();\r\n        },\r\n\r\n        _mouseDistanceMet: function(event) {\r\n            return (Math.max(\r\n                Math.abs(this._mouseDownEvent.pageX - event.pageX),\r\n                Math.abs(this._mouseDownEvent.pageY - event.pageY)\r\n            ) &gt;= this.options.distance);\r\n        },\r\n\r\n        _mouseDelayMet: function( \/* event *\/ ) {\r\n            return this.mouseDelayMet;\r\n        },\r\n\r\n        \/\/ These are placeholder methods, to be overriden by extending plugin\r\n        _mouseStart: function( \/* event *\/ ) {},\r\n        _mouseDrag: function( \/* event *\/ ) {},\r\n        _mouseStop: function( \/* event *\/ ) {},\r\n        _mouseCapture: function( \/* event *\/ ) {\r\n            return true;\r\n        }\r\n    });\r\n\r\n\r\n\r\n    \/\/ $.ui.plugin is deprecated. Use $.widget() extensions instead.\r\n    var plugin = $.ui.plugin = {\r\n        add: function(module, option, set) {\r\n            var i,\r\n                proto = $.ui[module].prototype;\r\n            for (i in set) {\r\n                proto.plugins[i] = proto.plugins[i] || [];\r\n                proto.plugins[i].push([option, set[i]]);\r\n            }\r\n        },\r\n        call: function(instance, name, args, allowDisconnected) {\r\n            var i,\r\n                set = instance.plugins[name];\r\n\r\n            if (!set) {\r\n                return;\r\n            }\r\n\r\n            if (!allowDisconnected &amp;&amp; (!instance.element[0].parentNode ||\r\n                    instance.element[0].parentNode.nodeType === 11)) {\r\n                return;\r\n            }\r\n\r\n            for (i = 0; i &lt; set.length; i++) {\r\n                if (instance.options[set[i][0]]) {\r\n                    set[i][1].apply(instance.element, args);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Draggable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Draggable\r\n    \/\/&gt;&gt;group: Interactions\r\n    \/\/&gt;&gt;description: Enables dragging functionality for any element.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/draggable\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/draggable\/\r\n    \/\/&gt;&gt;css.structure: ..\/..\/themes\/base\/draggable.css\r\n\r\n\r\n    $.widget(&quot;ui.draggable&quot;, $.ui.mouse, {\r\n        version: &quot;1.14.1&quot;,\r\n        widgetEventPrefix: &quot;drag&quot;,\r\n        options: {\r\n            addClasses: true,\r\n            appendTo: &quot;parent&quot;,\r\n            axis: false,\r\n            connectToSortable: false,\r\n            containment: false,\r\n            cursor: &quot;auto&quot;,\r\n            cursorAt: false,\r\n            grid: false,\r\n            handle: false,\r\n            helper: &quot;original&quot;,\r\n            iframeFix: false,\r\n            opacity: false,\r\n            refreshPositions: false,\r\n            revert: false,\r\n            revertDuration: 500,\r\n            scope: &quot;default&quot;,\r\n            scroll: true,\r\n            scrollSensitivity: 20,\r\n            scrollSpeed: 20,\r\n            snap: false,\r\n            snapMode: &quot;both&quot;,\r\n            snapTolerance: 20,\r\n            stack: false,\r\n            zIndex: false,\r\n\r\n            \/\/ Callbacks\r\n            drag: null,\r\n            start: null,\r\n            stop: null\r\n        },\r\n        _create: function() {\r\n\r\n            if (this.options.helper === &quot;original&quot;) {\r\n                this._setPositionRelative();\r\n            }\r\n            if (this.options.addClasses) {\r\n                this._addClass(&quot;ui-draggable&quot;);\r\n            }\r\n            this._setHandleClassName();\r\n\r\n            this._mouseInit();\r\n        },\r\n\r\n        _setOption: function(key, value) {\r\n            this._super(key, value);\r\n            if (key === &quot;handle&quot;) {\r\n                this._removeHandleClassName();\r\n                this._setHandleClassName();\r\n            }\r\n        },\r\n\r\n        _destroy: function() {\r\n            if ((this.helper || this.element).is(&quot;.ui-draggable-dragging&quot;)) {\r\n                this.destroyOnClear = true;\r\n                return;\r\n            }\r\n            this._removeHandleClassName();\r\n            this._mouseDestroy();\r\n        },\r\n\r\n        _mouseCapture: function(event) {\r\n            var o = this.options;\r\n\r\n            \/\/ Among others, prevent a drag on a resizable-handle\r\n            if (this.helper || o.disabled ||\r\n                $(event.target).closest(&quot;.ui-resizable-handle&quot;).length &gt; 0) {\r\n                return false;\r\n            }\r\n\r\n            \/\/Quit if we&#039;re not on a valid handle\r\n            this.handle = this._getHandle(event);\r\n            if (!this.handle) {\r\n                return false;\r\n            }\r\n\r\n            this._blurActiveElement(event);\r\n\r\n            this._blockFrames(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix);\r\n\r\n            return true;\r\n\r\n        },\r\n\r\n        _blockFrames: function(selector) {\r\n            this.iframeBlocks = this.document.find(selector).map(function() {\r\n                var iframe = $(this);\r\n\r\n                return $(&quot;&lt;div&gt;&quot;)\r\n                    .css(&quot;position&quot;, &quot;absolute&quot;)\r\n                    .appendTo(iframe.parent())\r\n                    .outerWidth(iframe.outerWidth())\r\n                    .outerHeight(iframe.outerHeight())\r\n                    .offset(iframe.offset())[0];\r\n            });\r\n        },\r\n\r\n        _unblockFrames: function() {\r\n            if (this.iframeBlocks) {\r\n                this.iframeBlocks.remove();\r\n                delete this.iframeBlocks;\r\n            }\r\n        },\r\n\r\n        _blurActiveElement: function(event) {\r\n            var activeElement = this.document[0].activeElement,\r\n                target = $(event.target);\r\n\r\n            \/\/ Don&#039;t blur if the event occurred on an element that is within\r\n            \/\/ the currently focused element\r\n            \/\/ See #10527, #12472\r\n            if (target.closest(activeElement).length) {\r\n                return;\r\n            }\r\n\r\n            \/\/ Blur any element that currently has focus, see #4261\r\n            $(activeElement).trigger(&quot;blur&quot;);\r\n        },\r\n\r\n        _mouseStart: function(event) {\r\n\r\n            var o = this.options;\r\n\r\n            \/\/Create and append the visible helper\r\n            this.helper = this._createHelper(event);\r\n\r\n            this._addClass(this.helper, &quot;ui-draggable-dragging&quot;);\r\n\r\n            \/\/Cache the helper size\r\n            this._cacheHelperProportions();\r\n\r\n            \/\/If ddmanager is used for droppables, set the global draggable\r\n            if ($.ui.ddmanager) {\r\n                $.ui.ddmanager.current = this;\r\n            }\r\n\r\n            \/*\r\n             * - Position generation -\r\n             * This block generates everything position related - it&#039;s the core of draggables.\r\n             *\/\r\n\r\n            \/\/Cache the margins of the original element\r\n            this._cacheMargins();\r\n\r\n            \/\/Store the helper&#039;s css position\r\n            this.cssPosition = this.helper.css(&quot;position&quot;);\r\n            this.scrollParent = this.helper.scrollParent(true);\r\n            this.offsetParent = this.helper.offsetParent();\r\n            this.hasFixedAncestor = this.helper.parents().filter(function() {\r\n                return $(this).css(&quot;position&quot;) === &quot;fixed&quot;;\r\n            }).length &gt; 0;\r\n\r\n            \/\/The element&#039;s absolute position on the page minus margins\r\n            this.positionAbs = this.element.offset();\r\n            this._refreshOffsets(event);\r\n\r\n            \/\/Generate the original position\r\n            this.originalPosition = this.position = this._generatePosition(event, false);\r\n            this.originalPageX = event.pageX;\r\n            this.originalPageY = event.pageY;\r\n\r\n            \/\/Adjust the mouse offset relative to the helper if &quot;cursorAt&quot; is supplied\r\n            if (o.cursorAt) {\r\n                this._adjustOffsetFromHelper(o.cursorAt);\r\n            }\r\n\r\n            \/\/Set a containment if given in the options\r\n            this._setContainment();\r\n\r\n            \/\/Trigger event + callbacks\r\n            if (this._trigger(&quot;start&quot;, event) === false) {\r\n                this._clear();\r\n                return false;\r\n            }\r\n\r\n            \/\/Recache the helper size\r\n            this._cacheHelperProportions();\r\n\r\n            \/\/Prepare the droppable offsets\r\n            if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour) {\r\n                $.ui.ddmanager.prepareOffsets(this, event);\r\n            }\r\n\r\n            \/\/ Execute the drag once - this causes the helper not to be visible before getting its\r\n            \/\/ correct position\r\n            this._mouseDrag(event, true);\r\n\r\n            \/\/ If the ddmanager is used for droppables, inform the manager that dragging has started\r\n            \/\/ (see #5003)\r\n            if ($.ui.ddmanager) {\r\n                $.ui.ddmanager.dragStart(this, event);\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        _refreshOffsets: function(event) {\r\n            this.offset = {\r\n                top: this.positionAbs.top - this.margins.top,\r\n                left: this.positionAbs.left - this.margins.left,\r\n                scroll: false,\r\n                parent: this._getParentOffset(),\r\n                relative: this._getRelativeOffset()\r\n            };\r\n\r\n            this.offset.click = {\r\n                left: event.pageX - this.offset.left,\r\n                top: event.pageY - this.offset.top\r\n            };\r\n        },\r\n\r\n        _mouseDrag: function(event, noPropagation) {\r\n\r\n            \/\/ reset any necessary cached properties (see #5009)\r\n            if (this.hasFixedAncestor) {\r\n                this.offset.parent = this._getParentOffset();\r\n            }\r\n\r\n            \/\/Compute the helpers position\r\n            this.position = this._generatePosition(event, true);\r\n            this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);\r\n\r\n            \/\/Call plugins and callbacks and use the resulting position if something is returned\r\n            if (!noPropagation) {\r\n                var ui = this._uiHash();\r\n                if (this._trigger(&quot;drag&quot;, event, ui) === false) {\r\n                    this._mouseUp(new $.Event(&quot;mouseup&quot;, event));\r\n                    return false;\r\n                }\r\n                this.position = ui.position;\r\n            }\r\n\r\n            this.helper[0].style.left = this.position.left + &quot;px&quot;;\r\n            this.helper[0].style.top = this.position.top + &quot;px&quot;;\r\n\r\n            if ($.ui.ddmanager) {\r\n                $.ui.ddmanager.drag(this, event);\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        _mouseStop: function(event) {\r\n\r\n            \/\/If we are using droppables, inform the manager about the drop\r\n            var that = this,\r\n                dropped = false;\r\n            if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour) {\r\n                dropped = $.ui.ddmanager.drop(this, event);\r\n            }\r\n\r\n            \/\/if a drop comes from outside (a sortable)\r\n            if (this.dropped) {\r\n                dropped = this.dropped;\r\n                this.dropped = false;\r\n            }\r\n\r\n            if ((this.options.revert === &quot;invalid&quot; &amp;&amp; !dropped) ||\r\n                (this.options.revert === &quot;valid&quot; &amp;&amp; dropped) ||\r\n                this.options.revert === true || (typeof this.options.revert === &quot;function&quot; &amp;&amp;\r\n                    this.options.revert.call(this.element, dropped))\r\n            ) {\r\n                $(this.helper).animate(\r\n                    this.originalPosition,\r\n                    parseInt(this.options.revertDuration, 10),\r\n                    function() {\r\n                        if (that._trigger(&quot;stop&quot;, event) !== false) {\r\n                            that._clear();\r\n                        }\r\n                    }\r\n                );\r\n            } else {\r\n                if (this._trigger(&quot;stop&quot;, event) !== false) {\r\n                    this._clear();\r\n                }\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        _mouseUp: function(event) {\r\n            this._unblockFrames();\r\n\r\n            \/\/ If the ddmanager is used for droppables, inform the manager that dragging has stopped\r\n            \/\/ (see #5003)\r\n            if ($.ui.ddmanager) {\r\n                $.ui.ddmanager.dragStop(this, event);\r\n            }\r\n\r\n            \/\/ Only need to focus if the event occurred on the draggable itself, see #10527\r\n            if (this.handleElement.is(event.target)) {\r\n\r\n                \/\/ The interaction is over; whether or not the click resulted in a drag,\r\n                \/\/ focus the element\r\n                this.element.trigger(&quot;focus&quot;);\r\n            }\r\n\r\n            return $.ui.mouse.prototype._mouseUp.call(this, event);\r\n        },\r\n\r\n        cancel: function() {\r\n\r\n            if (this.helper.is(&quot;.ui-draggable-dragging&quot;)) {\r\n                this._mouseUp(new $.Event(&quot;mouseup&quot;, {\r\n                    target: this.element[0]\r\n                }));\r\n            } else {\r\n                this._clear();\r\n            }\r\n\r\n            return this;\r\n\r\n        },\r\n\r\n        _getHandle: function(event) {\r\n            return this.options.handle ?\r\n                !!$(event.target).closest(this.element.find(this.options.handle)).length :\r\n                true;\r\n        },\r\n\r\n        _setHandleClassName: function() {\r\n            this.handleElement = this.options.handle ?\r\n                this.element.find(this.options.handle) : this.element;\r\n            this._addClass(this.handleElement, &quot;ui-draggable-handle&quot;);\r\n        },\r\n\r\n        _removeHandleClassName: function() {\r\n            this._removeClass(this.handleElement, &quot;ui-draggable-handle&quot;);\r\n        },\r\n\r\n        _createHelper: function(event) {\r\n\r\n            var o = this.options,\r\n                helperIsFunction = typeof o.helper === &quot;function&quot;,\r\n                helper = helperIsFunction ?\r\n                $(o.helper.apply(this.element[0], [event])) :\r\n                (o.helper === &quot;clone&quot; ?\r\n                    this.element.clone().removeAttr(&quot;id&quot;) :\r\n                    this.element);\r\n\r\n            if (!helper.parents(&quot;body&quot;).length) {\r\n                helper.appendTo((o.appendTo === &quot;parent&quot; ?\r\n                    this.element[0].parentNode :\r\n                    o.appendTo));\r\n            }\r\n\r\n            \/\/ https:\/\/bugs.jqueryui.com\/ticket\/9446\r\n            \/\/ a helper function can return the original element\r\n            \/\/ which wouldn&#039;t have been set to relative in _create\r\n            if (helperIsFunction &amp;&amp; helper[0] === this.element[0]) {\r\n                this._setPositionRelative();\r\n            }\r\n\r\n            if (helper[0] !== this.element[0] &amp;&amp;\r\n                !(\/(fixed|absolute)\/).test(helper.css(&quot;position&quot;))) {\r\n                helper.css(&quot;position&quot;, &quot;absolute&quot;);\r\n            }\r\n\r\n            return helper;\r\n\r\n        },\r\n\r\n        _setPositionRelative: function() {\r\n            if (!(\/^(?:r|a|f)\/).test(this.element.css(&quot;position&quot;))) {\r\n                this.element[0].style.position = &quot;relative&quot;;\r\n            }\r\n        },\r\n\r\n        _adjustOffsetFromHelper: function(obj) {\r\n            if (typeof obj === &quot;string&quot;) {\r\n                obj = obj.split(&quot; &quot;);\r\n            }\r\n            if (Array.isArray(obj)) {\r\n                obj = {\r\n                    left: +obj[0],\r\n                    top: +obj[1] || 0\r\n                };\r\n            }\r\n            if (&quot;left&quot; in obj) {\r\n                this.offset.click.left = obj.left + this.margins.left;\r\n            }\r\n            if (&quot;right&quot; in obj) {\r\n                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\r\n            }\r\n            if (&quot;top&quot; in obj) {\r\n                this.offset.click.top = obj.top + this.margins.top;\r\n            }\r\n            if (&quot;bottom&quot; in obj) {\r\n                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\r\n            }\r\n        },\r\n\r\n        _isRootNode: function(element) {\r\n            return (\/(html|body)\/i).test(element.tagName) || element === this.document[0];\r\n        },\r\n\r\n        _getParentOffset: function() {\r\n\r\n            \/\/Get the offsetParent and cache its position\r\n            var po = this.offsetParent.offset(),\r\n                document = this.document[0];\r\n\r\n            \/\/ This is a special case where we need to modify a offset calculated on start, since the\r\n            \/\/ following happened:\r\n            \/\/ 1. The position of the helper is absolute, so it&#039;s position is calculated based on the\r\n            \/\/ next positioned parent\r\n            \/\/ 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#039;t\r\n            \/\/ the document, which means that the scroll is included in the initial calculation of the\r\n            \/\/ offset of the parent, and never recalculated upon drag\r\n            if (this.cssPosition === &quot;absolute&quot; &amp;&amp; this.scrollParent[0] !== document &amp;&amp;\r\n                $.contains(this.scrollParent[0], this.offsetParent[0])) {\r\n                po.left += this.scrollParent.scrollLeft();\r\n                po.top += this.scrollParent.scrollTop();\r\n            }\r\n\r\n            if (this._isRootNode(this.offsetParent[0])) {\r\n                po = {\r\n                    top: 0,\r\n                    left: 0\r\n                };\r\n            }\r\n\r\n            return {\r\n                top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;), 10) || 0),\r\n                left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;), 10) || 0)\r\n            };\r\n\r\n        },\r\n\r\n        _getRelativeOffset: function() {\r\n            if (this.cssPosition !== &quot;relative&quot;) {\r\n                return {\r\n                    top: 0,\r\n                    left: 0\r\n                };\r\n            }\r\n\r\n            var p = this.element.position(),\r\n                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);\r\n\r\n            return {\r\n                top: p.top - (parseInt(this.helper.css(&quot;top&quot;), 10) || 0) +\r\n                    (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),\r\n                left: p.left - (parseInt(this.helper.css(&quot;left&quot;), 10) || 0) +\r\n                    (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)\r\n            };\r\n\r\n        },\r\n\r\n        _cacheMargins: function() {\r\n            this.margins = {\r\n                left: (parseInt(this.element.css(&quot;marginLeft&quot;), 10) || 0),\r\n                top: (parseInt(this.element.css(&quot;marginTop&quot;), 10) || 0),\r\n                right: (parseInt(this.element.css(&quot;marginRight&quot;), 10) || 0),\r\n                bottom: (parseInt(this.element.css(&quot;marginBottom&quot;), 10) || 0)\r\n            };\r\n        },\r\n\r\n        _cacheHelperProportions: function() {\r\n            this.helperProportions = {\r\n                width: this.helper.outerWidth(),\r\n                height: this.helper.outerHeight()\r\n            };\r\n        },\r\n\r\n        _setContainment: function() {\r\n\r\n            var isUserScrollable, c, ce,\r\n                o = this.options,\r\n                document = this.document[0];\r\n\r\n            this.relativeContainer = null;\r\n\r\n            if (!o.containment) {\r\n                this.containment = null;\r\n                return;\r\n            }\r\n\r\n            if (o.containment === &quot;window&quot;) {\r\n                this.containment = [\r\n                    $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\r\n                    $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,\r\n                    $(window).scrollLeft() + $(window).width() -\r\n                    this.helperProportions.width - this.margins.left,\r\n                    $(window).scrollTop() +\r\n                    ($(window).height() || document.body.parentNode.scrollHeight) -\r\n                    this.helperProportions.height - this.margins.top\r\n                ];\r\n                return;\r\n            }\r\n\r\n            if (o.containment === &quot;document&quot;) {\r\n                this.containment = [\r\n                    0,\r\n                    0,\r\n                    $(document).width() - this.helperProportions.width - this.margins.left,\r\n                    ($(document).height() || document.body.parentNode.scrollHeight) -\r\n                    this.helperProportions.height - this.margins.top\r\n                ];\r\n                return;\r\n            }\r\n\r\n            if (o.containment.constructor === Array) {\r\n                this.containment = o.containment;\r\n                return;\r\n            }\r\n\r\n            if (o.containment === &quot;parent&quot;) {\r\n                o.containment = this.helper[0].parentNode;\r\n            }\r\n\r\n            c = $(o.containment);\r\n            ce = c[0];\r\n\r\n            if (!ce) {\r\n                return;\r\n            }\r\n\r\n            isUserScrollable = \/(scroll|auto)\/.test(c.css(&quot;overflow&quot;));\r\n\r\n            this.containment = [\r\n                (parseInt(c.css(&quot;borderLeftWidth&quot;), 10) || 0) +\r\n                (parseInt(c.css(&quot;paddingLeft&quot;), 10) || 0),\r\n                (parseInt(c.css(&quot;borderTopWidth&quot;), 10) || 0) +\r\n                (parseInt(c.css(&quot;paddingTop&quot;), 10) || 0),\r\n                (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -\r\n                (parseInt(c.css(&quot;borderRightWidth&quot;), 10) || 0) -\r\n                (parseInt(c.css(&quot;paddingRight&quot;), 10) || 0) -\r\n                this.helperProportions.width -\r\n                this.margins.left -\r\n                this.margins.right,\r\n                (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -\r\n                (parseInt(c.css(&quot;borderBottomWidth&quot;), 10) || 0) -\r\n                (parseInt(c.css(&quot;paddingBottom&quot;), 10) || 0) -\r\n                this.helperProportions.height -\r\n                this.margins.top -\r\n                this.margins.bottom\r\n            ];\r\n            this.relativeContainer = c;\r\n        },\r\n\r\n        _convertPositionTo: function(d, pos) {\r\n\r\n            if (!pos) {\r\n                pos = this.position;\r\n            }\r\n\r\n            var mod = d === &quot;absolute&quot; ? 1 : -1,\r\n                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);\r\n\r\n            return {\r\n                top: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pos.top +\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.top * mod +\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.top * mod -\r\n                    ((this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.offset.scroll.top :\r\n                        (scrollIsRootNode ? 0 : this.offset.scroll.top)) * mod)\r\n                ),\r\n                left: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pos.left +\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.left * mod +\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.left * mod -\r\n                    ((this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.offset.scroll.left :\r\n                        (scrollIsRootNode ? 0 : this.offset.scroll.left)) * mod)\r\n                )\r\n            };\r\n\r\n        },\r\n\r\n        _generatePosition: function(event, constrainPosition) {\r\n\r\n            var containment, co, top, left,\r\n                o = this.options,\r\n                scrollIsRootNode = this._isRootNode(this.scrollParent[0]),\r\n                pageX = event.pageX,\r\n                pageY = event.pageY;\r\n\r\n            \/\/ Cache the scroll\r\n            if (!scrollIsRootNode || !this.offset.scroll) {\r\n                this.offset.scroll = {\r\n                    top: this.scrollParent.scrollTop(),\r\n                    left: this.scrollParent.scrollLeft()\r\n                };\r\n            }\r\n\r\n            \/*\r\n             * - Position constraining -\r\n             * Constrain the position to a mix of grid, containment.\r\n             *\/\r\n\r\n            \/\/ If we are not dragging yet, we won&#039;t check for options\r\n            if (constrainPosition) {\r\n                if (this.containment) {\r\n                    if (this.relativeContainer) {\r\n                        co = this.relativeContainer.offset();\r\n                        containment = [\r\n                            this.containment[0] + co.left,\r\n                            this.containment[1] + co.top,\r\n                            this.containment[2] + co.left,\r\n                            this.containment[3] + co.top\r\n                        ];\r\n                    } else {\r\n                        containment = this.containment;\r\n                    }\r\n\r\n                    if (event.pageX - this.offset.click.left &lt; containment[0]) {\r\n                        pageX = containment[0] + this.offset.click.left;\r\n                    }\r\n                    if (event.pageY - this.offset.click.top &lt; containment[1]) {\r\n                        pageY = containment[1] + this.offset.click.top;\r\n                    }\r\n                    if (event.pageX - this.offset.click.left &gt; containment[2]) {\r\n                        pageX = containment[2] + this.offset.click.left;\r\n                    }\r\n                    if (event.pageY - this.offset.click.top &gt; containment[3]) {\r\n                        pageY = containment[3] + this.offset.click.top;\r\n                    }\r\n                }\r\n\r\n                if (o.grid) {\r\n\r\n                    \/\/Check for grid elements set to 0 to prevent divide by 0 error causing invalid\r\n                    \/\/ argument errors in IE (see ticket #6950)\r\n                    top = o.grid[1] ? this.originalPageY + Math.round((pageY -\r\n                        this.originalPageY) \/ o.grid[1]) * o.grid[1] : this.originalPageY;\r\n                    pageY = containment ? ((top - this.offset.click.top &gt;= containment[1] ||\r\n                            top - this.offset.click.top &gt; containment[3]) ?\r\n                        top :\r\n                        ((top - this.offset.click.top &gt;= containment[1]) ?\r\n                            top - o.grid[1] : top + o.grid[1])) : top;\r\n\r\n                    left = o.grid[0] ? this.originalPageX +\r\n                        Math.round((pageX - this.originalPageX) \/ o.grid[0]) * o.grid[0] :\r\n                        this.originalPageX;\r\n                    pageX = containment ? ((left - this.offset.click.left &gt;= containment[0] ||\r\n                            left - this.offset.click.left &gt; containment[2]) ?\r\n                        left :\r\n                        ((left - this.offset.click.left &gt;= containment[0]) ?\r\n                            left - o.grid[0] : left + o.grid[0])) : left;\r\n                }\r\n\r\n                if (o.axis === &quot;y&quot;) {\r\n                    pageX = this.originalPageX;\r\n                }\r\n\r\n                if (o.axis === &quot;x&quot;) {\r\n                    pageY = this.originalPageY;\r\n                }\r\n            }\r\n\r\n            return {\r\n                top: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pageY -\r\n\r\n                    \/\/ Click offset (relative to the element)\r\n                    this.offset.click.top -\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.top -\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.top +\r\n                    (this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.offset.scroll.top :\r\n                        (scrollIsRootNode ? 0 : this.offset.scroll.top))\r\n                ),\r\n                left: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pageX -\r\n\r\n                    \/\/ Click offset (relative to the element)\r\n                    this.offset.click.left -\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.left -\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.left +\r\n                    (this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.offset.scroll.left :\r\n                        (scrollIsRootNode ? 0 : this.offset.scroll.left))\r\n                )\r\n            };\r\n\r\n        },\r\n\r\n        _clear: function() {\r\n            this._removeClass(this.helper, &quot;ui-draggable-dragging&quot;);\r\n            if (this.helper[0] !== this.element[0] &amp;&amp; !this.cancelHelperRemoval) {\r\n                this.helper.remove();\r\n            }\r\n            this.helper = null;\r\n            this.cancelHelperRemoval = false;\r\n            if (this.destroyOnClear) {\r\n                this.destroy();\r\n            }\r\n        },\r\n\r\n        \/\/ From now on bulk stuff - mainly helpers\r\n\r\n        _trigger: function(type, event, ui) {\r\n            ui = ui || this._uiHash();\r\n            $.ui.plugin.call(this, type, [event, ui, this], true);\r\n\r\n            \/\/ Absolute position and offset (see #6884 ) have to be recalculated after plugins\r\n            if (\/^(drag|start|stop)\/.test(type)) {\r\n                this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);\r\n                ui.offset = this.positionAbs;\r\n            }\r\n            return $.Widget.prototype._trigger.call(this, type, event, ui);\r\n        },\r\n\r\n        plugins: {},\r\n\r\n        _uiHash: function() {\r\n            return {\r\n                helper: this.helper,\r\n                position: this.position,\r\n                originalPosition: this.originalPosition,\r\n                offset: this.positionAbs\r\n            };\r\n        }\r\n\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {\r\n        start: function(event, ui, draggable) {\r\n            var uiSortable = $.extend({}, ui, {\r\n                item: draggable.element\r\n            });\r\n\r\n            draggable.sortables = [];\r\n            $(draggable.options.connectToSortable).each(function() {\r\n                var sortable = $(this).sortable(&quot;instance&quot;);\r\n\r\n                if (sortable &amp;&amp; !sortable.options.disabled) {\r\n                    draggable.sortables.push(sortable);\r\n\r\n                    \/\/ RefreshPositions is called at drag start to refresh the containerCache\r\n                    \/\/ which is used in drag. This ensures it&#039;s initialized and synchronized\r\n                    \/\/ with any changes that might have happened on the page since initialization.\r\n                    sortable.refreshPositions();\r\n                    sortable._trigger(&quot;activate&quot;, event, uiSortable);\r\n                }\r\n            });\r\n        },\r\n        stop: function(event, ui, draggable) {\r\n            var uiSortable = $.extend({}, ui, {\r\n                item: draggable.element\r\n            });\r\n\r\n            draggable.cancelHelperRemoval = false;\r\n\r\n            $.each(draggable.sortables, function() {\r\n                var sortable = this;\r\n\r\n                if (sortable.isOver) {\r\n                    sortable.isOver = 0;\r\n\r\n                    \/\/ Allow this sortable to handle removing the helper\r\n                    draggable.cancelHelperRemoval = true;\r\n                    sortable.cancelHelperRemoval = false;\r\n\r\n                    \/\/ Use _storedCSS To restore properties in the sortable,\r\n                    \/\/ as this also handles revert (#9675) since the draggable\r\n                    \/\/ may have modified them in unexpected ways (#8809)\r\n                    sortable._storedCSS = {\r\n                        position: sortable.placeholder.css(&quot;position&quot;),\r\n                        top: sortable.placeholder.css(&quot;top&quot;),\r\n                        left: sortable.placeholder.css(&quot;left&quot;)\r\n                    };\r\n\r\n                    sortable._mouseStop(event);\r\n\r\n                    \/\/ Once drag has ended, the sortable should return to using\r\n                    \/\/ its original helper, not the shared helper from draggable\r\n                    sortable.options.helper = sortable.options._helper;\r\n                } else {\r\n\r\n                    \/\/ Prevent this Sortable from removing the helper.\r\n                    \/\/ However, don&#039;t set the draggable to remove the helper\r\n                    \/\/ either as another connected Sortable may yet handle the removal.\r\n                    sortable.cancelHelperRemoval = true;\r\n\r\n                    sortable._trigger(&quot;deactivate&quot;, event, uiSortable);\r\n                }\r\n            });\r\n        },\r\n        drag: function(event, ui, draggable) {\r\n            $.each(draggable.sortables, function() {\r\n                var innermostIntersecting = false,\r\n                    sortable = this;\r\n\r\n                \/\/ Copy over variables that sortable&#039;s _intersectsWith uses\r\n                sortable.positionAbs = draggable.positionAbs;\r\n                sortable.helperProportions = draggable.helperProportions;\r\n                sortable.offset.click = draggable.offset.click;\r\n\r\n                if (sortable._intersectsWith(sortable.containerCache)) {\r\n                    innermostIntersecting = true;\r\n\r\n                    $.each(draggable.sortables, function() {\r\n\r\n                        \/\/ Copy over variables that sortable&#039;s _intersectsWith uses\r\n                        this.positionAbs = draggable.positionAbs;\r\n                        this.helperProportions = draggable.helperProportions;\r\n                        this.offset.click = draggable.offset.click;\r\n\r\n                        if (this !== sortable &amp;&amp;\r\n                            this._intersectsWith(this.containerCache) &amp;&amp;\r\n                            $.contains(sortable.element[0], this.element[0])) {\r\n                            innermostIntersecting = false;\r\n                        }\r\n\r\n                        return innermostIntersecting;\r\n                    });\r\n                }\r\n\r\n                if (innermostIntersecting) {\r\n\r\n                    \/\/ If it intersects, we use a little isOver variable and set it once,\r\n                    \/\/ so that the move-in stuff gets fired only once.\r\n                    if (!sortable.isOver) {\r\n                        sortable.isOver = 1;\r\n\r\n                        \/\/ Store draggable&#039;s parent in case we need to reappend to it later.\r\n                        draggable._parent = ui.helper.parent();\r\n\r\n                        sortable.currentItem = ui.helper\r\n                            .appendTo(sortable.element)\r\n                            .data(&quot;ui-sortable-item&quot;, true);\r\n\r\n                        \/\/ Store helper option to later restore it\r\n                        sortable.options._helper = sortable.options.helper;\r\n\r\n                        sortable.options.helper = function() {\r\n                            return ui.helper[0];\r\n                        };\r\n\r\n                        \/\/ Fire the start events of the sortable with our passed browser event,\r\n                        \/\/ and our own helper (so it doesn&#039;t create a new one)\r\n                        event.target = sortable.currentItem[0];\r\n                        sortable._mouseCapture(event, true);\r\n                        sortable._mouseStart(event, true, true);\r\n\r\n                        \/\/ Because the browser event is way off the new appended portlet,\r\n                        \/\/ modify necessary variables to reflect the changes\r\n                        sortable.offset.click.top = draggable.offset.click.top;\r\n                        sortable.offset.click.left = draggable.offset.click.left;\r\n                        sortable.offset.parent.left -= draggable.offset.parent.left -\r\n                            sortable.offset.parent.left;\r\n                        sortable.offset.parent.top -= draggable.offset.parent.top -\r\n                            sortable.offset.parent.top;\r\n\r\n                        draggable._trigger(&quot;toSortable&quot;, event);\r\n\r\n                        \/\/ Inform draggable that the helper is in a valid drop zone,\r\n                        \/\/ used solely in the revert option to handle &quot;valid\/invalid&quot;.\r\n                        draggable.dropped = sortable.element;\r\n\r\n                        \/\/ Need to refreshPositions of all sortables in the case that\r\n                        \/\/ adding to one sortable changes the location of the other sortables (#9675)\r\n                        $.each(draggable.sortables, function() {\r\n                            this.refreshPositions();\r\n                        });\r\n\r\n                        \/\/ Hack so receive\/update callbacks work (mostly)\r\n                        draggable.currentItem = draggable.element;\r\n                        sortable.fromOutside = draggable;\r\n                    }\r\n\r\n                    if (sortable.currentItem) {\r\n                        sortable._mouseDrag(event);\r\n\r\n                        \/\/ Copy the sortable&#039;s position because the draggable&#039;s can potentially reflect\r\n                        \/\/ a relative position, while sortable is always absolute, which the dragged\r\n                        \/\/ element has now become. (#8809)\r\n                        ui.position = sortable.position;\r\n                    }\r\n                } else {\r\n\r\n                    \/\/ If it doesn&#039;t intersect with the sortable, and it intersected before,\r\n                    \/\/ we fake the drag stop of the sortable, but make sure it doesn&#039;t remove\r\n                    \/\/ the helper by using cancelHelperRemoval.\r\n                    if (sortable.isOver) {\r\n\r\n                        sortable.isOver = 0;\r\n                        sortable.cancelHelperRemoval = true;\r\n\r\n                        \/\/ Calling sortable&#039;s mouseStop would trigger a revert,\r\n                        \/\/ so revert must be temporarily false until after mouseStop is called.\r\n                        sortable.options._revert = sortable.options.revert;\r\n                        sortable.options.revert = false;\r\n\r\n                        sortable._trigger(&quot;out&quot;, event, sortable._uiHash(sortable));\r\n                        sortable._mouseStop(event, true);\r\n\r\n                        \/\/ Restore sortable behaviors that were modfied\r\n                        \/\/ when the draggable entered the sortable area (#9481)\r\n                        sortable.options.revert = sortable.options._revert;\r\n                        sortable.options.helper = sortable.options._helper;\r\n\r\n                        if (sortable.placeholder) {\r\n                            sortable.placeholder.remove();\r\n                        }\r\n\r\n                        \/\/ Restore and recalculate the draggable&#039;s offset considering the sortable\r\n                        \/\/ may have modified them in unexpected ways. (#8809, #10669)\r\n                        ui.helper.appendTo(draggable._parent);\r\n                        draggable._refreshOffsets(event);\r\n                        ui.position = draggable._generatePosition(event, true);\r\n\r\n                        draggable._trigger(&quot;fromSortable&quot;, event);\r\n\r\n                        \/\/ Inform draggable that the helper is no longer in a valid drop zone\r\n                        draggable.dropped = false;\r\n\r\n                        \/\/ Need to refreshPositions of all sortables just in case removing\r\n                        \/\/ from one sortable changes the location of other sortables (#9675)\r\n                        $.each(draggable.sortables, function() {\r\n                            this.refreshPositions();\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {\r\n        start: function(event, ui, instance) {\r\n            var t = $(&quot;body&quot;),\r\n                o = instance.options;\r\n\r\n            if (t.css(&quot;cursor&quot;)) {\r\n                o._cursor = t.css(&quot;cursor&quot;);\r\n            }\r\n            t.css(&quot;cursor&quot;, o.cursor);\r\n        },\r\n        stop: function(event, ui, instance) {\r\n            var o = instance.options;\r\n            if (o._cursor) {\r\n                $(&quot;body&quot;).css(&quot;cursor&quot;, o._cursor);\r\n            }\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {\r\n        start: function(event, ui, instance) {\r\n            var t = $(ui.helper),\r\n                o = instance.options;\r\n            if (t.css(&quot;opacity&quot;)) {\r\n                o._opacity = t.css(&quot;opacity&quot;);\r\n            }\r\n            t.css(&quot;opacity&quot;, o.opacity);\r\n        },\r\n        stop: function(event, ui, instance) {\r\n            var o = instance.options;\r\n            if (o._opacity) {\r\n                $(ui.helper).css(&quot;opacity&quot;, o._opacity);\r\n            }\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {\r\n        start: function(event, ui, i) {\r\n            if (!i.scrollParentNotHidden) {\r\n                i.scrollParentNotHidden = i.helper.scrollParent(false);\r\n            }\r\n\r\n            if (i.scrollParentNotHidden[0] !== i.document[0] &amp;&amp;\r\n                i.scrollParentNotHidden[0].tagName !== &quot;HTML&quot;) {\r\n                i.overflowOffset = i.scrollParentNotHidden.offset();\r\n            }\r\n        },\r\n        drag: function(event, ui, i) {\r\n\r\n            var o = i.options,\r\n                scrolled = false,\r\n                scrollParent = i.scrollParentNotHidden[0],\r\n                document = i.document[0];\r\n\r\n            if (scrollParent !== document &amp;&amp; scrollParent.tagName !== &quot;HTML&quot;) {\r\n                if (!o.axis || o.axis !== &quot;x&quot;) {\r\n                    if ((i.overflowOffset.top + scrollParent.offsetHeight) - event.pageY &lt;\r\n                        o.scrollSensitivity) {\r\n                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\r\n                    } else if (event.pageY - i.overflowOffset.top &lt; o.scrollSensitivity) {\r\n                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\r\n                    }\r\n                }\r\n\r\n                if (!o.axis || o.axis !== &quot;y&quot;) {\r\n                    if ((i.overflowOffset.left + scrollParent.offsetWidth) - event.pageX &lt;\r\n                        o.scrollSensitivity) {\r\n                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\r\n                    } else if (event.pageX - i.overflowOffset.left &lt; o.scrollSensitivity) {\r\n                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\r\n                    }\r\n                }\r\n\r\n            } else {\r\n\r\n                if (!o.axis || o.axis !== &quot;x&quot;) {\r\n                    if (event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity) {\r\n                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\r\n                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) &lt;\r\n                        o.scrollSensitivity) {\r\n                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\r\n                    }\r\n                }\r\n\r\n                if (!o.axis || o.axis !== &quot;y&quot;) {\r\n                    if (event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity) {\r\n                        scrolled = $(document).scrollLeft(\r\n                            $(document).scrollLeft() - o.scrollSpeed\r\n                        );\r\n                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) &lt;\r\n                        o.scrollSensitivity) {\r\n                        scrolled = $(document).scrollLeft(\r\n                            $(document).scrollLeft() + o.scrollSpeed\r\n                        );\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            if (scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour) {\r\n                $.ui.ddmanager.prepareOffsets(i, event);\r\n            }\r\n\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {\r\n        start: function(event, ui, i) {\r\n\r\n            var o = i.options;\r\n\r\n            i.snapElements = [];\r\n\r\n            $(o.snap.constructor !== String ? (o.snap.items || &quot;:data(ui-draggable)&quot;) : o.snap)\r\n                .each(function() {\r\n                    var $t = $(this),\r\n                        $o = $t.offset();\r\n                    if (this !== i.element[0]) {\r\n                        i.snapElements.push({\r\n                            item: this,\r\n                            width: $t.outerWidth(),\r\n                            height: $t.outerHeight(),\r\n                            top: $o.top,\r\n                            left: $o.left\r\n                        });\r\n                    }\r\n                });\r\n\r\n        },\r\n        drag: function(event, ui, inst) {\r\n\r\n            var ts, bs, ls, rs, l, r, t, b, i, first,\r\n                o = inst.options,\r\n                d = o.snapTolerance,\r\n                x1 = ui.offset.left,\r\n                x2 = x1 + inst.helperProportions.width,\r\n                y1 = ui.offset.top,\r\n                y2 = y1 + inst.helperProportions.height;\r\n\r\n            for (i = inst.snapElements.length - 1; i &gt;= 0; i--) {\r\n\r\n                l = inst.snapElements[i].left - inst.margins.left;\r\n                r = l + inst.snapElements[i].width;\r\n                t = inst.snapElements[i].top - inst.margins.top;\r\n                b = t + inst.snapElements[i].height;\r\n\r\n                if (x2 &lt; l - d || x1 &gt; r + d || y2 &lt; t - d || y1 &gt; b + d ||\r\n                    !$.contains(inst.snapElements[i].item.ownerDocument,\r\n                        inst.snapElements[i].item)) {\r\n                    if (inst.snapElements[i].snapping) {\r\n                        if (inst.options.snap.release) {\r\n                            inst.options.snap.release.call(\r\n                                inst.element,\r\n                                event,\r\n                                $.extend(inst._uiHash(), {\r\n                                    snapItem: inst.snapElements[i].item\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                    inst.snapElements[i].snapping = false;\r\n                    continue;\r\n                }\r\n\r\n                if (o.snapMode !== &quot;inner&quot;) {\r\n                    ts = Math.abs(t - y2) &lt;= d;\r\n                    bs = Math.abs(b - y1) &lt;= d;\r\n                    ls = Math.abs(l - x2) &lt;= d;\r\n                    rs = Math.abs(r - x1) &lt;= d;\r\n                    if (ts) {\r\n                        ui.position.top = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: t - inst.helperProportions.height,\r\n                            left: 0\r\n                        }).top;\r\n                    }\r\n                    if (bs) {\r\n                        ui.position.top = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: b,\r\n                            left: 0\r\n                        }).top;\r\n                    }\r\n                    if (ls) {\r\n                        ui.position.left = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: 0,\r\n                            left: l - inst.helperProportions.width\r\n                        }).left;\r\n                    }\r\n                    if (rs) {\r\n                        ui.position.left = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: 0,\r\n                            left: r\r\n                        }).left;\r\n                    }\r\n                }\r\n\r\n                first = (ts || bs || ls || rs);\r\n\r\n                if (o.snapMode !== &quot;outer&quot;) {\r\n                    ts = Math.abs(t - y1) &lt;= d;\r\n                    bs = Math.abs(b - y2) &lt;= d;\r\n                    ls = Math.abs(l - x1) &lt;= d;\r\n                    rs = Math.abs(r - x2) &lt;= d;\r\n                    if (ts) {\r\n                        ui.position.top = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: t,\r\n                            left: 0\r\n                        }).top;\r\n                    }\r\n                    if (bs) {\r\n                        ui.position.top = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: b - inst.helperProportions.height,\r\n                            left: 0\r\n                        }).top;\r\n                    }\r\n                    if (ls) {\r\n                        ui.position.left = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: 0,\r\n                            left: l\r\n                        }).left;\r\n                    }\r\n                    if (rs) {\r\n                        ui.position.left = inst._convertPositionTo(&quot;relative&quot;, {\r\n                            top: 0,\r\n                            left: r - inst.helperProportions.width\r\n                        }).left;\r\n                    }\r\n                }\r\n\r\n                if (!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first)) {\r\n                    if (inst.options.snap.snap) {\r\n                        inst.options.snap.snap.call(\r\n                            inst.element,\r\n                            event,\r\n                            $.extend(inst._uiHash(), {\r\n                                snapItem: inst.snapElements[i].item\r\n                            }));\r\n                    }\r\n                }\r\n                inst.snapElements[i].snapping = (ts || bs || ls || rs || first);\r\n\r\n            }\r\n\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {\r\n        start: function(event, ui, instance) {\r\n            var min,\r\n                o = instance.options,\r\n                group = $.makeArray($(o.stack)).sort(function(a, b) {\r\n                    return (parseInt($(a).css(&quot;zIndex&quot;), 10) || 0) -\r\n                        (parseInt($(b).css(&quot;zIndex&quot;), 10) || 0);\r\n                });\r\n\r\n            if (!group.length) {\r\n                return;\r\n            }\r\n\r\n            min = parseInt($(group[0]).css(&quot;zIndex&quot;), 10) || 0;\r\n            $(group).each(function(i) {\r\n                $(this).css(&quot;zIndex&quot;, min + i);\r\n            });\r\n            this.css(&quot;zIndex&quot;, (min + group.length));\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {\r\n        start: function(event, ui, instance) {\r\n            var t = $(ui.helper),\r\n                o = instance.options;\r\n\r\n            if (t.css(&quot;zIndex&quot;)) {\r\n                o._zIndex = t.css(&quot;zIndex&quot;);\r\n            }\r\n            t.css(&quot;zIndex&quot;, o.zIndex);\r\n        },\r\n        stop: function(event, ui, instance) {\r\n            var o = instance.options;\r\n\r\n            if (o._zIndex) {\r\n                $(ui.helper).css(&quot;zIndex&quot;, o._zIndex);\r\n            }\r\n        }\r\n    });\r\n\r\n    var widgetsDraggable = $.ui.draggable;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Droppable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Droppable\r\n    \/\/&gt;&gt;group: Interactions\r\n    \/\/&gt;&gt;description: Enables drop targets for draggable elements.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/droppable\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/droppable\/\r\n\r\n\r\n    $.widget(&quot;ui.droppable&quot;, {\r\n        version: &quot;1.14.1&quot;,\r\n        widgetEventPrefix: &quot;drop&quot;,\r\n        options: {\r\n            accept: &quot;*&quot;,\r\n            addClasses: true,\r\n            greedy: false,\r\n            scope: &quot;default&quot;,\r\n            tolerance: &quot;intersect&quot;,\r\n\r\n            \/\/ Callbacks\r\n            activate: null,\r\n            deactivate: null,\r\n            drop: null,\r\n            out: null,\r\n            over: null\r\n        },\r\n        _create: function() {\r\n\r\n            var proportions,\r\n                o = this.options,\r\n                accept = o.accept;\r\n\r\n            this.isover = false;\r\n            this.isout = true;\r\n\r\n            this.accept = typeof accept === &quot;function&quot; ? accept : function(d) {\r\n                return d.is(accept);\r\n            };\r\n\r\n            this.proportions = function( \/* valueToWrite *\/ ) {\r\n                if (arguments.length) {\r\n\r\n                    \/\/ Store the droppable&#039;s proportions\r\n                    proportions = arguments[0];\r\n                } else {\r\n\r\n                    \/\/ Retrieve or derive the droppable&#039;s proportions\r\n                    return proportions ?\r\n                        proportions :\r\n                        proportions = {\r\n                            width: this.element[0].offsetWidth,\r\n                            height: this.element[0].offsetHeight\r\n                        };\r\n                }\r\n            };\r\n\r\n            this._addToManager(o.scope);\r\n\r\n            if (o.addClasses) {\r\n                this._addClass(&quot;ui-droppable&quot;);\r\n            }\r\n\r\n        },\r\n\r\n        _addToManager: function(scope) {\r\n\r\n            \/\/ Add the reference and positions to the manager\r\n            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];\r\n            $.ui.ddmanager.droppables[scope].push(this);\r\n        },\r\n\r\n        _splice: function(drop) {\r\n            var i = 0;\r\n            for (; i &lt; drop.length; i++) {\r\n                if (drop[i] === this) {\r\n                    drop.splice(i, 1);\r\n                }\r\n            }\r\n        },\r\n\r\n        _destroy: function() {\r\n            var drop = $.ui.ddmanager.droppables[this.options.scope];\r\n\r\n            this._splice(drop);\r\n        },\r\n\r\n        _setOption: function(key, value) {\r\n\r\n            if (key === &quot;accept&quot;) {\r\n                this.accept = typeof value === &quot;function&quot; ? value : function(d) {\r\n                    return d.is(value);\r\n                };\r\n            } else if (key === &quot;scope&quot;) {\r\n                var drop = $.ui.ddmanager.droppables[this.options.scope];\r\n\r\n                this._splice(drop);\r\n                this._addToManager(value);\r\n            }\r\n\r\n            this._super(key, value);\r\n        },\r\n\r\n        _activate: function(event) {\r\n            var draggable = $.ui.ddmanager.current;\r\n\r\n            this._addActiveClass();\r\n            if (draggable) {\r\n                this._trigger(&quot;activate&quot;, event, this.ui(draggable));\r\n            }\r\n        },\r\n\r\n        _deactivate: function(event) {\r\n            var draggable = $.ui.ddmanager.current;\r\n\r\n            this._removeActiveClass();\r\n            if (draggable) {\r\n                this._trigger(&quot;deactivate&quot;, event, this.ui(draggable));\r\n            }\r\n        },\r\n\r\n        _over: function(event) {\r\n\r\n            var draggable = $.ui.ddmanager.current;\r\n\r\n            \/\/ Bail if draggable and droppable are same element\r\n            if (!draggable || (draggable.currentItem ||\r\n                    draggable.element)[0] === this.element[0]) {\r\n                return;\r\n            }\r\n\r\n            if (this.accept.call(this.element[0], (draggable.currentItem ||\r\n                    draggable.element))) {\r\n                this._addHoverClass();\r\n                this._trigger(&quot;over&quot;, event, this.ui(draggable));\r\n            }\r\n\r\n        },\r\n\r\n        _out: function(event) {\r\n\r\n            var draggable = $.ui.ddmanager.current;\r\n\r\n            \/\/ Bail if draggable and droppable are same element\r\n            if (!draggable || (draggable.currentItem ||\r\n                    draggable.element)[0] === this.element[0]) {\r\n                return;\r\n            }\r\n\r\n            if (this.accept.call(this.element[0], (draggable.currentItem ||\r\n                    draggable.element))) {\r\n                this._removeHoverClass();\r\n                this._trigger(&quot;out&quot;, event, this.ui(draggable));\r\n            }\r\n\r\n        },\r\n\r\n        _drop: function(event, custom) {\r\n\r\n            var draggable = custom || $.ui.ddmanager.current,\r\n                childrenIntersection = false;\r\n\r\n            \/\/ Bail if draggable and droppable are same element\r\n            if (!draggable || (draggable.currentItem ||\r\n                    draggable.element)[0] === this.element[0]) {\r\n                return false;\r\n            }\r\n\r\n            this.element\r\n                .find(&quot;:data(ui-droppable)&quot;)\r\n                .not(&quot;.ui-draggable-dragging&quot;)\r\n                .each(function() {\r\n                    var inst = $(this).droppable(&quot;instance&quot;);\r\n                    if (\r\n                        inst.options.greedy &amp;&amp;\r\n                        !inst.options.disabled &amp;&amp;\r\n                        inst.options.scope === draggable.options.scope &amp;&amp;\r\n                        inst.accept.call(\r\n                            inst.element[0], (draggable.currentItem || draggable.element)\r\n                        ) &amp;&amp;\r\n                        $.ui.intersect(\r\n                            draggable,\r\n                            $.extend(inst, {\r\n                                offset: inst.element.offset()\r\n                            }),\r\n                            inst.options.tolerance, event\r\n                        )\r\n                    ) {\r\n                        childrenIntersection = true;\r\n                        return false;\r\n                    }\r\n                });\r\n            if (childrenIntersection) {\r\n                return false;\r\n            }\r\n\r\n            if (this.accept.call(this.element[0],\r\n                    (draggable.currentItem || draggable.element))) {\r\n                this._removeActiveClass();\r\n                this._removeHoverClass();\r\n\r\n                this._trigger(&quot;drop&quot;, event, this.ui(draggable));\r\n                return this.element;\r\n            }\r\n\r\n            return false;\r\n\r\n        },\r\n\r\n        ui: function(c) {\r\n            return {\r\n                draggable: (c.currentItem || c.element),\r\n                helper: c.helper,\r\n                position: c.position,\r\n                offset: c.positionAbs\r\n            };\r\n        },\r\n\r\n        \/\/ Extension points just to make backcompat sane and avoid duplicating logic\r\n        \/\/ TODO: Remove in 1.14 along with call to it below\r\n        _addHoverClass: function() {\r\n            this._addClass(&quot;ui-droppable-hover&quot;);\r\n        },\r\n\r\n        _removeHoverClass: function() {\r\n            this._removeClass(&quot;ui-droppable-hover&quot;);\r\n        },\r\n\r\n        _addActiveClass: function() {\r\n            this._addClass(&quot;ui-droppable-active&quot;);\r\n        },\r\n\r\n        _removeActiveClass: function() {\r\n            this._removeClass(&quot;ui-droppable-active&quot;);\r\n        }\r\n    });\r\n\r\n    $.ui.intersect = (function() {\r\n        function isOverAxis(x, reference, size) {\r\n            return (x &gt;= reference) &amp;&amp; (x &lt; (reference + size));\r\n        }\r\n\r\n        return function(draggable, droppable, toleranceMode, event) {\r\n\r\n            if (!droppable.offset) {\r\n                return false;\r\n            }\r\n\r\n            var x1 = (draggable.positionAbs ||\r\n                    draggable.position.absolute).left + draggable.margins.left,\r\n                y1 = (draggable.positionAbs ||\r\n                    draggable.position.absolute).top + draggable.margins.top,\r\n                x2 = x1 + draggable.helperProportions.width,\r\n                y2 = y1 + draggable.helperProportions.height,\r\n                l = droppable.offset.left,\r\n                t = droppable.offset.top,\r\n                r = l + droppable.proportions().width,\r\n                b = t + droppable.proportions().height;\r\n\r\n            switch (toleranceMode) {\r\n                case &quot;fit&quot;:\r\n                    return (l &lt;= x1 &amp;&amp; x2 &lt;= r &amp;&amp; t &lt;= y1 &amp;&amp; y2 &lt;= b);\r\n                case &quot;intersect&quot;:\r\n                    return (l &lt; x1 + (draggable.helperProportions.width \/ 2) &amp;&amp; \/\/ Right Half\r\n                        x2 - (draggable.helperProportions.width \/ 2) &lt; r &amp;&amp; \/\/ Left Half\r\n                        t &lt; y1 + (draggable.helperProportions.height \/ 2) &amp;&amp; \/\/ Bottom Half\r\n                        y2 - (draggable.helperProportions.height \/ 2) &lt; b); \/\/ Top Half\r\n                case &quot;pointer&quot;:\r\n                    return isOverAxis(event.pageY, t, droppable.proportions().height) &amp;&amp;\r\n                        isOverAxis(event.pageX, l, droppable.proportions().width);\r\n                case &quot;touch&quot;:\r\n                    return (\r\n                        (y1 &gt;= t &amp;&amp; y1 &lt;= b) || \/\/ Top edge touching\r\n                        (y2 &gt;= t &amp;&amp; y2 &lt;= b) || \/\/ Bottom edge touching\r\n                        (y1 &lt; t &amp;&amp; y2 &gt; b) \/\/ Surrounded vertically\r\n                    ) &amp;&amp; (\r\n                        (x1 &gt;= l &amp;&amp; x1 &lt;= r) || \/\/ Left edge touching\r\n                        (x2 &gt;= l &amp;&amp; x2 &lt;= r) || \/\/ Right edge touching\r\n                        (x1 &lt; l &amp;&amp; x2 &gt; r) \/\/ Surrounded horizontally\r\n                    );\r\n                default:\r\n                    return false;\r\n            }\r\n        };\r\n    })();\r\n\r\n    \/*\r\n      This manager tracks offsets of draggables and droppables\r\n    *\/\r\n    $.ui.ddmanager = {\r\n        current: null,\r\n        droppables: {\r\n            &quot;default&quot;: []\r\n        },\r\n        prepareOffsets: function(t, event) {\r\n\r\n            var i, j,\r\n                m = $.ui.ddmanager.droppables[t.options.scope] || [],\r\n                type = event ? event.type : null, \/\/ workaround for #2317\r\n                list = (t.currentItem || t.element).find(&quot;:data(ui-droppable)&quot;).addBack();\r\n\r\n            droppablesLoop: for (i = 0; i &lt; m.length; i++) {\r\n\r\n                \/\/ No disabled and non-accepted\r\n                if (m[i].options.disabled || (t &amp;&amp; !m[i].accept.call(m[i].element[0],\r\n                        (t.currentItem || t.element)))) {\r\n                    continue;\r\n                }\r\n\r\n                \/\/ Filter out elements in the current dragged item\r\n                for (j = 0; j &lt; list.length; j++) {\r\n                    if (list[j] === m[i].element[0]) {\r\n                        m[i].proportions().height = 0;\r\n                        continue droppablesLoop;\r\n                    }\r\n                }\r\n\r\n                m[i].visible = m[i].element.css(&quot;display&quot;) !== &quot;none&quot;;\r\n                if (!m[i].visible) {\r\n                    continue;\r\n                }\r\n\r\n                \/\/ Activate the droppable if used directly from draggables\r\n                if (type === &quot;mousedown&quot;) {\r\n                    m[i]._activate.call(m[i], event);\r\n                }\r\n\r\n                m[i].offset = m[i].element.offset();\r\n                m[i].proportions({\r\n                    width: m[i].element[0].offsetWidth,\r\n                    height: m[i].element[0].offsetHeight\r\n                });\r\n\r\n            }\r\n\r\n        },\r\n        drop: function(draggable, event) {\r\n\r\n            var dropped = false;\r\n\r\n            \/\/ Create a copy of the droppables in case the list changes during the drop (#9116)\r\n            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {\r\n\r\n                if (!this.options) {\r\n                    return;\r\n                }\r\n                if (!this.options.disabled &amp;&amp; this.visible &amp;&amp;\r\n                    $.ui.intersect(draggable, this, this.options.tolerance, event)) {\r\n                    dropped = this._drop.call(this, event) || dropped;\r\n                }\r\n\r\n                if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; this.accept.call(this.element[0],\r\n                        (draggable.currentItem || draggable.element))) {\r\n                    this.isout = true;\r\n                    this.isover = false;\r\n                    this._deactivate.call(this, event);\r\n                }\r\n\r\n            });\r\n            return dropped;\r\n\r\n        },\r\n        dragStart: function(draggable, event) {\r\n\r\n            \/\/ Listen for scrolling so that if the dragging causes scrolling the position of the\r\n            \/\/ droppables can be recalculated (see #5003)\r\n            draggable.element.parentsUntil(&quot;body&quot;).on(&quot;scroll.droppable&quot;, function() {\r\n                if (!draggable.options.refreshPositions) {\r\n                    $.ui.ddmanager.prepareOffsets(draggable, event);\r\n                }\r\n            });\r\n        },\r\n        drag: function(draggable, event) {\r\n\r\n            \/\/ If you have a highly dynamic page, you might try this option. It renders positions\r\n            \/\/ every time you move the mouse.\r\n            if (draggable.options.refreshPositions) {\r\n                $.ui.ddmanager.prepareOffsets(draggable, event);\r\n            }\r\n\r\n            \/\/ Run through all droppables and check their positions based on specific tolerance options\r\n            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {\r\n\r\n                if (this.options.disabled || this.greedyChild || !this.visible) {\r\n                    return;\r\n                }\r\n\r\n                var parentInstance, scope, parent,\r\n                    intersects = $.ui.intersect(draggable, this, this.options.tolerance, event),\r\n                    c = !intersects &amp;&amp; this.isover ?\r\n                    &quot;isout&quot; :\r\n                    (intersects &amp;&amp; !this.isover ? &quot;isover&quot; : null);\r\n                if (!c) {\r\n                    return;\r\n                }\r\n\r\n                if (this.options.greedy) {\r\n\r\n                    \/\/ find droppable parents with same scope\r\n                    scope = this.options.scope;\r\n                    parent = this.element.parents(&quot;:data(ui-droppable)&quot;).filter(function() {\r\n                        return $(this).droppable(&quot;instance&quot;).options.scope === scope;\r\n                    });\r\n\r\n                    if (parent.length) {\r\n                        parentInstance = $(parent[0]).droppable(&quot;instance&quot;);\r\n                        parentInstance.greedyChild = (c === &quot;isover&quot;);\r\n                    }\r\n                }\r\n\r\n                \/\/ We just moved into a greedy child\r\n                if (parentInstance &amp;&amp; c === &quot;isover&quot;) {\r\n                    parentInstance.isover = false;\r\n                    parentInstance.isout = true;\r\n                    parentInstance._out.call(parentInstance, event);\r\n                }\r\n\r\n                this[c] = true;\r\n                this[c === &quot;isout&quot; ? &quot;isover&quot; : &quot;isout&quot;] = false;\r\n                this[c === &quot;isover&quot; ? &quot;_over&quot; : &quot;_out&quot;].call(this, event);\r\n\r\n                \/\/ We just moved out of a greedy child\r\n                if (parentInstance &amp;&amp; c === &quot;isout&quot;) {\r\n                    parentInstance.isout = false;\r\n                    parentInstance.isover = true;\r\n                    parentInstance._over.call(parentInstance, event);\r\n                }\r\n            });\r\n\r\n        },\r\n        dragStop: function(draggable, event) {\r\n            draggable.element.parentsUntil(&quot;body&quot;).off(&quot;scroll.droppable&quot;);\r\n\r\n            \/\/ Call prepareOffsets one final time since IE does not fire return scroll events when\r\n            \/\/ overflow was caused by drag (see #5003)\r\n            if (!draggable.options.refreshPositions) {\r\n                $.ui.ddmanager.prepareOffsets(draggable, event);\r\n            }\r\n        }\r\n    };\r\n\r\n    \/\/ DEPRECATED\r\n    \/\/ TODO: switch return back to widget declaration at top of file when this is removed\r\n    if ($.uiBackCompat === true) {\r\n\r\n        \/\/ Backcompat for activeClass and hoverClass options\r\n        $.widget(&quot;ui.droppable&quot;, $.ui.droppable, {\r\n            options: {\r\n                hoverClass: false,\r\n                activeClass: false\r\n            },\r\n            _addActiveClass: function() {\r\n                this._super();\r\n                if (this.options.activeClass) {\r\n                    this.element.addClass(this.options.activeClass);\r\n                }\r\n            },\r\n            _removeActiveClass: function() {\r\n                this._super();\r\n                if (this.options.activeClass) {\r\n                    this.element.removeClass(this.options.activeClass);\r\n                }\r\n            },\r\n            _addHoverClass: function() {\r\n                this._super();\r\n                if (this.options.hoverClass) {\r\n                    this.element.addClass(this.options.hoverClass);\r\n                }\r\n            },\r\n            _removeHoverClass: function() {\r\n                this._super();\r\n                if (this.options.hoverClass) {\r\n                    this.element.removeClass(this.options.hoverClass);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    var widgetsDroppable = $.ui.droppable;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Resizable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Resizable\r\n    \/\/&gt;&gt;group: Interactions\r\n    \/\/&gt;&gt;description: Enables resize functionality for any element.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/resizable\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/resizable\/\r\n    \/\/&gt;&gt;css.structure: ..\/..\/themes\/base\/core.css\r\n    \/\/&gt;&gt;css.structure: ..\/..\/themes\/base\/resizable.css\r\n    \/\/&gt;&gt;css.theme: ..\/..\/themes\/base\/theme.css\r\n\r\n\r\n    $.widget(&quot;ui.resizable&quot;, $.ui.mouse, {\r\n        version: &quot;1.14.1&quot;,\r\n        widgetEventPrefix: &quot;resize&quot;,\r\n        options: {\r\n            alsoResize: false,\r\n            animate: false,\r\n            animateDuration: &quot;slow&quot;,\r\n            animateEasing: &quot;swing&quot;,\r\n            aspectRatio: false,\r\n            autoHide: false,\r\n            classes: {\r\n                &quot;ui-resizable-se&quot;: &quot;ui-icon ui-icon-gripsmall-diagonal-se&quot;\r\n            },\r\n            containment: false,\r\n            ghost: false,\r\n            grid: false,\r\n            handles: &quot;e,s,se&quot;,\r\n            helper: false,\r\n            maxHeight: null,\r\n            maxWidth: null,\r\n            minHeight: 10,\r\n            minWidth: 10,\r\n\r\n            \/\/ See #7960\r\n            zIndex: 90,\r\n\r\n            \/\/ Callbacks\r\n            resize: null,\r\n            start: null,\r\n            stop: null\r\n        },\r\n\r\n        _num: function(value) {\r\n            return parseFloat(value) || 0;\r\n        },\r\n\r\n        _isNumber: function(value) {\r\n            return !isNaN(parseFloat(value));\r\n        },\r\n\r\n        _hasScroll: function(el, a) {\r\n\r\n            var scroll,\r\n                has = false,\r\n                overflow = $(el).css(&quot;overflow&quot;);\r\n\r\n            if (overflow === &quot;hidden&quot;) {\r\n                return false;\r\n            }\r\n            if (overflow === &quot;scroll&quot;) {\r\n                return true;\r\n            }\r\n\r\n            scroll = (a &amp;&amp; a === &quot;left&quot;) ? &quot;scrollLeft&quot; : &quot;scrollTop&quot;;\r\n\r\n            if (el[scroll] &gt; 0) {\r\n                return true;\r\n            }\r\n\r\n            \/\/ TODO: determine which cases actually cause this to happen\r\n            \/\/ if the element doesn&#039;t have the scroll set, see if it&#039;s possible to\r\n            \/\/ set the scroll\r\n            try {\r\n                el[scroll] = 1;\r\n                has = (el[scroll] &gt; 0);\r\n                el[scroll] = 0;\r\n            } catch (e) {\r\n\r\n                \/\/ `el` might be a string, then setting `scroll` will throw\r\n                \/\/ an error in strict mode; ignore it.\r\n            }\r\n            return has;\r\n        },\r\n\r\n        _create: function() {\r\n\r\n            var margins,\r\n                o = this.options,\r\n                that = this;\r\n            this._addClass(&quot;ui-resizable&quot;);\r\n\r\n            $.extend(this, {\r\n                _aspectRatio: !!(o.aspectRatio),\r\n                aspectRatio: o.aspectRatio,\r\n                originalElement: this.element,\r\n                _proportionallyResizeElements: [],\r\n                _helper: o.helper || o.ghost || o.animate ? o.helper || &quot;ui-resizable-helper&quot; : null\r\n            });\r\n\r\n            \/\/ Wrap the element if it cannot hold child nodes\r\n            if (this.element[0].nodeName.match(\/^(canvas|textarea|input|select|button|img)$\/i)) {\r\n\r\n                this.element.wrap(\r\n                    $(&quot;&lt;div class=&#039;ui-wrapper&#039;&gt;&lt;\/div&gt;&quot;).css({\r\n                        overflow: &quot;hidden&quot;,\r\n                        position: this.element.css(&quot;position&quot;),\r\n                        width: this.element.outerWidth(),\r\n                        height: this.element.outerHeight(),\r\n                        top: this.element.css(&quot;top&quot;),\r\n                        left: this.element.css(&quot;left&quot;)\r\n                    })\r\n                );\r\n\r\n                this.element = this.element.parent().data(\r\n                    &quot;ui-resizable&quot;, this.element.resizable(&quot;instance&quot;)\r\n                );\r\n\r\n                this.elementIsWrapper = true;\r\n\r\n                margins = {\r\n                    marginTop: this.originalElement.css(&quot;marginTop&quot;),\r\n                    marginRight: this.originalElement.css(&quot;marginRight&quot;),\r\n                    marginBottom: this.originalElement.css(&quot;marginBottom&quot;),\r\n                    marginLeft: this.originalElement.css(&quot;marginLeft&quot;)\r\n                };\r\n\r\n                this.element.css(margins);\r\n\r\n                \/\/ Support: Safari\r\n                \/\/ Prevent Safari textarea resize\r\n                this.originalResizeStyle = this.originalElement.css(&quot;resize&quot;);\r\n                this.originalElement.css(&quot;resize&quot;, &quot;none&quot;);\r\n\r\n                this._proportionallyResizeElements.push(this.originalElement.css({\r\n                    position: &quot;static&quot;,\r\n                    zoom: 1,\r\n                    display: &quot;block&quot;\r\n                }));\r\n\r\n                this._proportionallyResize();\r\n            }\r\n\r\n            this._setupHandles();\r\n\r\n            if (o.autoHide) {\r\n                $(this.element)\r\n                    .on(&quot;mouseenter&quot;, function() {\r\n                        if (o.disabled) {\r\n                            return;\r\n                        }\r\n                        that._removeClass(&quot;ui-resizable-autohide&quot;);\r\n                        that._handles.show();\r\n                    })\r\n                    .on(&quot;mouseleave&quot;, function() {\r\n                        if (o.disabled) {\r\n                            return;\r\n                        }\r\n                        if (!that.resizing) {\r\n                            that._addClass(&quot;ui-resizable-autohide&quot;);\r\n                            that._handles.hide();\r\n                        }\r\n                    });\r\n            }\r\n\r\n            this._mouseInit();\r\n        },\r\n\r\n        _destroy: function() {\r\n\r\n            this._mouseDestroy();\r\n            this._addedHandles.remove();\r\n\r\n            var wrapper,\r\n                _destroy = function(exp) {\r\n                    $(exp)\r\n                        .removeData(&quot;resizable&quot;)\r\n                        .removeData(&quot;ui-resizable&quot;)\r\n                        .off(&quot;.resizable&quot;);\r\n                };\r\n\r\n            \/\/ TODO: Unwrap at same DOM position\r\n            if (this.elementIsWrapper) {\r\n                _destroy(this.element);\r\n                wrapper = this.element;\r\n                this.originalElement.css({\r\n                    position: wrapper.css(&quot;position&quot;),\r\n                    width: wrapper.outerWidth(),\r\n                    height: wrapper.outerHeight(),\r\n                    top: wrapper.css(&quot;top&quot;),\r\n                    left: wrapper.css(&quot;left&quot;)\r\n                }).insertAfter(wrapper);\r\n                wrapper.remove();\r\n            }\r\n\r\n            this.originalElement.css(&quot;resize&quot;, this.originalResizeStyle);\r\n            _destroy(this.originalElement);\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOption: function(key, value) {\r\n            this._super(key, value);\r\n\r\n            switch (key) {\r\n                case &quot;handles&quot;:\r\n                    this._removeHandles();\r\n                    this._setupHandles();\r\n                    break;\r\n                case &quot;aspectRatio&quot;:\r\n                    this._aspectRatio = !!value;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        },\r\n\r\n        _setupHandles: function() {\r\n            var o = this.options,\r\n                handle, i, n, hname, axis, that = this;\r\n            this.handles = o.handles ||\r\n                (!$(&quot;.ui-resizable-handle&quot;, this.element).length ?\r\n                    &quot;e,s,se&quot; : {\r\n                        n: &quot;.ui-resizable-n&quot;,\r\n                        e: &quot;.ui-resizable-e&quot;,\r\n                        s: &quot;.ui-resizable-s&quot;,\r\n                        w: &quot;.ui-resizable-w&quot;,\r\n                        se: &quot;.ui-resizable-se&quot;,\r\n                        sw: &quot;.ui-resizable-sw&quot;,\r\n                        ne: &quot;.ui-resizable-ne&quot;,\r\n                        nw: &quot;.ui-resizable-nw&quot;\r\n                    });\r\n\r\n            this._handles = $();\r\n            this._addedHandles = $();\r\n            if (this.handles.constructor === String) {\r\n\r\n                if (this.handles === &quot;all&quot;) {\r\n                    this.handles = &quot;n,e,s,w,se,sw,ne,nw&quot;;\r\n                }\r\n\r\n                n = this.handles.split(&quot;,&quot;);\r\n                this.handles = {};\r\n\r\n                for (i = 0; i &lt; n.length; i++) {\r\n\r\n                    handle = String.prototype.trim.call(n[i]);\r\n                    hname = &quot;ui-resizable-&quot; + handle;\r\n                    axis = $(&quot;&lt;div&gt;&quot;);\r\n                    this._addClass(axis, &quot;ui-resizable-handle &quot; + hname);\r\n\r\n                    axis.css({\r\n                        zIndex: o.zIndex\r\n                    });\r\n\r\n                    this.handles[handle] = &quot;.ui-resizable-&quot; + handle;\r\n                    if (!this.element.children(this.handles[handle]).length) {\r\n                        this.element.append(axis);\r\n                        this._addedHandles = this._addedHandles.add(axis);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            this._renderAxis = function(target) {\r\n\r\n                var i, axis, padPos, padWrapper;\r\n\r\n                target = target || this.element;\r\n\r\n                for (i in this.handles) {\r\n\r\n                    if (this.handles[i].constructor === String) {\r\n                        this.handles[i] = this.element.children(this.handles[i]).first().show();\r\n                    } else if (this.handles[i].jquery || this.handles[i].nodeType) {\r\n                        this.handles[i] = $(this.handles[i]);\r\n                        this._on(this.handles[i], {\r\n                            &quot;mousedown&quot;: that._mouseDown\r\n                        });\r\n                    }\r\n\r\n                    if (this.elementIsWrapper &amp;&amp;\r\n                        this.originalElement[0]\r\n                        .nodeName\r\n                        .match(\/^(textarea|input|select|button)$\/i)) {\r\n                        axis = $(this.handles[i], this.element);\r\n\r\n                        padWrapper = \/sw|ne|nw|se|n|s\/.test(i) ?\r\n                            axis.outerHeight() :\r\n                            axis.outerWidth();\r\n\r\n                        padPos = [&quot;padding&quot;,\r\n                            \/ne|nw|n\/.test(i) ? &quot;Top&quot; :\r\n                            \/se|sw|s\/.test(i) ? &quot;Bottom&quot; :\r\n                            \/^e$\/.test(i) ? &quot;Right&quot; : &quot;Left&quot;\r\n                        ].join(&quot;&quot;);\r\n\r\n                        target.css(padPos, padWrapper);\r\n\r\n                        this._proportionallyResize();\r\n                    }\r\n\r\n                    this._handles = this._handles.add(this.handles[i]);\r\n                }\r\n            };\r\n\r\n            \/\/ TODO: make renderAxis a prototype function\r\n            this._renderAxis(this.element);\r\n\r\n            this._handles = this._handles.add(this.element.find(&quot;.ui-resizable-handle&quot;));\r\n            this._handles.disableSelection();\r\n\r\n            this._handles.on(&quot;mouseover&quot;, function() {\r\n                if (!that.resizing) {\r\n                    if (this.className) {\r\n                        axis = this.className.match(\/ui-resizable-(se|sw|ne|nw|n|e|s|w)\/i);\r\n                    }\r\n                    that.axis = axis &amp;&amp; axis[1] ? axis[1] : &quot;se&quot;;\r\n                }\r\n            });\r\n\r\n            if (o.autoHide) {\r\n                this._handles.hide();\r\n                this._addClass(&quot;ui-resizable-autohide&quot;);\r\n            }\r\n        },\r\n\r\n        _removeHandles: function() {\r\n            this._addedHandles.remove();\r\n        },\r\n\r\n        _mouseCapture: function(event) {\r\n            var i, handle,\r\n                capture = false;\r\n\r\n            for (i in this.handles) {\r\n                handle = $(this.handles[i])[0];\r\n                if (handle === event.target || $.contains(handle, event.target)) {\r\n                    capture = true;\r\n                }\r\n            }\r\n\r\n            return !this.options.disabled &amp;&amp; capture;\r\n        },\r\n\r\n        _mouseStart: function(event) {\r\n\r\n            var curleft, curtop, cursor, calculatedSize,\r\n                o = this.options,\r\n                el = this.element;\r\n\r\n            this.resizing = true;\r\n\r\n            this._renderProxy();\r\n\r\n            curleft = this._num(this.helper.css(&quot;left&quot;));\r\n            curtop = this._num(this.helper.css(&quot;top&quot;));\r\n\r\n            if (o.containment) {\r\n                curleft += $(o.containment).scrollLeft() || 0;\r\n                curtop += $(o.containment).scrollTop() || 0;\r\n            }\r\n\r\n            this.offset = this.helper.offset();\r\n            this.position = {\r\n                left: curleft,\r\n                top: curtop\r\n            };\r\n\r\n            if (!this._helper) {\r\n                calculatedSize = this._calculateAdjustedElementDimensions(el);\r\n            }\r\n\r\n            this.size = this._helper ? {\r\n                width: this.helper.width(),\r\n                height: this.helper.height()\r\n            } : {\r\n                width: calculatedSize.width,\r\n                height: calculatedSize.height\r\n            };\r\n\r\n            this.originalSize = this._helper ? {\r\n                width: el.outerWidth(),\r\n                height: el.outerHeight()\r\n            } : {\r\n                width: calculatedSize.width,\r\n                height: calculatedSize.height\r\n            };\r\n\r\n            this.sizeDiff = {\r\n                width: el.outerWidth() - el.width(),\r\n                height: el.outerHeight() - el.height()\r\n            };\r\n\r\n            this.originalPosition = {\r\n                left: curleft,\r\n                top: curtop\r\n            };\r\n            this.originalMousePosition = {\r\n                left: event.pageX,\r\n                top: event.pageY\r\n            };\r\n\r\n            this.aspectRatio = (typeof o.aspectRatio === &quot;number&quot;) ?\r\n                o.aspectRatio :\r\n                ((this.originalSize.width \/ this.originalSize.height) || 1);\r\n\r\n            cursor = $(&quot;.ui-resizable-&quot; + this.axis).css(&quot;cursor&quot;);\r\n            $(&quot;body&quot;).css(&quot;cursor&quot;, cursor === &quot;auto&quot; ? this.axis + &quot;-resize&quot; : cursor);\r\n\r\n            this._addClass(&quot;ui-resizable-resizing&quot;);\r\n            this._propagate(&quot;start&quot;, event);\r\n            return true;\r\n        },\r\n\r\n        _mouseDrag: function(event) {\r\n\r\n            var data, props,\r\n                smp = this.originalMousePosition,\r\n                a = this.axis,\r\n                dx = (event.pageX - smp.left) || 0,\r\n                dy = (event.pageY - smp.top) || 0,\r\n                trigger = this._change[a];\r\n\r\n            this._updatePrevProperties();\r\n\r\n            if (!trigger) {\r\n                return false;\r\n            }\r\n\r\n            data = trigger.apply(this, [event, dx, dy]);\r\n\r\n            this._updateVirtualBoundaries(event.shiftKey);\r\n            if (this._aspectRatio || event.shiftKey) {\r\n                data = this._updateRatio(data, event);\r\n            }\r\n\r\n            data = this._respectSize(data, event);\r\n\r\n            this._updateCache(data);\r\n\r\n            this._propagate(&quot;resize&quot;, event);\r\n\r\n            props = this._applyChanges();\r\n\r\n            if (!this._helper &amp;&amp; this._proportionallyResizeElements.length) {\r\n                this._proportionallyResize();\r\n            }\r\n\r\n            if (!$.isEmptyObject(props)) {\r\n                this._updatePrevProperties();\r\n                this._trigger(&quot;resize&quot;, event, this.ui());\r\n                this._applyChanges();\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        _mouseStop: function(event) {\r\n\r\n            this.resizing = false;\r\n            var pr, ista, soffseth, soffsetw, s, left, top,\r\n                o = this.options,\r\n                that = this;\r\n\r\n            if (this._helper) {\r\n\r\n                pr = this._proportionallyResizeElements;\r\n                ista = pr.length &amp;&amp; (\/textarea\/i).test(pr[0].nodeName);\r\n                soffseth = ista &amp;&amp; this._hasScroll(pr[0], &quot;left&quot;) ? 0 : that.sizeDiff.height;\r\n                soffsetw = ista ? 0 : that.sizeDiff.width;\r\n\r\n                s = {\r\n                    width: (that.helper.width() - soffsetw),\r\n                    height: (that.helper.height() - soffseth)\r\n                };\r\n                left = (parseFloat(that.element.css(&quot;left&quot;)) +\r\n                    (that.position.left - that.originalPosition.left)) || null;\r\n                top = (parseFloat(that.element.css(&quot;top&quot;)) +\r\n                    (that.position.top - that.originalPosition.top)) || null;\r\n\r\n                if (!o.animate) {\r\n                    this.element.css($.extend(s, {\r\n                        top: top,\r\n                        left: left\r\n                    }));\r\n                }\r\n\r\n                that.helper.height(that.size.height);\r\n                that.helper.width(that.size.width);\r\n\r\n                if (this._helper &amp;&amp; !o.animate) {\r\n                    this._proportionallyResize();\r\n                }\r\n            }\r\n\r\n            $(&quot;body&quot;).css(&quot;cursor&quot;, &quot;auto&quot;);\r\n\r\n            this._removeClass(&quot;ui-resizable-resizing&quot;);\r\n\r\n            this._propagate(&quot;stop&quot;, event);\r\n\r\n            if (this._helper) {\r\n                this.helper.remove();\r\n            }\r\n\r\n            return false;\r\n\r\n        },\r\n\r\n        _updatePrevProperties: function() {\r\n            this.prevPosition = {\r\n                top: this.position.top,\r\n                left: this.position.left\r\n            };\r\n            this.prevSize = {\r\n                width: this.size.width,\r\n                height: this.size.height\r\n            };\r\n        },\r\n\r\n        _applyChanges: function() {\r\n            var props = {};\r\n\r\n            if (this.position.top !== this.prevPosition.top) {\r\n                props.top = this.position.top + &quot;px&quot;;\r\n            }\r\n            if (this.position.left !== this.prevPosition.left) {\r\n                props.left = this.position.left + &quot;px&quot;;\r\n            }\r\n\r\n            this.helper.css(props);\r\n\r\n            if (this.size.width !== this.prevSize.width) {\r\n                props.width = this.size.width + &quot;px&quot;;\r\n                this.helper.width(props.width);\r\n            }\r\n            if (this.size.height !== this.prevSize.height) {\r\n                props.height = this.size.height + &quot;px&quot;;\r\n                this.helper.height(props.height);\r\n            }\r\n\r\n            return props;\r\n        },\r\n\r\n        _updateVirtualBoundaries: function(forceAspectRatio) {\r\n            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,\r\n                o = this.options;\r\n\r\n            b = {\r\n                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,\r\n                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,\r\n                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,\r\n                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity\r\n            };\r\n\r\n            if (this._aspectRatio || forceAspectRatio) {\r\n                pMinWidth = b.minHeight * this.aspectRatio;\r\n                pMinHeight = b.minWidth \/ this.aspectRatio;\r\n                pMaxWidth = b.maxHeight * this.aspectRatio;\r\n                pMaxHeight = b.maxWidth \/ this.aspectRatio;\r\n\r\n                if (pMinWidth &gt; b.minWidth) {\r\n                    b.minWidth = pMinWidth;\r\n                }\r\n                if (pMinHeight &gt; b.minHeight) {\r\n                    b.minHeight = pMinHeight;\r\n                }\r\n                if (pMaxWidth &lt; b.maxWidth) {\r\n                    b.maxWidth = pMaxWidth;\r\n                }\r\n                if (pMaxHeight &lt; b.maxHeight) {\r\n                    b.maxHeight = pMaxHeight;\r\n                }\r\n            }\r\n            this._vBoundaries = b;\r\n        },\r\n\r\n        _updateCache: function(data) {\r\n            this.offset = this.helper.offset();\r\n            if (this._isNumber(data.left)) {\r\n                this.position.left = data.left;\r\n            }\r\n            if (this._isNumber(data.top)) {\r\n                this.position.top = data.top;\r\n            }\r\n            if (this._isNumber(data.height)) {\r\n                this.size.height = data.height;\r\n            }\r\n            if (this._isNumber(data.width)) {\r\n                this.size.width = data.width;\r\n            }\r\n        },\r\n\r\n        _updateRatio: function(data) {\r\n\r\n            var cpos = this.position,\r\n                csize = this.size,\r\n                a = this.axis;\r\n\r\n            if (this._isNumber(data.height)) {\r\n                data.width = (data.height * this.aspectRatio);\r\n            } else if (this._isNumber(data.width)) {\r\n                data.height = (data.width \/ this.aspectRatio);\r\n            }\r\n\r\n            if (a === &quot;sw&quot;) {\r\n                data.left = cpos.left + (csize.width - data.width);\r\n                data.top = null;\r\n            }\r\n            if (a === &quot;nw&quot;) {\r\n                data.top = cpos.top + (csize.height - data.height);\r\n                data.left = cpos.left + (csize.width - data.width);\r\n            }\r\n\r\n            return data;\r\n        },\r\n\r\n        _respectSize: function(data) {\r\n\r\n            var o = this._vBoundaries,\r\n                a = this.axis,\r\n                ismaxw = this._isNumber(data.width) &amp;&amp; o.maxWidth &amp;&amp; (o.maxWidth &lt; data.width),\r\n                ismaxh = this._isNumber(data.height) &amp;&amp; o.maxHeight &amp;&amp; (o.maxHeight &lt; data.height),\r\n                isminw = this._isNumber(data.width) &amp;&amp; o.minWidth &amp;&amp; (o.minWidth &gt; data.width),\r\n                isminh = this._isNumber(data.height) &amp;&amp; o.minHeight &amp;&amp; (o.minHeight &gt; data.height),\r\n                dw = this.originalPosition.left + this.originalSize.width,\r\n                dh = this.originalPosition.top + this.originalSize.height,\r\n                cw = \/sw|nw|w\/.test(a),\r\n                ch = \/nw|ne|n\/.test(a);\r\n            if (isminw) {\r\n                data.width = o.minWidth;\r\n            }\r\n            if (isminh) {\r\n                data.height = o.minHeight;\r\n            }\r\n            if (ismaxw) {\r\n                data.width = o.maxWidth;\r\n            }\r\n            if (ismaxh) {\r\n                data.height = o.maxHeight;\r\n            }\r\n\r\n            if (isminw &amp;&amp; cw) {\r\n                data.left = dw - o.minWidth;\r\n            }\r\n            if (ismaxw &amp;&amp; cw) {\r\n                data.left = dw - o.maxWidth;\r\n            }\r\n            if (isminh &amp;&amp; ch) {\r\n                data.top = dh - o.minHeight;\r\n            }\r\n            if (ismaxh &amp;&amp; ch) {\r\n                data.top = dh - o.maxHeight;\r\n            }\r\n\r\n            \/\/ Fixing jump error on top\/left - bug #2330\r\n            if (!data.width &amp;&amp; !data.height &amp;&amp; !data.left &amp;&amp; data.top) {\r\n                data.top = null;\r\n            } else if (!data.width &amp;&amp; !data.height &amp;&amp; !data.top &amp;&amp; data.left) {\r\n                data.left = null;\r\n            }\r\n\r\n            return data;\r\n        },\r\n\r\n        _getPaddingPlusBorderDimensions: function(element) {\r\n            var i = 0,\r\n                widths = [],\r\n                borders = [\r\n                    element.css(&quot;borderTopWidth&quot;),\r\n                    element.css(&quot;borderRightWidth&quot;),\r\n                    element.css(&quot;borderBottomWidth&quot;),\r\n                    element.css(&quot;borderLeftWidth&quot;)\r\n                ],\r\n                paddings = [\r\n                    element.css(&quot;paddingTop&quot;),\r\n                    element.css(&quot;paddingRight&quot;),\r\n                    element.css(&quot;paddingBottom&quot;),\r\n                    element.css(&quot;paddingLeft&quot;)\r\n                ];\r\n\r\n            for (; i &lt; 4; i++) {\r\n                widths[i] = (parseFloat(borders[i]) || 0);\r\n                widths[i] += (parseFloat(paddings[i]) || 0);\r\n            }\r\n\r\n            return {\r\n                height: widths[0] + widths[2],\r\n                width: widths[1] + widths[3]\r\n            };\r\n        },\r\n\r\n        _calculateAdjustedElementDimensions: function(element) {\r\n            var elWidth, elHeight, paddingBorder,\r\n                ce = element.get(0);\r\n\r\n            if (element.css(&quot;box-sizing&quot;) !== &quot;content-box&quot; ||\r\n                (!this._hasScroll(ce) &amp;&amp; !this._hasScroll(ce, &quot;left&quot;))) {\r\n                return {\r\n                    height: parseFloat(element.css(&quot;height&quot;)),\r\n                    width: parseFloat(element.css(&quot;width&quot;))\r\n                };\r\n            }\r\n\r\n            \/\/ Check if CSS inline styles are set and use those (usually from previous resizes)\r\n            elWidth = parseFloat(ce.style.width);\r\n            elHeight = parseFloat(ce.style.height);\r\n\r\n            paddingBorder = this._getPaddingPlusBorderDimensions(element);\r\n            elWidth = isNaN(elWidth) ?\r\n                this._getElementTheoreticalSize(element, paddingBorder, &quot;width&quot;) :\r\n                elWidth;\r\n            elHeight = isNaN(elHeight) ?\r\n                this._getElementTheoreticalSize(element, paddingBorder, &quot;height&quot;) :\r\n                elHeight;\r\n\r\n            return {\r\n                height: elHeight,\r\n                width: elWidth\r\n            };\r\n        },\r\n\r\n        _getElementTheoreticalSize: function(element, extraSize, dimension) {\r\n\r\n            \/\/ offsetWidth\/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\r\n            var size = Math.max(0, Math.ceil(\r\n                element.get(0)[&quot;offset&quot; + dimension[0].toUpperCase() + dimension.slice(1)] -\r\n                extraSize[dimension] -\r\n                0.5\r\n\r\n                \/\/ If offsetWidth\/offsetHeight is unknown, then we can&#039;t determine theoretical size.\r\n                \/\/ Use an explicit zero to avoid NaN.\r\n                \/\/ See https:\/\/github.com\/jquery\/jquery\/issues\/3964\r\n            )) || 0;\r\n\r\n            return size;\r\n        },\r\n\r\n        _proportionallyResize: function() {\r\n\r\n            if (!this._proportionallyResizeElements.length) {\r\n                return;\r\n            }\r\n\r\n            var prel,\r\n                i = 0,\r\n                element = this.helper || this.element;\r\n\r\n            for (; i &lt; this._proportionallyResizeElements.length; i++) {\r\n\r\n                prel = this._proportionallyResizeElements[i];\r\n\r\n                \/\/ TODO: Seems like a bug to cache this.outerDimensions\r\n                \/\/ considering that we are in a loop.\r\n                if (!this.outerDimensions) {\r\n                    this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);\r\n                }\r\n\r\n                prel.css({\r\n                    height: (element.height() - this.outerDimensions.height) || 0,\r\n                    width: (element.width() - this.outerDimensions.width) || 0\r\n                });\r\n\r\n            }\r\n\r\n        },\r\n\r\n        _renderProxy: function() {\r\n\r\n            var el = this.element,\r\n                o = this.options;\r\n            this.elementOffset = el.offset();\r\n\r\n            if (this._helper) {\r\n\r\n                this.helper = this.helper || $(&quot;&lt;div&gt;&lt;\/div&gt;&quot;).css({\r\n                    overflow: &quot;hidden&quot;\r\n                });\r\n\r\n                this._addClass(this.helper, this._helper);\r\n                this.helper.css({\r\n                    width: this.element.outerWidth(),\r\n                    height: this.element.outerHeight(),\r\n                    position: &quot;absolute&quot;,\r\n                    left: this.elementOffset.left + &quot;px&quot;,\r\n                    top: this.elementOffset.top + &quot;px&quot;,\r\n                    zIndex: ++o.zIndex \/\/TODO: Don&#039;t modify option\r\n                });\r\n\r\n                this.helper\r\n                    .appendTo(&quot;body&quot;)\r\n                    .disableSelection();\r\n\r\n            } else {\r\n                this.helper = this.element;\r\n            }\r\n\r\n        },\r\n\r\n        _change: {\r\n            e: function(event, dx) {\r\n                return {\r\n                    width: this.originalSize.width + dx\r\n                };\r\n            },\r\n            w: function(event, dx) {\r\n                var cs = this.originalSize,\r\n                    sp = this.originalPosition;\r\n                return {\r\n                    left: sp.left + dx,\r\n                    width: cs.width - dx\r\n                };\r\n            },\r\n            n: function(event, dx, dy) {\r\n                var cs = this.originalSize,\r\n                    sp = this.originalPosition;\r\n                return {\r\n                    top: sp.top + dy,\r\n                    height: cs.height - dy\r\n                };\r\n            },\r\n            s: function(event, dx, dy) {\r\n                return {\r\n                    height: this.originalSize.height + dy\r\n                };\r\n            },\r\n            se: function(event, dx, dy) {\r\n                return $.extend(this._change.s.apply(this, arguments),\r\n                    this._change.e.apply(this, [event, dx, dy]));\r\n            },\r\n            sw: function(event, dx, dy) {\r\n                return $.extend(this._change.s.apply(this, arguments),\r\n                    this._change.w.apply(this, [event, dx, dy]));\r\n            },\r\n            ne: function(event, dx, dy) {\r\n                return $.extend(this._change.n.apply(this, arguments),\r\n                    this._change.e.apply(this, [event, dx, dy]));\r\n            },\r\n            nw: function(event, dx, dy) {\r\n                return $.extend(this._change.n.apply(this, arguments),\r\n                    this._change.w.apply(this, [event, dx, dy]));\r\n            }\r\n        },\r\n\r\n        _propagate: function(n, event) {\r\n            $.ui.plugin.call(this, n, [event, this.ui()]);\r\n            if (n !== &quot;resize&quot;) {\r\n                this._trigger(n, event, this.ui());\r\n            }\r\n        },\r\n\r\n        plugins: {},\r\n\r\n        ui: function() {\r\n            return {\r\n                originalElement: this.originalElement,\r\n                element: this.element,\r\n                helper: this.helper,\r\n                position: this.position,\r\n                size: this.size,\r\n                originalSize: this.originalSize,\r\n                originalPosition: this.originalPosition\r\n            };\r\n        }\r\n\r\n    });\r\n\r\n    \/*\r\n     * Resizable Extensions\r\n     *\/\r\n\r\n    $.ui.plugin.add(&quot;resizable&quot;, &quot;animate&quot;, {\r\n\r\n        stop: function(event) {\r\n            var that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options,\r\n                pr = that._proportionallyResizeElements,\r\n                ista = pr.length &amp;&amp; (\/textarea\/i).test(pr[0].nodeName),\r\n                soffseth = ista &amp;&amp; that._hasScroll(pr[0], &quot;left&quot;) ? 0 : that.sizeDiff.height,\r\n                soffsetw = ista ? 0 : that.sizeDiff.width,\r\n                style = {\r\n                    width: (that.size.width - soffsetw),\r\n                    height: (that.size.height - soffseth)\r\n                },\r\n                left = (parseFloat(that.element.css(&quot;left&quot;)) +\r\n                    (that.position.left - that.originalPosition.left)) || null,\r\n                top = (parseFloat(that.element.css(&quot;top&quot;)) +\r\n                    (that.position.top - that.originalPosition.top)) || null;\r\n\r\n            that.element.animate(\r\n                $.extend(style, top &amp;&amp; left ? {\r\n                    top: top,\r\n                    left: left\r\n                } : {}), {\r\n                    duration: o.animateDuration,\r\n                    easing: o.animateEasing,\r\n                    step: function() {\r\n\r\n                        var data = {\r\n                            width: parseFloat(that.element.css(&quot;width&quot;)),\r\n                            height: parseFloat(that.element.css(&quot;height&quot;)),\r\n                            top: parseFloat(that.element.css(&quot;top&quot;)),\r\n                            left: parseFloat(that.element.css(&quot;left&quot;))\r\n                        };\r\n\r\n                        if (pr &amp;&amp; pr.length) {\r\n                            $(pr[0]).css({\r\n                                width: data.width,\r\n                                height: data.height\r\n                            });\r\n                        }\r\n\r\n                        \/\/ Propagating resize, and updating values for each animation step\r\n                        that._updateCache(data);\r\n                        that._propagate(&quot;resize&quot;, event);\r\n\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;resizable&quot;, &quot;containment&quot;, {\r\n\r\n        start: function() {\r\n            var element, p, co, ch, cw, width, height,\r\n                that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options,\r\n                el = that.element,\r\n                oc = o.containment,\r\n                ce = (oc instanceof $) ?\r\n                oc.get(0) :\r\n                (\/parent\/.test(oc)) ? el.parent().get(0) : oc;\r\n\r\n            if (!ce) {\r\n                return;\r\n            }\r\n\r\n            that.containerElement = $(ce);\r\n\r\n            if (\/document\/.test(oc) || oc === document) {\r\n                that.containerOffset = {\r\n                    left: 0,\r\n                    top: 0\r\n                };\r\n                that.containerPosition = {\r\n                    left: 0,\r\n                    top: 0\r\n                };\r\n\r\n                that.parentData = {\r\n                    element: $(document),\r\n                    left: 0,\r\n                    top: 0,\r\n                    width: $(document).width(),\r\n                    height: $(document).height() || document.body.parentNode.scrollHeight\r\n                };\r\n            } else {\r\n                element = $(ce);\r\n                p = [];\r\n                $([&quot;Top&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Bottom&quot;]).each(function(i, name) {\r\n                    p[i] = that._num(element.css(&quot;padding&quot; + name));\r\n                });\r\n\r\n                that.containerOffset = element.offset();\r\n                that.containerPosition = element.position();\r\n                that.containerSize = {\r\n                    height: (element.innerHeight() - p[3]),\r\n                    width: (element.innerWidth() - p[1])\r\n                };\r\n\r\n                co = that.containerOffset;\r\n                ch = that.containerSize.height;\r\n                cw = that.containerSize.width;\r\n                width = (that._hasScroll(ce, &quot;left&quot;) ? ce.scrollWidth : cw);\r\n                height = (that._hasScroll(ce) ? ce.scrollHeight : ch);\r\n\r\n                that.parentData = {\r\n                    element: ce,\r\n                    left: co.left,\r\n                    top: co.top,\r\n                    width: width,\r\n                    height: height\r\n                };\r\n            }\r\n        },\r\n\r\n        resize: function(event) {\r\n            var woset, hoset, isParent, isOffsetRelative,\r\n                that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options,\r\n                co = that.containerOffset,\r\n                cp = that.position,\r\n                pRatio = that._aspectRatio || event.shiftKey,\r\n                cop = {\r\n                    top: 0,\r\n                    left: 0\r\n                },\r\n                ce = that.containerElement,\r\n                continueResize = true;\r\n\r\n            if (ce[0] !== document &amp;&amp; (\/static\/).test(ce.css(&quot;position&quot;))) {\r\n                cop = co;\r\n            }\r\n\r\n            if (cp.left &lt; (that._helper ? co.left : 0)) {\r\n                that.size.width = that.size.width +\r\n                    (that._helper ?\r\n                        (that.position.left - co.left) :\r\n                        (that.position.left - cop.left));\r\n\r\n                if (pRatio) {\r\n                    that.size.height = that.size.width \/ that.aspectRatio;\r\n                    continueResize = false;\r\n                }\r\n                that.position.left = o.helper ? co.left : 0;\r\n            }\r\n\r\n            if (cp.top &lt; (that._helper ? co.top : 0)) {\r\n                that.size.height = that.size.height +\r\n                    (that._helper ?\r\n                        (that.position.top - co.top) :\r\n                        that.position.top);\r\n\r\n                if (pRatio) {\r\n                    that.size.width = that.size.height * that.aspectRatio;\r\n                    continueResize = false;\r\n                }\r\n                that.position.top = that._helper ? co.top : 0;\r\n            }\r\n\r\n            isParent = that.containerElement.get(0) === that.element.parent().get(0);\r\n            isOffsetRelative = \/relative|absolute\/.test(that.containerElement.css(&quot;position&quot;));\r\n\r\n            if (isParent &amp;&amp; isOffsetRelative) {\r\n                that.offset.left = that.parentData.left + that.position.left;\r\n                that.offset.top = that.parentData.top + that.position.top;\r\n            } else {\r\n                that.offset.left = that.element.offset().left;\r\n                that.offset.top = that.element.offset().top;\r\n            }\r\n\r\n            woset = Math.abs(that.sizeDiff.width +\r\n                (that._helper ?\r\n                    that.offset.left - cop.left :\r\n                    (that.offset.left - co.left)));\r\n\r\n            hoset = Math.abs(that.sizeDiff.height +\r\n                (that._helper ?\r\n                    that.offset.top - cop.top :\r\n                    (that.offset.top - co.top)));\r\n\r\n            if (woset + that.size.width &gt;= that.parentData.width) {\r\n                that.size.width = that.parentData.width - woset;\r\n                if (pRatio) {\r\n                    that.size.height = that.size.width \/ that.aspectRatio;\r\n                    continueResize = false;\r\n                }\r\n            }\r\n\r\n            if (hoset + that.size.height &gt;= that.parentData.height) {\r\n                that.size.height = that.parentData.height - hoset;\r\n                if (pRatio) {\r\n                    that.size.width = that.size.height * that.aspectRatio;\r\n                    continueResize = false;\r\n                }\r\n            }\r\n\r\n            if (!continueResize) {\r\n                that.position.left = that.prevPosition.left;\r\n                that.position.top = that.prevPosition.top;\r\n                that.size.width = that.prevSize.width;\r\n                that.size.height = that.prevSize.height;\r\n            }\r\n        },\r\n\r\n        stop: function() {\r\n            var that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options,\r\n                co = that.containerOffset,\r\n                cop = that.containerPosition,\r\n                ce = that.containerElement,\r\n                helper = $(that.helper),\r\n                ho = helper.offset(),\r\n                w = helper.outerWidth() - that.sizeDiff.width,\r\n                h = helper.outerHeight() - that.sizeDiff.height;\r\n\r\n            if (that._helper &amp;&amp; !o.animate &amp;&amp; (\/relative\/).test(ce.css(&quot;position&quot;))) {\r\n                $(this).css({\r\n                    left: ho.left - cop.left - co.left,\r\n                    width: w,\r\n                    height: h\r\n                });\r\n            }\r\n\r\n            if (that._helper &amp;&amp; !o.animate &amp;&amp; (\/static\/).test(ce.css(&quot;position&quot;))) {\r\n                $(this).css({\r\n                    left: ho.left - cop.left - co.left,\r\n                    width: w,\r\n                    height: h\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;resizable&quot;, &quot;alsoResize&quot;, {\r\n\r\n        start: function() {\r\n            var that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options;\r\n\r\n            $(o.alsoResize).each(function() {\r\n                var el = $(this),\r\n                    elSize = that._calculateAdjustedElementDimensions(el);\r\n\r\n                el.data(&quot;ui-resizable-alsoresize&quot;, {\r\n                    width: elSize.width,\r\n                    height: elSize.height,\r\n                    left: parseFloat(el.css(&quot;left&quot;)),\r\n                    top: parseFloat(el.css(&quot;top&quot;))\r\n                });\r\n            });\r\n        },\r\n\r\n        resize: function(event, ui) {\r\n            var that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options,\r\n                os = that.originalSize,\r\n                op = that.originalPosition,\r\n                delta = {\r\n                    height: (that.size.height - os.height) || 0,\r\n                    width: (that.size.width - os.width) || 0,\r\n                    top: (that.position.top - op.top) || 0,\r\n                    left: (that.position.left - op.left) || 0\r\n                };\r\n\r\n            $(o.alsoResize).each(function() {\r\n                var el = $(this),\r\n                    start = $(this).data(&quot;ui-resizable-alsoresize&quot;),\r\n                    style = {},\r\n                    css = el.parents(ui.originalElement[0]).length ? [&quot;width&quot;, &quot;height&quot;] : [&quot;width&quot;, &quot;height&quot;, &quot;top&quot;, &quot;left&quot;];\r\n\r\n                $.each(css, function(i, prop) {\r\n                    var sum = (start[prop] || 0) + (delta[prop] || 0);\r\n                    if (sum &amp;&amp; sum &gt;= 0) {\r\n                        style[prop] = sum || null;\r\n                    }\r\n                });\r\n\r\n                el.css(style);\r\n            });\r\n        },\r\n\r\n        stop: function() {\r\n            $(this).removeData(&quot;ui-resizable-alsoresize&quot;);\r\n        }\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;resizable&quot;, &quot;ghost&quot;, {\r\n\r\n        start: function() {\r\n\r\n            var that = $(this).resizable(&quot;instance&quot;),\r\n                cs = that.size;\r\n\r\n            that.ghost = that.originalElement.clone();\r\n            that.ghost.css({\r\n                opacity: 0.25,\r\n                display: &quot;block&quot;,\r\n                position: &quot;relative&quot;,\r\n                height: cs.height,\r\n                width: cs.width,\r\n                margin: 0,\r\n                left: 0,\r\n                top: 0\r\n            });\r\n\r\n            that._addClass(that.ghost, &quot;ui-resizable-ghost&quot;);\r\n\r\n            \/\/ DEPRECATED\r\n            \/\/ TODO: remove after 1.12\r\n            if ($.uiBackCompat === true &amp;&amp; typeof that.options.ghost === &quot;string&quot;) {\r\n\r\n                \/\/ Ghost option\r\n                that.ghost.addClass(this.options.ghost);\r\n            }\r\n\r\n            that.ghost.appendTo(that.helper);\r\n\r\n        },\r\n\r\n        resize: function() {\r\n            var that = $(this).resizable(&quot;instance&quot;);\r\n            if (that.ghost) {\r\n                that.ghost.css({\r\n                    position: &quot;relative&quot;,\r\n                    height: that.size.height,\r\n                    width: that.size.width\r\n                });\r\n            }\r\n        },\r\n\r\n        stop: function() {\r\n            var that = $(this).resizable(&quot;instance&quot;);\r\n            if (that.ghost &amp;&amp; that.helper) {\r\n                that.helper.get(0).removeChild(that.ghost.get(0));\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    $.ui.plugin.add(&quot;resizable&quot;, &quot;grid&quot;, {\r\n\r\n        resize: function() {\r\n            var outerDimensions,\r\n                that = $(this).resizable(&quot;instance&quot;),\r\n                o = that.options,\r\n                cs = that.size,\r\n                os = that.originalSize,\r\n                op = that.originalPosition,\r\n                a = that.axis,\r\n                grid = typeof o.grid === &quot;number&quot; ? [o.grid, o.grid] : o.grid,\r\n                gridX = (grid[0] || 1),\r\n                gridY = (grid[1] || 1),\r\n                ox = Math.round((cs.width - os.width) \/ gridX) * gridX,\r\n                oy = Math.round((cs.height - os.height) \/ gridY) * gridY,\r\n                newWidth = os.width + ox,\r\n                newHeight = os.height + oy,\r\n                isMaxWidth = o.maxWidth &amp;&amp; (o.maxWidth &lt; newWidth),\r\n                isMaxHeight = o.maxHeight &amp;&amp; (o.maxHeight &lt; newHeight),\r\n                isMinWidth = o.minWidth &amp;&amp; (o.minWidth &gt; newWidth),\r\n                isMinHeight = o.minHeight &amp;&amp; (o.minHeight &gt; newHeight);\r\n\r\n            o.grid = grid;\r\n\r\n            if (isMinWidth) {\r\n                newWidth += gridX;\r\n            }\r\n            if (isMinHeight) {\r\n                newHeight += gridY;\r\n            }\r\n            if (isMaxWidth) {\r\n                newWidth -= gridX;\r\n            }\r\n            if (isMaxHeight) {\r\n                newHeight -= gridY;\r\n            }\r\n\r\n            if (\/^(se|s|e)$\/.test(a)) {\r\n                that.size.width = newWidth;\r\n                that.size.height = newHeight;\r\n            } else if (\/^(ne)$\/.test(a)) {\r\n                that.size.width = newWidth;\r\n                that.size.height = newHeight;\r\n                that.position.top = op.top - oy;\r\n            } else if (\/^(sw)$\/.test(a)) {\r\n                that.size.width = newWidth;\r\n                that.size.height = newHeight;\r\n                that.position.left = op.left - ox;\r\n            } else {\r\n                if (newHeight - gridY &lt;= 0 || newWidth - gridX &lt;= 0) {\r\n                    outerDimensions = that._getPaddingPlusBorderDimensions(this);\r\n                }\r\n\r\n                if (newHeight - gridY &gt; 0) {\r\n                    that.size.height = newHeight;\r\n                    that.position.top = op.top - oy;\r\n                } else {\r\n                    newHeight = gridY - outerDimensions.height;\r\n                    that.size.height = newHeight;\r\n                    that.position.top = op.top + os.height - newHeight;\r\n                }\r\n                if (newWidth - gridX &gt; 0) {\r\n                    that.size.width = newWidth;\r\n                    that.position.left = op.left - ox;\r\n                } else {\r\n                    newWidth = gridX - outerDimensions.width;\r\n                    that.size.width = newWidth;\r\n                    that.position.left = op.left + os.width - newWidth;\r\n                }\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    var widgetsResizable = $.ui.resizable;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Selectable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Selectable\r\n    \/\/&gt;&gt;group: Interactions\r\n    \/\/&gt;&gt;description: Allows groups of elements to be selected with the mouse.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/selectable\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/selectable\/\r\n    \/\/&gt;&gt;css.structure: ..\/..\/themes\/base\/selectable.css\r\n\r\n\r\n    var widgetsSelectable = $.widget(&quot;ui.selectable&quot;, $.ui.mouse, {\r\n        version: &quot;1.14.1&quot;,\r\n        options: {\r\n            appendTo: &quot;body&quot;,\r\n            autoRefresh: true,\r\n            distance: 0,\r\n            filter: &quot;*&quot;,\r\n            tolerance: &quot;touch&quot;,\r\n\r\n            \/\/ Callbacks\r\n            selected: null,\r\n            selecting: null,\r\n            start: null,\r\n            stop: null,\r\n            unselected: null,\r\n            unselecting: null\r\n        },\r\n        _create: function() {\r\n            var that = this;\r\n\r\n            this._addClass(&quot;ui-selectable&quot;);\r\n\r\n            this.dragged = false;\r\n\r\n            \/\/ Cache selectee children based on filter\r\n            this.refresh = function() {\r\n                that.elementPos = $(that.element[0]).offset();\r\n                that.selectees = $(that.options.filter, that.element[0]);\r\n                that._addClass(that.selectees, &quot;ui-selectee&quot;);\r\n                that.selectees.each(function() {\r\n                    var $this = $(this),\r\n                        selecteeOffset = $this.offset(),\r\n                        pos = {\r\n                            left: selecteeOffset.left - that.elementPos.left,\r\n                            top: selecteeOffset.top - that.elementPos.top\r\n                        };\r\n                    $.data(this, &quot;selectable-item&quot;, {\r\n                        element: this,\r\n                        $element: $this,\r\n                        left: pos.left,\r\n                        top: pos.top,\r\n                        right: pos.left + $this.outerWidth(),\r\n                        bottom: pos.top + $this.outerHeight(),\r\n                        startselected: false,\r\n                        selected: $this.hasClass(&quot;ui-selected&quot;),\r\n                        selecting: $this.hasClass(&quot;ui-selecting&quot;),\r\n                        unselecting: $this.hasClass(&quot;ui-unselecting&quot;)\r\n                    });\r\n                });\r\n            };\r\n            this.refresh();\r\n\r\n            this._mouseInit();\r\n\r\n            this.helper = $(&quot;&lt;div&gt;&quot;);\r\n            this._addClass(this.helper, &quot;ui-selectable-helper&quot;);\r\n        },\r\n\r\n        _destroy: function() {\r\n            this.selectees.removeData(&quot;selectable-item&quot;);\r\n            this._mouseDestroy();\r\n        },\r\n\r\n        _mouseStart: function(event) {\r\n            var that = this,\r\n                options = this.options;\r\n\r\n            this.opos = [event.pageX, event.pageY];\r\n            this.elementPos = $(this.element[0]).offset();\r\n\r\n            if (this.options.disabled) {\r\n                return;\r\n            }\r\n\r\n            this.selectees = $(options.filter, this.element[0]);\r\n\r\n            this._trigger(&quot;start&quot;, event);\r\n\r\n            $(options.appendTo).append(this.helper);\r\n\r\n            \/\/ position helper (lasso)\r\n            this.helper.css({\r\n                &quot;left&quot;: event.pageX,\r\n                &quot;top&quot;: event.pageY,\r\n                &quot;width&quot;: 0,\r\n                &quot;height&quot;: 0\r\n            });\r\n\r\n            if (options.autoRefresh) {\r\n                this.refresh();\r\n            }\r\n\r\n            this.selectees.filter(&quot;.ui-selected&quot;).each(function() {\r\n                var selectee = $.data(this, &quot;selectable-item&quot;);\r\n                selectee.startselected = true;\r\n                if (!event.metaKey &amp;&amp; !event.ctrlKey) {\r\n                    that._removeClass(selectee.$element, &quot;ui-selected&quot;);\r\n                    selectee.selected = false;\r\n                    that._addClass(selectee.$element, &quot;ui-unselecting&quot;);\r\n                    selectee.unselecting = true;\r\n\r\n                    \/\/ selectable UNSELECTING callback\r\n                    that._trigger(&quot;unselecting&quot;, event, {\r\n                        unselecting: selectee.element\r\n                    });\r\n                }\r\n            });\r\n\r\n            $(event.target).parents().addBack().each(function() {\r\n                var doSelect,\r\n                    selectee = $.data(this, &quot;selectable-item&quot;);\r\n                if (selectee) {\r\n                    doSelect = (!event.metaKey &amp;&amp; !event.ctrlKey) ||\r\n                        !selectee.$element.hasClass(&quot;ui-selected&quot;);\r\n                    that._removeClass(selectee.$element, doSelect ? &quot;ui-unselecting&quot; : &quot;ui-selected&quot;)\r\n                        ._addClass(selectee.$element, doSelect ? &quot;ui-selecting&quot; : &quot;ui-unselecting&quot;);\r\n                    selectee.unselecting = !doSelect;\r\n                    selectee.selecting = doSelect;\r\n                    selectee.selected = doSelect;\r\n\r\n                    \/\/ selectable (UN)SELECTING callback\r\n                    if (doSelect) {\r\n                        that._trigger(&quot;selecting&quot;, event, {\r\n                            selecting: selectee.element\r\n                        });\r\n                    } else {\r\n                        that._trigger(&quot;unselecting&quot;, event, {\r\n                            unselecting: selectee.element\r\n                        });\r\n                    }\r\n                    return false;\r\n                }\r\n            });\r\n\r\n        },\r\n\r\n        _mouseDrag: function(event) {\r\n\r\n            this.dragged = true;\r\n\r\n            if (this.options.disabled) {\r\n                return;\r\n            }\r\n\r\n            var tmp,\r\n                that = this,\r\n                options = this.options,\r\n                x1 = this.opos[0],\r\n                y1 = this.opos[1],\r\n                x2 = event.pageX,\r\n                y2 = event.pageY;\r\n\r\n            if (x1 &gt; x2) {\r\n                tmp = x2;\r\n                x2 = x1;\r\n                x1 = tmp;\r\n            }\r\n            if (y1 &gt; y2) {\r\n                tmp = y2;\r\n                y2 = y1;\r\n                y1 = tmp;\r\n            }\r\n            this.helper.css({\r\n                left: x1,\r\n                top: y1,\r\n                width: x2 - x1,\r\n                height: y2 - y1\r\n            });\r\n\r\n            this.selectees.each(function() {\r\n                var selectee = $.data(this, &quot;selectable-item&quot;),\r\n                    hit = false,\r\n                    offset = {};\r\n\r\n                \/\/prevent helper from being selected if appendTo: selectable\r\n                if (!selectee || selectee.element === that.element[0]) {\r\n                    return;\r\n                }\r\n\r\n                offset.left = selectee.left + that.elementPos.left;\r\n                offset.right = selectee.right + that.elementPos.left;\r\n                offset.top = selectee.top + that.elementPos.top;\r\n                offset.bottom = selectee.bottom + that.elementPos.top;\r\n\r\n                if (options.tolerance === &quot;touch&quot;) {\r\n                    hit = (!(offset.left &gt; x2 || offset.right &lt; x1 || offset.top &gt; y2 ||\r\n                        offset.bottom &lt; y1));\r\n                } else if (options.tolerance === &quot;fit&quot;) {\r\n                    hit = (offset.left &gt; x1 &amp;&amp; offset.right &lt; x2 &amp;&amp; offset.top &gt; y1 &amp;&amp;\r\n                        offset.bottom &lt; y2);\r\n                }\r\n\r\n                if (hit) {\r\n\r\n                    \/\/ SELECT\r\n                    if (selectee.selected) {\r\n                        that._removeClass(selectee.$element, &quot;ui-selected&quot;);\r\n                        selectee.selected = false;\r\n                    }\r\n                    if (selectee.unselecting) {\r\n                        that._removeClass(selectee.$element, &quot;ui-unselecting&quot;);\r\n                        selectee.unselecting = false;\r\n                    }\r\n                    if (!selectee.selecting) {\r\n                        that._addClass(selectee.$element, &quot;ui-selecting&quot;);\r\n                        selectee.selecting = true;\r\n\r\n                        \/\/ selectable SELECTING callback\r\n                        that._trigger(&quot;selecting&quot;, event, {\r\n                            selecting: selectee.element\r\n                        });\r\n                    }\r\n                } else {\r\n\r\n                    \/\/ UNSELECT\r\n                    if (selectee.selecting) {\r\n                        if ((event.metaKey || event.ctrlKey) &amp;&amp; selectee.startselected) {\r\n                            that._removeClass(selectee.$element, &quot;ui-selecting&quot;);\r\n                            selectee.selecting = false;\r\n                            that._addClass(selectee.$element, &quot;ui-selected&quot;);\r\n                            selectee.selected = true;\r\n                        } else {\r\n                            that._removeClass(selectee.$element, &quot;ui-selecting&quot;);\r\n                            selectee.selecting = false;\r\n                            if (selectee.startselected) {\r\n                                that._addClass(selectee.$element, &quot;ui-unselecting&quot;);\r\n                                selectee.unselecting = true;\r\n                            }\r\n\r\n                            \/\/ selectable UNSELECTING callback\r\n                            that._trigger(&quot;unselecting&quot;, event, {\r\n                                unselecting: selectee.element\r\n                            });\r\n                        }\r\n                    }\r\n                    if (selectee.selected) {\r\n                        if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp; !selectee.startselected) {\r\n                            that._removeClass(selectee.$element, &quot;ui-selected&quot;);\r\n                            selectee.selected = false;\r\n\r\n                            that._addClass(selectee.$element, &quot;ui-unselecting&quot;);\r\n                            selectee.unselecting = true;\r\n\r\n                            \/\/ selectable UNSELECTING callback\r\n                            that._trigger(&quot;unselecting&quot;, event, {\r\n                                unselecting: selectee.element\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            return false;\r\n        },\r\n\r\n        _mouseStop: function(event) {\r\n            var that = this;\r\n\r\n            this.dragged = false;\r\n\r\n            $(&quot;.ui-unselecting&quot;, this.element[0]).each(function() {\r\n                var selectee = $.data(this, &quot;selectable-item&quot;);\r\n                that._removeClass(selectee.$element, &quot;ui-unselecting&quot;);\r\n                selectee.unselecting = false;\r\n                selectee.startselected = false;\r\n                that._trigger(&quot;unselected&quot;, event, {\r\n                    unselected: selectee.element\r\n                });\r\n            });\r\n            $(&quot;.ui-selecting&quot;, this.element[0]).each(function() {\r\n                var selectee = $.data(this, &quot;selectable-item&quot;);\r\n                that._removeClass(selectee.$element, &quot;ui-selecting&quot;)\r\n                    ._addClass(selectee.$element, &quot;ui-selected&quot;);\r\n                selectee.selecting = false;\r\n                selectee.selected = true;\r\n                selectee.startselected = true;\r\n                that._trigger(&quot;selected&quot;, event, {\r\n                    selected: selectee.element\r\n                });\r\n            });\r\n            this._trigger(&quot;stop&quot;, event);\r\n\r\n            this.helper.remove();\r\n\r\n            return false;\r\n        }\r\n\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Sortable 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Sortable\r\n    \/\/&gt;&gt;group: Interactions\r\n    \/\/&gt;&gt;description: Enables items in a list to be sorted using the mouse.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/sortable\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/sortable\/\r\n    \/\/&gt;&gt;css.structure: ..\/..\/themes\/base\/sortable.css\r\n\r\n\r\n    var widgetsSortable = $.widget(&quot;ui.sortable&quot;, $.ui.mouse, {\r\n        version: &quot;1.14.1&quot;,\r\n        widgetEventPrefix: &quot;sort&quot;,\r\n        ready: false,\r\n        options: {\r\n            appendTo: &quot;parent&quot;,\r\n            axis: false,\r\n            connectWith: false,\r\n            containment: false,\r\n            cursor: &quot;auto&quot;,\r\n            cursorAt: false,\r\n            dropOnEmpty: true,\r\n            forcePlaceholderSize: false,\r\n            forceHelperSize: false,\r\n            grid: false,\r\n            handle: false,\r\n            helper: &quot;original&quot;,\r\n            items: &quot;&gt; *&quot;,\r\n            opacity: false,\r\n            placeholder: false,\r\n            revert: false,\r\n            scroll: true,\r\n            scrollSensitivity: 20,\r\n            scrollSpeed: 20,\r\n            scope: &quot;default&quot;,\r\n            tolerance: &quot;intersect&quot;,\r\n            zIndex: 1000,\r\n\r\n            \/\/ Callbacks\r\n            activate: null,\r\n            beforeStop: null,\r\n            change: null,\r\n            deactivate: null,\r\n            out: null,\r\n            over: null,\r\n            receive: null,\r\n            remove: null,\r\n            sort: null,\r\n            start: null,\r\n            stop: null,\r\n            update: null\r\n        },\r\n\r\n        _isOverAxis: function(x, reference, size) {\r\n            return (x &gt;= reference) &amp;&amp; (x &lt; (reference + size));\r\n        },\r\n\r\n        _isFloating: function(item) {\r\n            return (\/left|right\/).test(item.css(&quot;float&quot;)) ||\r\n                (\/inline|table-cell\/).test(item.css(&quot;display&quot;));\r\n        },\r\n\r\n        _create: function() {\r\n            this.containerCache = {};\r\n            this._addClass(&quot;ui-sortable&quot;);\r\n\r\n            \/\/Get the items\r\n            this.refresh();\r\n\r\n            \/\/Let&#039;s determine the parent&#039;s offset\r\n            this.offset = this.element.offset();\r\n\r\n            \/\/Initialize mouse events for interaction\r\n            this._mouseInit();\r\n\r\n            this._setHandleClassName();\r\n\r\n            \/\/We&#039;re ready to go\r\n            this.ready = true;\r\n\r\n        },\r\n\r\n        _setOption: function(key, value) {\r\n            this._super(key, value);\r\n\r\n            if (key === &quot;handle&quot;) {\r\n                this._setHandleClassName();\r\n            }\r\n        },\r\n\r\n        _setHandleClassName: function() {\r\n            var that = this;\r\n            this._removeClass(this.element.find(&quot;.ui-sortable-handle&quot;), &quot;ui-sortable-handle&quot;);\r\n            $.each(this.items, function() {\r\n                that._addClass(\r\n                    this.instance.options.handle ?\r\n                    this.item.find(this.instance.options.handle) :\r\n                    this.item,\r\n                    &quot;ui-sortable-handle&quot;\r\n                );\r\n            });\r\n        },\r\n\r\n        _destroy: function() {\r\n            this._mouseDestroy();\r\n\r\n            for (var i = this.items.length - 1; i &gt;= 0; i--) {\r\n                this.items[i].item.removeData(this.widgetName + &quot;-item&quot;);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        _mouseCapture: function(event, overrideHandle) {\r\n            var currentItem = null,\r\n                validHandle = false,\r\n                that = this;\r\n\r\n            if (this.reverting) {\r\n                return false;\r\n            }\r\n\r\n            if (this.options.disabled || this.options.type === &quot;static&quot;) {\r\n                return false;\r\n            }\r\n\r\n            \/\/We have to refresh the items data once first\r\n            this._refreshItems(event);\r\n\r\n            \/\/Find out if the clicked node (or one of its parents) is a actual item in this.items\r\n            $(event.target).parents().each(function() {\r\n                if ($.data(this, that.widgetName + &quot;-item&quot;) === that) {\r\n                    currentItem = $(this);\r\n                    return false;\r\n                }\r\n            });\r\n            if ($.data(event.target, that.widgetName + &quot;-item&quot;) === that) {\r\n                currentItem = $(event.target);\r\n            }\r\n\r\n            if (!currentItem) {\r\n                return false;\r\n            }\r\n            if (this.options.handle &amp;&amp; !overrideHandle) {\r\n                $(this.options.handle, currentItem).find(&quot;*&quot;).addBack().each(function() {\r\n                    if (this === event.target) {\r\n                        validHandle = true;\r\n                    }\r\n                });\r\n                if (!validHandle) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this.currentItem = currentItem;\r\n            this._removeCurrentsFromItems();\r\n            return true;\r\n\r\n        },\r\n\r\n        _mouseStart: function(event, overrideHandle, noActivation) {\r\n\r\n            var i, body,\r\n                o = this.options;\r\n\r\n            this.currentContainer = this;\r\n\r\n            \/\/We only need to call refreshPositions, because the refreshItems call has been moved to\r\n            \/\/ mouseCapture\r\n            this.refreshPositions();\r\n\r\n            \/\/Prepare the dragged items parent\r\n            this.appendTo = $(o.appendTo !== &quot;parent&quot; ?\r\n                o.appendTo :\r\n                this.currentItem.parent());\r\n\r\n            \/\/Create and append the visible helper\r\n            this.helper = this._createHelper(event);\r\n\r\n            \/\/Cache the helper size\r\n            this._cacheHelperProportions();\r\n\r\n            \/*\r\n             * - Position generation -\r\n             * This block generates everything position related - it&#039;s the core of draggables.\r\n             *\/\r\n\r\n            \/\/Cache the margins of the original element\r\n            this._cacheMargins();\r\n\r\n            \/\/The element&#039;s absolute position on the page minus margins\r\n            this.offset = this.currentItem.offset();\r\n            this.offset = {\r\n                top: this.offset.top - this.margins.top,\r\n                left: this.offset.left - this.margins.left\r\n            };\r\n\r\n            $.extend(this.offset, {\r\n                click: { \/\/Where the click happened, relative to the element\r\n                    left: event.pageX - this.offset.left,\r\n                    top: event.pageY - this.offset.top\r\n                },\r\n\r\n                \/\/ This is a relative to absolute position minus the actual position calculation -\r\n                \/\/ only used for relative positioned helper\r\n                relative: this._getRelativeOffset()\r\n            });\r\n\r\n            \/\/ After we get the helper offset, but before we get the parent offset we can\r\n            \/\/ change the helper&#039;s position to absolute\r\n            \/\/ TODO: Still need to figure out a way to make relative sorting possible\r\n            this.helper.css(&quot;position&quot;, &quot;absolute&quot;);\r\n            this.cssPosition = this.helper.css(&quot;position&quot;);\r\n\r\n            \/\/Adjust the mouse offset relative to the helper if &quot;cursorAt&quot; is supplied\r\n            if (o.cursorAt) {\r\n                this._adjustOffsetFromHelper(o.cursorAt);\r\n            }\r\n\r\n            \/\/Cache the former DOM position\r\n            this.domPosition = {\r\n                prev: this.currentItem.prev()[0],\r\n                parent: this.currentItem.parent()[0]\r\n            };\r\n\r\n            \/\/ If the helper is not the original, hide the original so it&#039;s not playing any role during\r\n            \/\/ the drag, won&#039;t cause anything bad this way\r\n            if (this.helper[0] !== this.currentItem[0]) {\r\n                this.currentItem.hide();\r\n            }\r\n\r\n            \/\/Create the placeholder\r\n            this._createPlaceholder();\r\n\r\n            \/\/Get the next scrolling parent\r\n            this.scrollParent = this.placeholder.scrollParent();\r\n\r\n            $.extend(this.offset, {\r\n                parent: this._getParentOffset()\r\n            });\r\n\r\n            \/\/Set a containment if given in the options\r\n            if (o.containment) {\r\n                this._setContainment();\r\n            }\r\n\r\n            if (o.cursor &amp;&amp; o.cursor !== &quot;auto&quot;) { \/\/ cursor option\r\n                body = this.document.find(&quot;body&quot;);\r\n\r\n                this._storedStylesheet =\r\n                    $(&quot;&lt;style&gt;*{ cursor: &quot; + o.cursor + &quot; !important; }&lt;\/style&gt;&quot;).appendTo(body);\r\n            }\r\n\r\n            \/\/ We need to make sure to grab the zIndex before setting the\r\n            \/\/ opacity, because setting the opacity to anything lower than 1\r\n            \/\/ causes the zIndex to change from &quot;auto&quot; to 0.\r\n            if (o.zIndex) { \/\/ zIndex option\r\n                if (this.helper.css(&quot;zIndex&quot;)) {\r\n                    this._storedZIndex = this.helper.css(&quot;zIndex&quot;);\r\n                }\r\n                this.helper.css(&quot;zIndex&quot;, o.zIndex);\r\n            }\r\n\r\n            if (o.opacity) { \/\/ opacity option\r\n                if (this.helper.css(&quot;opacity&quot;)) {\r\n                    this._storedOpacity = this.helper.css(&quot;opacity&quot;);\r\n                }\r\n                this.helper.css(&quot;opacity&quot;, o.opacity);\r\n            }\r\n\r\n            \/\/Prepare scrolling\r\n            if (this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                this.scrollParent[0].tagName !== &quot;HTML&quot;) {\r\n                this.overflowOffset = this.scrollParent.offset();\r\n            }\r\n\r\n            \/\/Call callbacks\r\n            this._trigger(&quot;start&quot;, event, this._uiHash());\r\n\r\n            \/\/Recache the helper size\r\n            if (!this._preserveHelperProportions) {\r\n                this._cacheHelperProportions();\r\n            }\r\n\r\n            \/\/Post &quot;activate&quot; events to possible containers\r\n            if (!noActivation) {\r\n                for (i = this.containers.length - 1; i &gt;= 0; i--) {\r\n                    this.containers[i]._trigger(&quot;activate&quot;, event, this._uiHash(this));\r\n                }\r\n            }\r\n\r\n            \/\/Prepare possible droppables\r\n            if ($.ui.ddmanager) {\r\n                $.ui.ddmanager.current = this;\r\n            }\r\n\r\n            if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour) {\r\n                $.ui.ddmanager.prepareOffsets(this, event);\r\n            }\r\n\r\n            this.dragging = true;\r\n\r\n            this._addClass(this.helper, &quot;ui-sortable-helper&quot;);\r\n\r\n            \/\/Move the helper, if needed\r\n            if (!this.helper.parent().is(this.appendTo)) {\r\n                this.helper.detach().appendTo(this.appendTo);\r\n\r\n                \/\/Update position\r\n                this.offset.parent = this._getParentOffset();\r\n            }\r\n\r\n            \/\/Generate the original position\r\n            this.position = this.originalPosition = this._generatePosition(event);\r\n            this.originalPageX = event.pageX;\r\n            this.originalPageY = event.pageY;\r\n            this.lastPositionAbs = this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);\r\n\r\n            this._mouseDrag(event);\r\n\r\n            return true;\r\n\r\n        },\r\n\r\n        _scroll: function(event) {\r\n            var o = this.options,\r\n                scrolled = false;\r\n\r\n            if (this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                this.scrollParent[0].tagName !== &quot;HTML&quot;) {\r\n\r\n                if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) -\r\n                    event.pageY &lt; o.scrollSensitivity) {\r\n                    this.scrollParent[0].scrollTop =\r\n                        scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\r\n                } else if (event.pageY - this.overflowOffset.top &lt; o.scrollSensitivity) {\r\n                    this.scrollParent[0].scrollTop =\r\n                        scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\r\n                }\r\n\r\n                if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) -\r\n                    event.pageX &lt; o.scrollSensitivity) {\r\n                    this.scrollParent[0].scrollLeft = scrolled =\r\n                        this.scrollParent[0].scrollLeft + o.scrollSpeed;\r\n                } else if (event.pageX - this.overflowOffset.left &lt; o.scrollSensitivity) {\r\n                    this.scrollParent[0].scrollLeft = scrolled =\r\n                        this.scrollParent[0].scrollLeft - o.scrollSpeed;\r\n                }\r\n\r\n            } else {\r\n\r\n                if (event.pageY - this.document.scrollTop() &lt; o.scrollSensitivity) {\r\n                    scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);\r\n                } else if (this.window.height() - (event.pageY - this.document.scrollTop()) &lt;\r\n                    o.scrollSensitivity) {\r\n                    scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);\r\n                }\r\n\r\n                if (event.pageX - this.document.scrollLeft() &lt; o.scrollSensitivity) {\r\n                    scrolled = this.document.scrollLeft(\r\n                        this.document.scrollLeft() - o.scrollSpeed\r\n                    );\r\n                } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) &lt;\r\n                    o.scrollSensitivity) {\r\n                    scrolled = this.document.scrollLeft(\r\n                        this.document.scrollLeft() + o.scrollSpeed\r\n                    );\r\n                }\r\n\r\n            }\r\n\r\n            return scrolled;\r\n        },\r\n\r\n        _mouseDrag: function(event) {\r\n            var i, item, itemElement, intersection,\r\n                o = this.options;\r\n\r\n            \/\/Compute the helpers position\r\n            this.position = this._generatePosition(event);\r\n            this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);\r\n\r\n            \/\/Set the helper position\r\n            if (!this.options.axis || this.options.axis !== &quot;y&quot;) {\r\n                this.helper[0].style.left = this.position.left + &quot;px&quot;;\r\n            }\r\n            if (!this.options.axis || this.options.axis !== &quot;x&quot;) {\r\n                this.helper[0].style.top = this.position.top + &quot;px&quot;;\r\n            }\r\n\r\n            \/\/Do scrolling\r\n            if (o.scroll) {\r\n                if (this._scroll(event) !== false) {\r\n\r\n                    \/\/Update item positions used in position checks\r\n                    this._refreshItemPositions(true);\r\n\r\n                    if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour) {\r\n                        $.ui.ddmanager.prepareOffsets(this, event);\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.dragDirection = {\r\n                vertical: this._getDragVerticalDirection(),\r\n                horizontal: this._getDragHorizontalDirection()\r\n            };\r\n\r\n            \/\/Rearrange\r\n            for (i = this.items.length - 1; i &gt;= 0; i--) {\r\n\r\n                \/\/Cache variables and intersection, continue if no intersection\r\n                item = this.items[i];\r\n                itemElement = item.item[0];\r\n                intersection = this._intersectsWithPointer(item);\r\n                if (!intersection) {\r\n                    continue;\r\n                }\r\n\r\n                \/\/ Only put the placeholder inside the current Container, skip all\r\n                \/\/ items from other containers. This works because when moving\r\n                \/\/ an item from one container to another the\r\n                \/\/ currentContainer is switched before the placeholder is moved.\r\n                \/\/\r\n                \/\/ Without this, moving items in &quot;sub-sortables&quot; can cause\r\n                \/\/ the placeholder to jitter between the outer and inner container.\r\n                if (item.instance !== this.currentContainer) {\r\n                    continue;\r\n                }\r\n\r\n                \/\/ Cannot intersect with itself\r\n                \/\/ no useless actions that have been done before\r\n                \/\/ no action if the item moved is the parent of the item checked\r\n                if (itemElement !== this.currentItem[0] &amp;&amp;\r\n                    this.placeholder[intersection === 1 ?\r\n                        &quot;next&quot; : &quot;prev&quot;]()[0] !== itemElement &amp;&amp;\r\n                    !$.contains(this.placeholder[0], itemElement) &amp;&amp;\r\n                    (this.options.type === &quot;semi-dynamic&quot; ?\r\n                        !$.contains(this.element[0], itemElement) :\r\n                        true\r\n                    )\r\n                ) {\r\n\r\n                    this.direction = intersection === 1 ? &quot;down&quot; : &quot;up&quot;;\r\n\r\n                    if (this.options.tolerance === &quot;pointer&quot; ||\r\n                        this._intersectsWithSides(item)) {\r\n                        this._rearrange(event, item);\r\n                    } else {\r\n                        break;\r\n                    }\r\n\r\n                    this._trigger(&quot;change&quot;, event, this._uiHash());\r\n                    break;\r\n                }\r\n            }\r\n\r\n            \/\/Post events to containers\r\n            this._contactContainers(event);\r\n\r\n            \/\/Interconnect with droppables\r\n            if ($.ui.ddmanager) {\r\n                $.ui.ddmanager.drag(this, event);\r\n            }\r\n\r\n            \/\/Call callbacks\r\n            this._trigger(&quot;sort&quot;, event, this._uiHash());\r\n\r\n            this.lastPositionAbs = this.positionAbs;\r\n            return false;\r\n\r\n        },\r\n\r\n        _mouseStop: function(event, noPropagation) {\r\n\r\n            if (!event) {\r\n                return;\r\n            }\r\n\r\n            \/\/If we are using droppables, inform the manager about the drop\r\n            if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour) {\r\n                $.ui.ddmanager.drop(this, event);\r\n            }\r\n\r\n            if (this.options.revert) {\r\n                var that = this,\r\n                    cur = this.placeholder.offset(),\r\n                    axis = this.options.axis,\r\n                    animation = {};\r\n\r\n                if (!axis || axis === &quot;x&quot;) {\r\n                    animation.left = cur.left - this.offset.parent.left - this.margins.left +\r\n                        (this.offsetParent[0] === this.document[0].body ?\r\n                            0 :\r\n                            this.offsetParent[0].scrollLeft\r\n                        );\r\n                }\r\n                if (!axis || axis === &quot;y&quot;) {\r\n                    animation.top = cur.top - this.offset.parent.top - this.margins.top +\r\n                        (this.offsetParent[0] === this.document[0].body ?\r\n                            0 :\r\n                            this.offsetParent[0].scrollTop\r\n                        );\r\n                }\r\n                this.reverting = true;\r\n                $(this.helper).animate(\r\n                    animation,\r\n                    parseInt(this.options.revert, 10) || 500,\r\n                    function() {\r\n                        that._clear(event);\r\n                    }\r\n                );\r\n            } else {\r\n                this._clear(event, noPropagation);\r\n            }\r\n\r\n            return false;\r\n\r\n        },\r\n\r\n        cancel: function() {\r\n\r\n            if (this.dragging) {\r\n\r\n                this._mouseUp(new $.Event(&quot;mouseup&quot;, {\r\n                    target: null\r\n                }));\r\n\r\n                if (this.options.helper === &quot;original&quot;) {\r\n                    this.currentItem.css(this._storedCSS);\r\n                    this._removeClass(this.currentItem, &quot;ui-sortable-helper&quot;);\r\n                } else {\r\n                    this.currentItem.show();\r\n                }\r\n\r\n                \/\/Post deactivating events to containers\r\n                for (var i = this.containers.length - 1; i &gt;= 0; i--) {\r\n                    this.containers[i]._trigger(&quot;deactivate&quot;, null, this._uiHash(this));\r\n                    if (this.containers[i].containerCache.over) {\r\n                        this.containers[i]._trigger(&quot;out&quot;, null, this._uiHash(this));\r\n                        this.containers[i].containerCache.over = 0;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            if (this.placeholder) {\r\n\r\n                \/\/$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,\r\n                \/\/ it unbinds ALL events from the original node!\r\n                if (this.placeholder[0].parentNode) {\r\n                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\r\n                }\r\n                if (this.options.helper !== &quot;original&quot; &amp;&amp; this.helper &amp;&amp;\r\n                    this.helper[0].parentNode) {\r\n                    this.helper.remove();\r\n                }\r\n\r\n                $.extend(this, {\r\n                    helper: null,\r\n                    dragging: false,\r\n                    reverting: false,\r\n                    _noFinalSort: null\r\n                });\r\n\r\n                if (this.domPosition.prev) {\r\n                    $(this.domPosition.prev).after(this.currentItem);\r\n                } else {\r\n                    $(this.domPosition.parent).prepend(this.currentItem);\r\n                }\r\n            }\r\n\r\n            return this;\r\n\r\n        },\r\n\r\n        serialize: function(o) {\r\n\r\n            var items = this._getItemsAsjQuery(o &amp;&amp; o.connected),\r\n                str = [];\r\n            o = o || {};\r\n\r\n            $(items).each(function() {\r\n                var res = ($(o.item || this).attr(o.attribute || &quot;id&quot;) || &quot;&quot;)\r\n                    .match(o.expression || (\/(.+)[\\-=_](.+)\/));\r\n                if (res) {\r\n                    str.push(\r\n                        (o.key || res[1] + &quot;[]&quot;) +\r\n                        &quot;=&quot; + (o.key &amp;&amp; o.expression ? res[1] : res[2]));\r\n                }\r\n            });\r\n\r\n            if (!str.length &amp;&amp; o.key) {\r\n                str.push(o.key + &quot;=&quot;);\r\n            }\r\n\r\n            return str.join(&quot;&amp;&quot;);\r\n\r\n        },\r\n\r\n        toArray: function(o) {\r\n\r\n            var items = this._getItemsAsjQuery(o &amp;&amp; o.connected),\r\n                ret = [];\r\n\r\n            o = o || {};\r\n\r\n            items.each(function() {\r\n                ret.push($(o.item || this).attr(o.attribute || &quot;id&quot;) || &quot;&quot;);\r\n            });\r\n            return ret;\r\n\r\n        },\r\n\r\n        \/* Be careful with the following core functions *\/\r\n        _intersectsWith: function(item) {\r\n\r\n            var x1 = this.positionAbs.left,\r\n                x2 = x1 + this.helperProportions.width,\r\n                y1 = this.positionAbs.top,\r\n                y2 = y1 + this.helperProportions.height,\r\n                l = item.left,\r\n                r = l + item.width,\r\n                t = item.top,\r\n                b = t + item.height,\r\n                dyClick = this.offset.click.top,\r\n                dxClick = this.offset.click.left,\r\n                isOverElementHeight = (this.options.axis === &quot;x&quot;) || ((y1 + dyClick) &gt; t &amp;&amp;\r\n                    (y1 + dyClick) &lt; b),\r\n                isOverElementWidth = (this.options.axis === &quot;y&quot;) || ((x1 + dxClick) &gt; l &amp;&amp;\r\n                    (x1 + dxClick) &lt; r),\r\n                isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth;\r\n\r\n            if (this.options.tolerance === &quot;pointer&quot; ||\r\n                this.options.forcePointerForContainers ||\r\n                (this.options.tolerance !== &quot;pointer&quot; &amp;&amp;\r\n                    this.helperProportions[this.floating ? &quot;width&quot; : &quot;height&quot;] &gt;\r\n                    item[this.floating ? &quot;width&quot; : &quot;height&quot;])\r\n            ) {\r\n                return isOverElement;\r\n            } else {\r\n\r\n                return (l &lt; x1 + (this.helperProportions.width \/ 2) &amp;&amp; \/\/ Right Half\r\n                    x2 - (this.helperProportions.width \/ 2) &lt; r &amp;&amp; \/\/ Left Half\r\n                    t &lt; y1 + (this.helperProportions.height \/ 2) &amp;&amp; \/\/ Bottom Half\r\n                    y2 - (this.helperProportions.height \/ 2) &lt; b); \/\/ Top Half\r\n\r\n            }\r\n        },\r\n\r\n        _intersectsWithPointer: function(item) {\r\n            var verticalDirection, horizontalDirection,\r\n                isOverElementHeight = (this.options.axis === &quot;x&quot;) ||\r\n                this._isOverAxis(\r\n                    this.positionAbs.top + this.offset.click.top, item.top, item.height),\r\n                isOverElementWidth = (this.options.axis === &quot;y&quot;) ||\r\n                this._isOverAxis(\r\n                    this.positionAbs.left + this.offset.click.left, item.left, item.width),\r\n                isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth;\r\n\r\n            if (!isOverElement) {\r\n                return false;\r\n            }\r\n\r\n            verticalDirection = this.dragDirection.vertical;\r\n            horizontalDirection = this.dragDirection.horizontal;\r\n\r\n            return this.floating ?\r\n                ((horizontalDirection === &quot;right&quot; || verticalDirection === &quot;down&quot;) ? 2 : 1) :\r\n                (verticalDirection &amp;&amp; (verticalDirection === &quot;down&quot; ? 2 : 1));\r\n\r\n        },\r\n\r\n        _intersectsWithSides: function(item) {\r\n\r\n            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top +\r\n                    this.offset.click.top, item.top + (item.height \/ 2), item.height),\r\n                isOverRightHalf = this._isOverAxis(this.positionAbs.left +\r\n                    this.offset.click.left, item.left + (item.width \/ 2), item.width),\r\n                verticalDirection = this.dragDirection.vertical,\r\n                horizontalDirection = this.dragDirection.horizontal;\r\n\r\n            if (this.floating &amp;&amp; horizontalDirection) {\r\n                return ((horizontalDirection === &quot;right&quot; &amp;&amp; isOverRightHalf) ||\r\n                    (horizontalDirection === &quot;left&quot; &amp;&amp; !isOverRightHalf));\r\n            } else {\r\n                return verticalDirection &amp;&amp; ((verticalDirection === &quot;down&quot; &amp;&amp; isOverBottomHalf) ||\r\n                    (verticalDirection === &quot;up&quot; &amp;&amp; !isOverBottomHalf));\r\n            }\r\n\r\n        },\r\n\r\n        _getDragVerticalDirection: function() {\r\n            var delta = this.positionAbs.top - this.lastPositionAbs.top;\r\n            return delta !== 0 &amp;&amp; (delta &gt; 0 ? &quot;down&quot; : &quot;up&quot;);\r\n        },\r\n\r\n        _getDragHorizontalDirection: function() {\r\n            var delta = this.positionAbs.left - this.lastPositionAbs.left;\r\n            return delta !== 0 &amp;&amp; (delta &gt; 0 ? &quot;right&quot; : &quot;left&quot;);\r\n        },\r\n\r\n        refresh: function(event) {\r\n            this._refreshItems(event);\r\n            this._setHandleClassName();\r\n            this.refreshPositions();\r\n            return this;\r\n        },\r\n\r\n        _connectWith: function() {\r\n            var options = this.options;\r\n            return options.connectWith.constructor === String ? [options.connectWith] :\r\n                options.connectWith;\r\n        },\r\n\r\n        _getItemsAsjQuery: function(connected) {\r\n\r\n            var i, j, cur, inst,\r\n                items = [],\r\n                queries = [],\r\n                connectWith = this._connectWith();\r\n\r\n            if (connectWith &amp;&amp; connected) {\r\n                for (i = connectWith.length - 1; i &gt;= 0; i--) {\r\n                    cur = $(connectWith[i], this.document[0]);\r\n                    for (j = cur.length - 1; j &gt;= 0; j--) {\r\n                        inst = $.data(cur[j], this.widgetFullName);\r\n                        if (inst &amp;&amp; inst !== this &amp;&amp; !inst.options.disabled) {\r\n                            queries.push([typeof inst.options.items === &quot;function&quot; ?\r\n                                inst.options.items.call(inst.element) :\r\n                                $(inst.options.items, inst.element)\r\n                                .not(&quot;.ui-sortable-helper&quot;)\r\n                                .not(&quot;.ui-sortable-placeholder&quot;), inst\r\n                            ]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            queries.push([typeof this.options.items === &quot;function&quot; ?\r\n                this.options.items\r\n                .call(this.element, null, {\r\n                    options: this.options,\r\n                    item: this.currentItem\r\n                }) :\r\n                $(this.options.items, this.element)\r\n                .not(&quot;.ui-sortable-helper&quot;)\r\n                .not(&quot;.ui-sortable-placeholder&quot;), this\r\n            ]);\r\n\r\n            function addItems() {\r\n                items.push(this);\r\n            }\r\n            for (i = queries.length - 1; i &gt;= 0; i--) {\r\n                queries[i][0].each(addItems);\r\n            }\r\n\r\n            return $(items);\r\n\r\n        },\r\n\r\n        _removeCurrentsFromItems: function() {\r\n\r\n            var list = this.currentItem.find(&quot;:data(&quot; + this.widgetName + &quot;-item)&quot;);\r\n\r\n            this.items = $.grep(this.items, function(item) {\r\n                for (var j = 0; j &lt; list.length; j++) {\r\n                    if (list[j] === item.item[0]) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            });\r\n\r\n        },\r\n\r\n        _refreshItems: function(event) {\r\n\r\n            this.items = [];\r\n            this.containers = [this];\r\n\r\n            var i, j, cur, inst, targetData, _queries, item, queriesLength,\r\n                items = this.items,\r\n                queries = [\r\n                    [typeof this.options.items === &quot;function&quot; ?\r\n                        this.options.items.call(this.element[0], event, {\r\n                            item: this.currentItem\r\n                        }) :\r\n                        $(this.options.items, this.element), this\r\n                    ]\r\n                ],\r\n                connectWith = this._connectWith();\r\n\r\n            \/\/Shouldn&#039;t be run the first time through due to massive slow-down\r\n            if (connectWith &amp;&amp; this.ready) {\r\n                for (i = connectWith.length - 1; i &gt;= 0; i--) {\r\n                    cur = $(connectWith[i], this.document[0]);\r\n                    for (j = cur.length - 1; j &gt;= 0; j--) {\r\n                        inst = $.data(cur[j], this.widgetFullName);\r\n                        if (inst &amp;&amp; inst !== this &amp;&amp; !inst.options.disabled) {\r\n                            queries.push([typeof inst.options.items === &quot;function&quot; ?\r\n                                inst.options.items\r\n                                .call(inst.element[0], event, {\r\n                                    item: this.currentItem\r\n                                }) :\r\n                                $(inst.options.items, inst.element), inst\r\n                            ]);\r\n                            this.containers.push(inst);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (i = queries.length - 1; i &gt;= 0; i--) {\r\n                targetData = queries[i][1];\r\n                _queries = queries[i][0];\r\n\r\n                for (j = 0, queriesLength = _queries.length; j &lt; queriesLength; j++) {\r\n                    item = $(_queries[j]);\r\n\r\n                    \/\/ Data for target checking (mouse manager)\r\n                    item.data(this.widgetName + &quot;-item&quot;, targetData);\r\n\r\n                    items.push({\r\n                        item: item,\r\n                        instance: targetData,\r\n                        width: 0,\r\n                        height: 0,\r\n                        left: 0,\r\n                        top: 0\r\n                    });\r\n                }\r\n            }\r\n\r\n        },\r\n\r\n        _refreshItemPositions: function(fast) {\r\n            var i, item, t, p;\r\n\r\n            for (i = this.items.length - 1; i &gt;= 0; i--) {\r\n                item = this.items[i];\r\n\r\n                \/\/We ignore calculating positions of all connected containers when we&#039;re not over them\r\n                if (this.currentContainer &amp;&amp; item.instance !== this.currentContainer &amp;&amp;\r\n                    item.item[0] !== this.currentItem[0]) {\r\n                    continue;\r\n                }\r\n\r\n                t = this.options.toleranceElement ?\r\n                    $(this.options.toleranceElement, item.item) :\r\n                    item.item;\r\n\r\n                if (!fast) {\r\n                    item.width = t.outerWidth();\r\n                    item.height = t.outerHeight();\r\n                }\r\n\r\n                p = t.offset();\r\n                item.left = p.left;\r\n                item.top = p.top;\r\n            }\r\n        },\r\n\r\n        refreshPositions: function(fast) {\r\n\r\n            \/\/ Determine whether items are being displayed horizontally\r\n            this.floating = this.items.length ?\r\n                this.options.axis === &quot;x&quot; || this._isFloating(this.items[0].item) :\r\n                false;\r\n\r\n            \/\/ This has to be redone because due to the item being moved out\/into the offsetParent,\r\n            \/\/ the offsetParent&#039;s position will change\r\n            if (this.offsetParent &amp;&amp; this.helper) {\r\n                this.offset.parent = this._getParentOffset();\r\n            }\r\n\r\n            this._refreshItemPositions(fast);\r\n\r\n            var i, p;\r\n\r\n            if (this.options.custom &amp;&amp; this.options.custom.refreshContainers) {\r\n                this.options.custom.refreshContainers.call(this);\r\n            } else {\r\n                for (i = this.containers.length - 1; i &gt;= 0; i--) {\r\n                    p = this.containers[i].element.offset();\r\n                    this.containers[i].containerCache.left = p.left;\r\n                    this.containers[i].containerCache.top = p.top;\r\n                    this.containers[i].containerCache.width =\r\n                        this.containers[i].element.outerWidth();\r\n                    this.containers[i].containerCache.height =\r\n                        this.containers[i].element.outerHeight();\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        _createPlaceholder: function(that) {\r\n            that = that || this;\r\n            var className, nodeName,\r\n                o = that.options;\r\n\r\n            if (!o.placeholder || o.placeholder.constructor === String) {\r\n                className = o.placeholder;\r\n                nodeName = that.currentItem[0].nodeName.toLowerCase();\r\n                o.placeholder = {\r\n                    element: function() {\r\n\r\n                        var element = $(&quot;&lt;&quot; + nodeName + &quot;&gt;&quot;, that.document[0]);\r\n\r\n                        that._addClass(element, &quot;ui-sortable-placeholder&quot;,\r\n                                className || that.currentItem[0].className)\r\n                            ._removeClass(element, &quot;ui-sortable-helper&quot;);\r\n\r\n                        if (nodeName === &quot;tbody&quot;) {\r\n                            that._createTrPlaceholder(\r\n                                that.currentItem.find(&quot;tr&quot;).eq(0),\r\n                                $(&quot;&lt;tr&gt;&quot;, that.document[0]).appendTo(element)\r\n                            );\r\n                        } else if (nodeName === &quot;tr&quot;) {\r\n                            that._createTrPlaceholder(that.currentItem, element);\r\n                        } else if (nodeName === &quot;img&quot;) {\r\n                            element.attr(&quot;src&quot;, that.currentItem.attr(&quot;src&quot;));\r\n                        }\r\n\r\n                        if (!className) {\r\n                            element.css(&quot;visibility&quot;, &quot;hidden&quot;);\r\n                        }\r\n\r\n                        return element;\r\n                    },\r\n                    update: function(container, p) {\r\n\r\n                        \/\/ 1. If a className is set as &#039;placeholder option, we don&#039;t force sizes -\r\n                        \/\/ the class is responsible for that\r\n                        \/\/ 2. The option &#039;forcePlaceholderSize can be enabled to force it even if a\r\n                        \/\/ class name is specified\r\n                        if (className &amp;&amp; !o.forcePlaceholderSize) {\r\n                            return;\r\n                        }\r\n\r\n                        \/\/ If the element doesn&#039;t have a actual height or width by itself (without\r\n                        \/\/ styles coming from a stylesheet), it receives the inline height and width\r\n                        \/\/ from the dragged item. Or, if it&#039;s a tbody or tr, it&#039;s going to have a height\r\n                        \/\/ anyway since we&#039;re populating them with &lt;td&gt;s above, but they&#039;re unlikely to\r\n                        \/\/ be the correct height on their own if the row heights are dynamic, so we&#039;ll\r\n                        \/\/ always assign the height of the dragged item given forcePlaceholderSize\r\n                        \/\/ is true.\r\n                        if (!p.height() || (o.forcePlaceholderSize &amp;&amp;\r\n                                (nodeName === &quot;tbody&quot; || nodeName === &quot;tr&quot;))) {\r\n                            p.height(\r\n                                that.currentItem.innerHeight() -\r\n                                parseInt(that.currentItem.css(&quot;paddingTop&quot;) || 0, 10) -\r\n                                parseInt(that.currentItem.css(&quot;paddingBottom&quot;) || 0, 10));\r\n                        }\r\n                        if (!p.width()) {\r\n                            p.width(\r\n                                that.currentItem.innerWidth() -\r\n                                parseInt(that.currentItem.css(&quot;paddingLeft&quot;) || 0, 10) -\r\n                                parseInt(that.currentItem.css(&quot;paddingRight&quot;) || 0, 10));\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\r\n            \/\/Create the placeholder\r\n            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\r\n\r\n            \/\/Append it after the actual current item\r\n            that.currentItem.after(that.placeholder);\r\n\r\n            \/\/Update the size of the placeholder (TODO: Logic to fuzzy, see line 316\/317)\r\n            o.placeholder.update(that, that.placeholder);\r\n\r\n        },\r\n\r\n        _createTrPlaceholder: function(sourceTr, targetTr) {\r\n            var that = this;\r\n\r\n            sourceTr.children().each(function() {\r\n                $(&quot;&lt;td&gt;&amp;#160;&lt;\/td&gt;&quot;, that.document[0])\r\n                    .attr(&quot;colspan&quot;, $(this).attr(&quot;colspan&quot;) || 1)\r\n                    .appendTo(targetTr);\r\n            });\r\n        },\r\n\r\n        _contactContainers: function(event) {\r\n            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,\r\n                floating, axis,\r\n                innermostContainer = null,\r\n                innermostIndex = null;\r\n\r\n            \/\/ Get innermost container that intersects with item\r\n            for (i = this.containers.length - 1; i &gt;= 0; i--) {\r\n\r\n                \/\/ Never consider a container that&#039;s located within the item itself\r\n                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._intersectsWith(this.containers[i].containerCache)) {\r\n\r\n                    \/\/ If we&#039;ve already found a container and it&#039;s more &quot;inner&quot; than this, then continue\r\n                    if (innermostContainer &amp;&amp;\r\n                        $.contains(\r\n                            this.containers[i].element[0],\r\n                            innermostContainer.element[0])) {\r\n                        continue;\r\n                    }\r\n\r\n                    innermostContainer = this.containers[i];\r\n                    innermostIndex = i;\r\n\r\n                } else {\r\n\r\n                    \/\/ container doesn&#039;t intersect. trigger &quot;out&quot; event if necessary\r\n                    if (this.containers[i].containerCache.over) {\r\n                        this.containers[i]._trigger(&quot;out&quot;, event, this._uiHash(this));\r\n                        this.containers[i].containerCache.over = 0;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            \/\/ If no intersecting containers found, return\r\n            if (!innermostContainer) {\r\n                return;\r\n            }\r\n\r\n            \/\/ Move the item into the container if it&#039;s not there already\r\n            if (this.containers.length === 1) {\r\n                if (!this.containers[innermostIndex].containerCache.over) {\r\n                    this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));\r\n                    this.containers[innermostIndex].containerCache.over = 1;\r\n                }\r\n            } else {\r\n\r\n                \/\/ When entering a new container, we will find the item with the least distance and\r\n                \/\/ append our item near it\r\n                dist = 10000;\r\n                itemWithLeastDistance = null;\r\n                floating = innermostContainer.floating || this._isFloating(this.currentItem);\r\n                posProperty = floating ? &quot;left&quot; : &quot;top&quot;;\r\n                sizeProperty = floating ? &quot;width&quot; : &quot;height&quot;;\r\n                axis = floating ? &quot;pageX&quot; : &quot;pageY&quot;;\r\n\r\n                for (j = this.items.length - 1; j &gt;= 0; j--) {\r\n                    if (!$.contains(\r\n                            this.containers[innermostIndex].element[0], this.items[j].item[0])) {\r\n                        continue;\r\n                    }\r\n                    if (this.items[j].item[0] === this.currentItem[0]) {\r\n                        continue;\r\n                    }\r\n\r\n                    cur = this.items[j].item.offset()[posProperty];\r\n                    nearBottom = false;\r\n                    if (event[axis] - cur &gt; this.items[j][sizeProperty] \/ 2) {\r\n                        nearBottom = true;\r\n                    }\r\n\r\n                    if (Math.abs(event[axis] - cur) &lt; dist) {\r\n                        dist = Math.abs(event[axis] - cur);\r\n                        itemWithLeastDistance = this.items[j];\r\n                        this.direction = nearBottom ? &quot;up&quot; : &quot;down&quot;;\r\n                    }\r\n                }\r\n\r\n                \/\/Check if dropOnEmpty is enabled\r\n                if (!itemWithLeastDistance &amp;&amp; !this.options.dropOnEmpty) {\r\n                    return;\r\n                }\r\n\r\n                if (this.currentContainer === this.containers[innermostIndex]) {\r\n                    if (!this.currentContainer.containerCache.over) {\r\n                        this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash());\r\n                        this.currentContainer.containerCache.over = 1;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (itemWithLeastDistance) {\r\n                    this._rearrange(event, itemWithLeastDistance, null, true);\r\n                } else {\r\n                    this._rearrange(event, null, this.containers[innermostIndex].element, true);\r\n                }\r\n                this._trigger(&quot;change&quot;, event, this._uiHash());\r\n                this.containers[innermostIndex]._trigger(&quot;change&quot;, event, this._uiHash(this));\r\n                this.currentContainer = this.containers[innermostIndex];\r\n\r\n                \/\/Update the placeholder\r\n                this.options.placeholder.update(this.currentContainer, this.placeholder);\r\n\r\n                \/\/Update scrollParent\r\n                this.scrollParent = this.placeholder.scrollParent();\r\n\r\n                \/\/Update overflowOffset\r\n                if (this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                    this.scrollParent[0].tagName !== &quot;HTML&quot;) {\r\n                    this.overflowOffset = this.scrollParent.offset();\r\n                }\r\n\r\n                this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));\r\n                this.containers[innermostIndex].containerCache.over = 1;\r\n            }\r\n\r\n        },\r\n\r\n        _createHelper: function(event) {\r\n\r\n            var o = this.options,\r\n                helper = typeof o.helper === &quot;function&quot; ?\r\n                $(o.helper.apply(this.element[0], [event, this.currentItem])) :\r\n                (o.helper === &quot;clone&quot; ? this.currentItem.clone() : this.currentItem);\r\n\r\n            \/\/Add the helper to the DOM if that didn&#039;t happen already\r\n            if (!helper.parents(&quot;body&quot;).length) {\r\n                this.appendTo[0].appendChild(helper[0]);\r\n            }\r\n\r\n            if (helper[0] === this.currentItem[0]) {\r\n                this._storedCSS = {\r\n                    width: this.currentItem[0].style.width,\r\n                    height: this.currentItem[0].style.height,\r\n                    position: this.currentItem.css(&quot;position&quot;),\r\n                    top: this.currentItem.css(&quot;top&quot;),\r\n                    left: this.currentItem.css(&quot;left&quot;)\r\n                };\r\n            }\r\n\r\n            if (!helper[0].style.width || o.forceHelperSize) {\r\n                helper.width(this.currentItem.width());\r\n            }\r\n            if (!helper[0].style.height || o.forceHelperSize) {\r\n                helper.height(this.currentItem.height());\r\n            }\r\n\r\n            return helper;\r\n\r\n        },\r\n\r\n        _adjustOffsetFromHelper: function(obj) {\r\n            if (typeof obj === &quot;string&quot;) {\r\n                obj = obj.split(&quot; &quot;);\r\n            }\r\n            if (Array.isArray(obj)) {\r\n                obj = {\r\n                    left: +obj[0],\r\n                    top: +obj[1] || 0\r\n                };\r\n            }\r\n            if (&quot;left&quot; in obj) {\r\n                this.offset.click.left = obj.left + this.margins.left;\r\n            }\r\n            if (&quot;right&quot; in obj) {\r\n                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\r\n            }\r\n            if (&quot;top&quot; in obj) {\r\n                this.offset.click.top = obj.top + this.margins.top;\r\n            }\r\n            if (&quot;bottom&quot; in obj) {\r\n                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\r\n            }\r\n        },\r\n\r\n        _getParentOffset: function() {\r\n\r\n            \/\/Get the offsetParent and cache its position\r\n            this.offsetParent = this.helper.offsetParent();\r\n            var po = this.offsetParent.offset();\r\n\r\n            \/\/ This is a special case where we need to modify a offset calculated on start, since the\r\n            \/\/ following happened:\r\n            \/\/ 1. The position of the helper is absolute, so it&#039;s position is calculated based on the\r\n            \/\/ next positioned parent\r\n            \/\/ 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#039;t\r\n            \/\/ the document, which means that the scroll is included in the initial calculation of the\r\n            \/\/ offset of the parent, and never recalculated upon drag\r\n            if (this.cssPosition === &quot;absolute&quot; &amp;&amp; this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                $.contains(this.scrollParent[0], this.offsetParent[0])) {\r\n                po.left += this.scrollParent.scrollLeft();\r\n                po.top += this.scrollParent.scrollTop();\r\n            }\r\n\r\n            \/\/ This needs to be actually done for all browsers, since pageX\/pageY includes\r\n            \/\/ this information.\r\n            if (this.offsetParent[0] === this.document[0].body) {\r\n                po = {\r\n                    top: 0,\r\n                    left: 0\r\n                };\r\n            }\r\n\r\n            return {\r\n                top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;), 10) || 0),\r\n                left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;), 10) || 0)\r\n            };\r\n\r\n        },\r\n\r\n        _getRelativeOffset: function() {\r\n\r\n            if (this.cssPosition === &quot;relative&quot;) {\r\n                var p = this.currentItem.position();\r\n                return {\r\n                    top: p.top - (parseInt(this.helper.css(&quot;top&quot;), 10) || 0) +\r\n                        this.scrollParent.scrollTop(),\r\n                    left: p.left - (parseInt(this.helper.css(&quot;left&quot;), 10) || 0) +\r\n                        this.scrollParent.scrollLeft()\r\n                };\r\n            } else {\r\n                return {\r\n                    top: 0,\r\n                    left: 0\r\n                };\r\n            }\r\n\r\n        },\r\n\r\n        _cacheMargins: function() {\r\n            this.margins = {\r\n                left: (parseInt(this.currentItem.css(&quot;marginLeft&quot;), 10) || 0),\r\n                top: (parseInt(this.currentItem.css(&quot;marginTop&quot;), 10) || 0)\r\n            };\r\n        },\r\n\r\n        _cacheHelperProportions: function() {\r\n            this.helperProportions = {\r\n                width: this.helper.outerWidth(),\r\n                height: this.helper.outerHeight()\r\n            };\r\n        },\r\n\r\n        _setContainment: function() {\r\n\r\n            var ce, co, over,\r\n                o = this.options;\r\n            if (o.containment === &quot;parent&quot;) {\r\n                o.containment = this.helper[0].parentNode;\r\n            }\r\n            if (o.containment === &quot;document&quot; || o.containment === &quot;window&quot;) {\r\n                this.containment = [\r\n                    0 - this.offset.relative.left - this.offset.parent.left,\r\n                    0 - this.offset.relative.top - this.offset.parent.top,\r\n                    o.containment === &quot;document&quot; ?\r\n                    this.document.width() :\r\n                    this.window.width() - this.helperProportions.width - this.margins.left,\r\n                    (o.containment === &quot;document&quot; ?\r\n                        (this.document.height() || document.body.parentNode.scrollHeight) :\r\n                        this.window.height() || this.document[0].body.parentNode.scrollHeight\r\n                    ) - this.helperProportions.height - this.margins.top\r\n                ];\r\n            }\r\n\r\n            if (!(\/^(document|window|parent)$\/).test(o.containment)) {\r\n                ce = $(o.containment)[0];\r\n                co = $(o.containment).offset();\r\n                over = ($(ce).css(&quot;overflow&quot;) !== &quot;hidden&quot;);\r\n\r\n                this.containment = [\r\n                    co.left + (parseInt($(ce).css(&quot;borderLeftWidth&quot;), 10) || 0) +\r\n                    (parseInt($(ce).css(&quot;paddingLeft&quot;), 10) || 0) - this.margins.left,\r\n                    co.top + (parseInt($(ce).css(&quot;borderTopWidth&quot;), 10) || 0) +\r\n                    (parseInt($(ce).css(&quot;paddingTop&quot;), 10) || 0) - this.margins.top,\r\n                    co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -\r\n                    (parseInt($(ce).css(&quot;borderLeftWidth&quot;), 10) || 0) -\r\n                    (parseInt($(ce).css(&quot;paddingRight&quot;), 10) || 0) -\r\n                    this.helperProportions.width - this.margins.left,\r\n                    co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -\r\n                    (parseInt($(ce).css(&quot;borderTopWidth&quot;), 10) || 0) -\r\n                    (parseInt($(ce).css(&quot;paddingBottom&quot;), 10) || 0) -\r\n                    this.helperProportions.height - this.margins.top\r\n                ];\r\n            }\r\n\r\n        },\r\n\r\n        _convertPositionTo: function(d, pos) {\r\n\r\n            if (!pos) {\r\n                pos = this.position;\r\n            }\r\n            var mod = d === &quot;absolute&quot; ? 1 : -1,\r\n                scroll = this.cssPosition === &quot;absolute&quot; &amp;&amp;\r\n                !(this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                    $.contains(this.scrollParent[0], this.offsetParent[0])) ?\r\n                this.offsetParent :\r\n                this.scrollParent,\r\n                scrollIsRootNode = (\/(html|body)\/i).test(scroll[0].tagName);\r\n\r\n            return {\r\n                top: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pos.top +\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.top * mod +\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.top * mod -\r\n                    ((this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.scrollParent.scrollTop() :\r\n                        (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)\r\n                ),\r\n                left: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pos.left +\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.left * mod +\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.left * mod -\r\n                    ((this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :\r\n                        scroll.scrollLeft()) * mod)\r\n                )\r\n            };\r\n\r\n        },\r\n\r\n        _generatePosition: function(event) {\r\n\r\n            var top, left,\r\n                o = this.options,\r\n                pageX = event.pageX,\r\n                pageY = event.pageY,\r\n                scroll = this.cssPosition === &quot;absolute&quot; &amp;&amp;\r\n                !(this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                    $.contains(this.scrollParent[0], this.offsetParent[0])) ?\r\n                this.offsetParent :\r\n                this.scrollParent,\r\n                scrollIsRootNode = (\/(html|body)\/i).test(scroll[0].tagName);\r\n\r\n            \/\/ This is another very weird special case that only happens for relative elements:\r\n            \/\/ 1. If the css position is relative\r\n            \/\/ 2. and the scroll parent is the document or similar to the offset parent\r\n            \/\/ we have to refresh the relative offset during the scroll so there are no jumps\r\n            if (this.cssPosition === &quot;relative&quot; &amp;&amp; !(this.scrollParent[0] !== this.document[0] &amp;&amp;\r\n                    this.scrollParent[0] !== this.offsetParent[0])) {\r\n                this.offset.relative = this._getRelativeOffset();\r\n            }\r\n\r\n            \/*\r\n             * - Position constraining -\r\n             * Constrain the position to a mix of grid, containment.\r\n             *\/\r\n\r\n            if (this.originalPosition) { \/\/If we are not dragging yet, we won&#039;t check for options\r\n\r\n                if (this.containment) {\r\n                    if (event.pageX - this.offset.click.left &lt; this.containment[0]) {\r\n                        pageX = this.containment[0] + this.offset.click.left;\r\n                    }\r\n                    if (event.pageY - this.offset.click.top &lt; this.containment[1]) {\r\n                        pageY = this.containment[1] + this.offset.click.top;\r\n                    }\r\n                    if (event.pageX - this.offset.click.left &gt; this.containment[2]) {\r\n                        pageX = this.containment[2] + this.offset.click.left;\r\n                    }\r\n                    if (event.pageY - this.offset.click.top &gt; this.containment[3]) {\r\n                        pageY = this.containment[3] + this.offset.click.top;\r\n                    }\r\n                }\r\n\r\n                if (o.grid) {\r\n                    top = this.originalPageY + Math.round((pageY - this.originalPageY) \/\r\n                        o.grid[1]) * o.grid[1];\r\n                    pageY = this.containment ?\r\n                        ((top - this.offset.click.top &gt;= this.containment[1] &amp;&amp;\r\n                                top - this.offset.click.top &lt;= this.containment[3]) ?\r\n                            top :\r\n                            ((top - this.offset.click.top &gt;= this.containment[1]) ?\r\n                                top - o.grid[1] : top + o.grid[1])) :\r\n                        top;\r\n\r\n                    left = this.originalPageX + Math.round((pageX - this.originalPageX) \/\r\n                        o.grid[0]) * o.grid[0];\r\n                    pageX = this.containment ?\r\n                        ((left - this.offset.click.left &gt;= this.containment[0] &amp;&amp;\r\n                                left - this.offset.click.left &lt;= this.containment[2]) ?\r\n                            left :\r\n                            ((left - this.offset.click.left &gt;= this.containment[0]) ?\r\n                                left - o.grid[0] : left + o.grid[0])) :\r\n                        left;\r\n                }\r\n\r\n            }\r\n\r\n            return {\r\n                top: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pageY -\r\n\r\n                    \/\/ Click offset (relative to the element)\r\n                    this.offset.click.top -\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.top -\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.top +\r\n                    ((this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.scrollParent.scrollTop() :\r\n                        (scrollIsRootNode ? 0 : scroll.scrollTop())))\r\n                ),\r\n                left: (\r\n\r\n                    \/\/ The absolute mouse position\r\n                    pageX -\r\n\r\n                    \/\/ Click offset (relative to the element)\r\n                    this.offset.click.left -\r\n\r\n                    \/\/ Only for relative positioned nodes: Relative offset from element to offset parent\r\n                    this.offset.relative.left -\r\n\r\n                    \/\/ The offsetParent&#039;s offset without borders (offset + border)\r\n                    this.offset.parent.left +\r\n                    ((this.cssPosition === &quot;fixed&quot; ?\r\n                        -this.scrollParent.scrollLeft() :\r\n                        scrollIsRootNode ? 0 : scroll.scrollLeft()))\r\n                )\r\n            };\r\n\r\n        },\r\n\r\n        _rearrange: function(event, i, a, hardRefresh) {\r\n\r\n            if (a) {\r\n                a[0].appendChild(this.placeholder[0]);\r\n            } else {\r\n                i.item[0].parentNode.insertBefore(this.placeholder[0],\r\n                    (this.direction === &quot;down&quot; ? i.item[0] : i.item[0].nextSibling));\r\n            }\r\n\r\n            \/\/Various things done here to improve the performance:\r\n            \/\/ 1. we create a setTimeout, that calls refreshPositions\r\n            \/\/ 2. on the instance, we have a counter variable, that get&#039;s higher after every append\r\n            \/\/ 3. on the local scope, we copy the counter variable, and check in the timeout,\r\n            \/\/ if it&#039;s still the same\r\n            \/\/ 4. this lets only the last addition to the timeout stack through\r\n            this.counter = this.counter ? ++this.counter : 1;\r\n            var counter = this.counter;\r\n\r\n            this._delay(function() {\r\n                if (counter === this.counter) {\r\n\r\n                    \/\/Precompute after each DOM insertion, NOT on mousemove\r\n                    this.refreshPositions(!hardRefresh);\r\n                }\r\n            });\r\n\r\n        },\r\n\r\n        _clear: function(event, noPropagation) {\r\n\r\n            this.reverting = false;\r\n\r\n            \/\/ We delay all events that have to be triggered to after the point where the placeholder\r\n            \/\/ has been removed and everything else normalized again\r\n            var i,\r\n                delayedTriggers = [];\r\n\r\n            \/\/ We first have to update the dom position of the actual currentItem\r\n            \/\/ Note: don&#039;t do it if the current item is already removed (by a user), or it gets\r\n            \/\/ reappended (see #4088)\r\n            if (!this._noFinalSort &amp;&amp; this.currentItem.parent().length) {\r\n                this.placeholder.before(this.currentItem);\r\n            }\r\n            this._noFinalSort = null;\r\n\r\n            if (this.helper[0] === this.currentItem[0]) {\r\n                for (i in this._storedCSS) {\r\n                    if (this._storedCSS[i] === &quot;auto&quot; || this._storedCSS[i] === &quot;static&quot;) {\r\n                        this._storedCSS[i] = &quot;&quot;;\r\n                    }\r\n                }\r\n                this.currentItem.css(this._storedCSS);\r\n                this._removeClass(this.currentItem, &quot;ui-sortable-helper&quot;);\r\n            } else {\r\n                this.currentItem.show();\r\n            }\r\n\r\n            if (this.fromOutside &amp;&amp; !noPropagation) {\r\n                delayedTriggers.push(function(event) {\r\n                    this._trigger(&quot;receive&quot;, event, this._uiHash(this.fromOutside));\r\n                });\r\n            }\r\n            if ((this.fromOutside ||\r\n                    this.domPosition.prev !==\r\n                    this.currentItem.prev().not(&quot;.ui-sortable-helper&quot;)[0] ||\r\n                    this.domPosition.parent !== this.currentItem.parent()[0]) &amp;&amp; !noPropagation) {\r\n\r\n                \/\/ Trigger update callback if the DOM position has changed\r\n                delayedTriggers.push(function(event) {\r\n                    this._trigger(&quot;update&quot;, event, this._uiHash());\r\n                });\r\n            }\r\n\r\n            \/\/ Check if the items Container has Changed and trigger appropriate\r\n            \/\/ events.\r\n            if (this !== this.currentContainer) {\r\n                if (!noPropagation) {\r\n                    delayedTriggers.push(function(event) {\r\n                        this._trigger(&quot;remove&quot;, event, this._uiHash());\r\n                    });\r\n                    delayedTriggers.push((function(c) {\r\n                        return function(event) {\r\n                            c._trigger(&quot;receive&quot;, event, this._uiHash(this));\r\n                        };\r\n                    }).call(this, this.currentContainer));\r\n                    delayedTriggers.push((function(c) {\r\n                        return function(event) {\r\n                            c._trigger(&quot;update&quot;, event, this._uiHash(this));\r\n                        };\r\n                    }).call(this, this.currentContainer));\r\n                }\r\n            }\r\n\r\n            \/\/Post events to containers\r\n            function delayEvent(type, instance, container) {\r\n                return function(event) {\r\n                    container._trigger(type, event, instance._uiHash(instance));\r\n                };\r\n            }\r\n            for (i = this.containers.length - 1; i &gt;= 0; i--) {\r\n                if (!noPropagation) {\r\n                    delayedTriggers.push(delayEvent(&quot;deactivate&quot;, this, this.containers[i]));\r\n                }\r\n                if (this.containers[i].containerCache.over) {\r\n                    delayedTriggers.push(delayEvent(&quot;out&quot;, this, this.containers[i]));\r\n                    this.containers[i].containerCache.over = 0;\r\n                }\r\n            }\r\n\r\n            \/\/Do what was originally in plugins\r\n            if (this._storedStylesheet) {\r\n                this._storedStylesheet.remove();\r\n                this._storedStylesheet = null;\r\n            }\r\n            if (this._storedOpacity) {\r\n                this.helper.css(&quot;opacity&quot;, this._storedOpacity);\r\n            }\r\n            if (this._storedZIndex) {\r\n                this.helper.css(&quot;zIndex&quot;, this._storedZIndex === &quot;auto&quot; ? &quot;&quot; : this._storedZIndex);\r\n            }\r\n\r\n            this.dragging = false;\r\n\r\n            if (!noPropagation) {\r\n                this._trigger(&quot;beforeStop&quot;, event, this._uiHash());\r\n            }\r\n\r\n            \/\/$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,\r\n            \/\/ it unbinds ALL events from the original node!\r\n            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\r\n\r\n            if (!this.cancelHelperRemoval) {\r\n                if (this.helper[0] !== this.currentItem[0]) {\r\n                    this.helper.remove();\r\n                }\r\n                this.helper = null;\r\n            }\r\n\r\n            if (!noPropagation) {\r\n                for (i = 0; i &lt; delayedTriggers.length; i++) {\r\n\r\n                    \/\/ Trigger all delayed events\r\n                    delayedTriggers[i].call(this, event);\r\n                }\r\n                this._trigger(&quot;stop&quot;, event, this._uiHash());\r\n            }\r\n\r\n            this.fromOutside = false;\r\n            return !this.cancelHelperRemoval;\r\n\r\n        },\r\n\r\n        _trigger: function() {\r\n            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\r\n                this.cancel();\r\n            }\r\n        },\r\n\r\n        _uiHash: function(_inst) {\r\n            var inst = _inst || this;\r\n            return {\r\n                helper: inst.helper,\r\n                placeholder: inst.placeholder || $([]),\r\n                position: inst.position,\r\n                originalPosition: inst.originalPosition,\r\n                offset: inst.positionAbs,\r\n                item: inst.currentItem,\r\n                sender: _inst ? _inst.element : null\r\n            };\r\n        }\r\n\r\n    });\r\n\r\n\r\n\r\n    \/\/ Create a local jQuery because jQuery Color relies on it and the\r\n    \/\/ global may not exist with AMD and a custom build (#10199).\r\n    \/\/ This module is a noop if used as a regular AMD module.\r\n    \/\/ eslint-disable-next-line no-unused-vars\r\n    var jQuery = $;\r\n\r\n\r\n    \/*!\r\n     * jQuery Color Animations v3.0.0\r\n     * https:\/\/github.com\/jquery\/jquery-color\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\r\n     * Date: Wed May 15 16:49:44 2024 +0200\r\n     *\/\r\n\r\n\r\n    var stepHooks = &quot;backgroundColor borderBottomColor borderLeftColor borderRightColor &quot; +\r\n        &quot;borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor&quot;,\r\n\r\n        class2type = {},\r\n        toString = class2type.toString,\r\n\r\n        \/\/ plusequals test for += 100 -= 100\r\n        rplusequals = \/^([\\-+])=\\s*(\\d+\\.?\\d*)\/,\r\n\r\n        \/\/ a set of RE&#039;s that can match strings and generate color tuples.\r\n        stringParsers = [{\r\n            re: \/rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)\/,\r\n            parse: function(execResult) {\r\n                return [\r\n                    execResult[1],\r\n                    execResult[2],\r\n                    execResult[3],\r\n                    execResult[4]\r\n                ];\r\n            }\r\n        }, {\r\n            re: \/rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)\/,\r\n            parse: function(execResult) {\r\n                return [\r\n                    execResult[1] * 2.55,\r\n                    execResult[2] * 2.55,\r\n                    execResult[3] * 2.55,\r\n                    execResult[4]\r\n                ];\r\n            }\r\n        }, {\r\n\r\n            \/\/ this regex ignores A-F because it&#039;s compared against an already lowercased string\r\n            re: \/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?\/,\r\n            parse: function(execResult) {\r\n                return [\r\n                    parseInt(execResult[1], 16),\r\n                    parseInt(execResult[2], 16),\r\n                    parseInt(execResult[3], 16),\r\n                    execResult[4] ?\r\n                    (parseInt(execResult[4], 16) \/ 255).toFixed(2) :\r\n                    1\r\n                ];\r\n            }\r\n        }, {\r\n\r\n            \/\/ this regex ignores A-F because it&#039;s compared against an already lowercased string\r\n            re: \/#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?\/,\r\n            parse: function(execResult) {\r\n                return [\r\n                    parseInt(execResult[1] + execResult[1], 16),\r\n                    parseInt(execResult[2] + execResult[2], 16),\r\n                    parseInt(execResult[3] + execResult[3], 16),\r\n                    execResult[4] ?\r\n                    (parseInt(execResult[4] + execResult[4], 16) \/ 255)\r\n                    .toFixed(2) :\r\n                    1\r\n                ];\r\n            }\r\n        }, {\r\n            re: \/hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)\/,\r\n            space: &quot;hsla&quot;,\r\n            parse: function(execResult) {\r\n                return [\r\n                    execResult[1],\r\n                    execResult[2] \/ 100,\r\n                    execResult[3] \/ 100,\r\n                    execResult[4]\r\n                ];\r\n            }\r\n        }],\r\n\r\n        \/\/ jQuery.Color( )\r\n        color = jQuery.Color = function(color, green, blue, alpha) {\r\n            return new jQuery.Color.fn.parse(color, green, blue, alpha);\r\n        },\r\n        spaces = {\r\n            rgba: {\r\n                props: {\r\n                    red: {\r\n                        idx: 0,\r\n                        type: &quot;byte&quot;\r\n                    },\r\n                    green: {\r\n                        idx: 1,\r\n                        type: &quot;byte&quot;\r\n                    },\r\n                    blue: {\r\n                        idx: 2,\r\n                        type: &quot;byte&quot;\r\n                    }\r\n                }\r\n            },\r\n\r\n            hsla: {\r\n                props: {\r\n                    hue: {\r\n                        idx: 0,\r\n                        type: &quot;degrees&quot;\r\n                    },\r\n                    saturation: {\r\n                        idx: 1,\r\n                        type: &quot;percent&quot;\r\n                    },\r\n                    lightness: {\r\n                        idx: 2,\r\n                        type: &quot;percent&quot;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        propTypes = {\r\n            &quot;byte&quot;: {\r\n                floor: true,\r\n                max: 255\r\n            },\r\n            &quot;percent&quot;: {\r\n                max: 1\r\n            },\r\n            &quot;degrees&quot;: {\r\n                mod: 360,\r\n                floor: true\r\n            }\r\n        },\r\n\r\n        \/\/ colors = jQuery.Color.names\r\n        colors,\r\n\r\n        \/\/ local aliases of functions called often\r\n        each = jQuery.each;\r\n\r\n    \/\/ define cache name and alpha properties\r\n    \/\/ for rgba and hsla spaces\r\n    each(spaces, function(spaceName, space) {\r\n        space.cache = &quot;_&quot; + spaceName;\r\n        space.props.alpha = {\r\n            idx: 3,\r\n            type: &quot;percent&quot;,\r\n            def: 1\r\n        };\r\n    });\r\n\r\n    \/\/ Populate the class2type map\r\n    jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;.split(&quot; &quot;),\r\n        function(_i, name) {\r\n            class2type[&quot;[object &quot; + name + &quot;]&quot;] = name.toLowerCase();\r\n        });\r\n\r\n    function getType(obj) {\r\n        if (obj == null) {\r\n            return obj + &quot;&quot;;\r\n        }\r\n\r\n        return typeof obj === &quot;object&quot; ?\r\n            class2type[toString.call(obj)] || &quot;object&quot; :\r\n            typeof obj;\r\n    }\r\n\r\n    function clamp(value, prop, allowEmpty) {\r\n        var type = propTypes[prop.type] || {};\r\n\r\n        if (value == null) {\r\n            return (allowEmpty || !prop.def) ? null : prop.def;\r\n        }\r\n\r\n        \/\/ ~~ is an short way of doing floor for positive numbers\r\n        value = type.floor ? ~~value : parseFloat(value);\r\n\r\n        if (type.mod) {\r\n\r\n            \/\/ we add mod before modding to make sure that negatives values\r\n            \/\/ get converted properly: -10 -&gt; 350\r\n            return (value + type.mod) % type.mod;\r\n        }\r\n\r\n        \/\/ for now all property types without mod have min and max\r\n        return Math.min(type.max, Math.max(0, value));\r\n    }\r\n\r\n    function stringParse(string) {\r\n        var inst = color(),\r\n            rgba = inst._rgba = [];\r\n\r\n        string = string.toLowerCase();\r\n\r\n        each(stringParsers, function(_i, parser) {\r\n            var parsed,\r\n                match = parser.re.exec(string),\r\n                values = match &amp;&amp; parser.parse(match),\r\n                spaceName = parser.space || &quot;rgba&quot;;\r\n\r\n            if (values) {\r\n                parsed = inst[spaceName](values);\r\n\r\n                \/\/ if this was an rgba parse the assignment might happen twice\r\n                \/\/ oh well....\r\n                inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];\r\n                rgba = inst._rgba = parsed._rgba;\r\n\r\n                \/\/ exit each( stringParsers ) here because we matched\r\n                return false;\r\n            }\r\n        });\r\n\r\n        \/\/ Found a stringParser that handled it\r\n        if (rgba.length) {\r\n\r\n            \/\/ if this came from a parsed string, force &quot;transparent&quot; when alpha is 0\r\n            \/\/ chrome, (and maybe others) return &quot;transparent&quot; as rgba(0,0,0,0)\r\n            if (rgba.join() === &quot;0,0,0,0&quot;) {\r\n                jQuery.extend(rgba, colors.transparent);\r\n            }\r\n            return inst;\r\n        }\r\n\r\n        \/\/ named colors\r\n        return colors[string];\r\n    }\r\n\r\n    color.fn = jQuery.extend(color.prototype, {\r\n        parse: function(red, green, blue, alpha) {\r\n            if (red === undefined) {\r\n                this._rgba = [null, null, null, null];\r\n                return this;\r\n            }\r\n            if (red.jquery || red.nodeType) {\r\n                red = jQuery(red).css(green);\r\n                green = undefined;\r\n            }\r\n\r\n            var inst = this,\r\n                type = getType(red),\r\n                rgba = this._rgba = [];\r\n\r\n            \/\/ more than 1 argument specified - assume ( red, green, blue, alpha )\r\n            if (green !== undefined) {\r\n                red = [red, green, blue, alpha];\r\n                type = &quot;array&quot;;\r\n            }\r\n\r\n            if (type === &quot;string&quot;) {\r\n                return this.parse(stringParse(red) || colors._default);\r\n            }\r\n\r\n            if (type === &quot;array&quot;) {\r\n                each(spaces.rgba.props, function(_key, prop) {\r\n                    rgba[prop.idx] = clamp(red[prop.idx], prop);\r\n                });\r\n                return this;\r\n            }\r\n\r\n            if (type === &quot;object&quot;) {\r\n                if (red instanceof color) {\r\n                    each(spaces, function(_spaceName, space) {\r\n                        if (red[space.cache]) {\r\n                            inst[space.cache] = red[space.cache].slice();\r\n                        }\r\n                    });\r\n                } else {\r\n                    each(spaces, function(_spaceName, space) {\r\n                        var cache = space.cache;\r\n                        each(space.props, function(key, prop) {\r\n\r\n                            \/\/ if the cache doesn&#039;t exist, and we know how to convert\r\n                            if (!inst[cache] &amp;&amp; space.to) {\r\n\r\n                                \/\/ if the value was null, we don&#039;t need to copy it\r\n                                \/\/ if the key was alpha, we don&#039;t need to copy it either\r\n                                if (key === &quot;alpha&quot; || red[key] == null) {\r\n                                    return;\r\n                                }\r\n                                inst[cache] = space.to(inst._rgba);\r\n                            }\r\n\r\n                            \/\/ this is the only case where we allow nulls for ALL properties.\r\n                            \/\/ call clamp with alwaysAllowEmpty\r\n                            inst[cache][prop.idx] = clamp(red[key], prop, true);\r\n                        });\r\n\r\n                        \/\/ everything defined but alpha?\r\n                        if (inst[cache] &amp;&amp; jQuery.inArray(\r\n                                null,\r\n                                inst[cache].slice(0, 3)\r\n                            ) &lt; 0) {\r\n\r\n                            \/\/ use the default of 1\r\n                            if (inst[cache][3] == null) {\r\n                                inst[cache][3] = 1;\r\n                            }\r\n\r\n                            if (space.from) {\r\n                                inst._rgba = space.from(inst[cache]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                return this;\r\n            }\r\n        },\r\n        is: function(compare) {\r\n            var is = color(compare),\r\n                same = true,\r\n                inst = this;\r\n\r\n            each(spaces, function(_, space) {\r\n                var localCache,\r\n                    isCache = is[space.cache];\r\n                if (isCache) {\r\n                    localCache = inst[space.cache] || space.to &amp;&amp; space.to(inst._rgba) || [];\r\n                    each(space.props, function(_, prop) {\r\n                        if (isCache[prop.idx] != null) {\r\n                            same = (isCache[prop.idx] === localCache[prop.idx]);\r\n                            return same;\r\n                        }\r\n                    });\r\n                }\r\n                return same;\r\n            });\r\n            return same;\r\n        },\r\n        _space: function() {\r\n            var used = [],\r\n                inst = this;\r\n            each(spaces, function(spaceName, space) {\r\n                if (inst[space.cache]) {\r\n                    used.push(spaceName);\r\n                }\r\n            });\r\n            return used.pop();\r\n        },\r\n        transition: function(other, distance) {\r\n            var end = color(other),\r\n                spaceName = end._space(),\r\n                space = spaces[spaceName],\r\n                startColor = this.alpha() === 0 ? color(&quot;transparent&quot;) : this,\r\n                start = startColor[space.cache] || space.to(startColor._rgba),\r\n                result = start.slice();\r\n\r\n            end = end[space.cache];\r\n            each(space.props, function(_key, prop) {\r\n                var index = prop.idx,\r\n                    startValue = start[index],\r\n                    endValue = end[index],\r\n                    type = propTypes[prop.type] || {};\r\n\r\n                \/\/ if null, don&#039;t override start value\r\n                if (endValue === null) {\r\n                    return;\r\n                }\r\n\r\n                \/\/ if null - use end\r\n                if (startValue === null) {\r\n                    result[index] = endValue;\r\n                } else {\r\n                    if (type.mod) {\r\n                        if (endValue - startValue &gt; type.mod \/ 2) {\r\n                            startValue += type.mod;\r\n                        } else if (startValue - endValue &gt; type.mod \/ 2) {\r\n                            startValue -= type.mod;\r\n                        }\r\n                    }\r\n                    result[index] = clamp((endValue - startValue) * distance + startValue, prop);\r\n                }\r\n            });\r\n            return this[spaceName](result);\r\n        },\r\n        blend: function(opaque) {\r\n\r\n            \/\/ if we are already opaque - return ourself\r\n            if (this._rgba[3] === 1) {\r\n                return this;\r\n            }\r\n\r\n            var rgb = this._rgba.slice(),\r\n                a = rgb.pop(),\r\n                blend = color(opaque)._rgba;\r\n\r\n            return color(jQuery.map(rgb, function(v, i) {\r\n                return (1 - a) * blend[i] + a * v;\r\n            }));\r\n        },\r\n        toRgbaString: function() {\r\n            var prefix = &quot;rgba(&quot;,\r\n                rgba = jQuery.map(this._rgba, function(v, i) {\r\n                    if (v != null) {\r\n                        return v;\r\n                    }\r\n                    return i &gt; 2 ? 1 : 0;\r\n                });\r\n\r\n            if (rgba[3] === 1) {\r\n                rgba.pop();\r\n                prefix = &quot;rgb(&quot;;\r\n            }\r\n\r\n            return prefix + rgba.join(&quot;, &quot;) + &quot;)&quot;;\r\n        },\r\n        toHslaString: function() {\r\n            var prefix = &quot;hsla(&quot;,\r\n                hsla = jQuery.map(this.hsla(), function(v, i) {\r\n                    if (v == null) {\r\n                        v = i &gt; 2 ? 1 : 0;\r\n                    }\r\n\r\n                    \/\/ catch 1 and 2\r\n                    if (i &amp;&amp; i &lt; 3) {\r\n                        v = Math.round(v * 100) + &quot;%&quot;;\r\n                    }\r\n                    return v;\r\n                });\r\n\r\n            if (hsla[3] === 1) {\r\n                hsla.pop();\r\n                prefix = &quot;hsl(&quot;;\r\n            }\r\n            return prefix + hsla.join(&quot;, &quot;) + &quot;)&quot;;\r\n        },\r\n        toHexString: function(includeAlpha) {\r\n            var rgba = this._rgba.slice(),\r\n                alpha = rgba.pop();\r\n\r\n            if (includeAlpha) {\r\n                rgba.push(~~(alpha * 255));\r\n            }\r\n\r\n            return &quot;#&quot; + jQuery.map(rgba, function(v) {\r\n\r\n                \/\/ default to 0 when nulls exist\r\n                return (&quot;0&quot; + (v || 0).toString(16)).substr(-2);\r\n            }).join(&quot;&quot;);\r\n        },\r\n        toString: function() {\r\n            return this.toRgbaString();\r\n        }\r\n    });\r\n    color.fn.parse.prototype = color.fn;\r\n\r\n    \/\/ hsla conversions adapted from:\r\n    \/\/ https:\/\/code.google.com\/p\/maashaack\/source\/browse\/packages\/graphics\/trunk\/src\/graphics\/colors\/HUE2RGB.as?r=5021\r\n\r\n    function hue2rgb(p, q, h) {\r\n        h = (h + 1) % 1;\r\n        if (h * 6 &lt; 1) {\r\n            return p + (q - p) * h * 6;\r\n        }\r\n        if (h * 2 &lt; 1) {\r\n            return q;\r\n        }\r\n        if (h * 3 &lt; 2) {\r\n            return p + (q - p) * ((2 \/ 3) - h) * 6;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    spaces.hsla.to = function(rgba) {\r\n        if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {\r\n            return [null, null, null, rgba[3]];\r\n        }\r\n        var r = rgba[0] \/ 255,\r\n            g = rgba[1] \/ 255,\r\n            b = rgba[2] \/ 255,\r\n            a = rgba[3],\r\n            max = Math.max(r, g, b),\r\n            min = Math.min(r, g, b),\r\n            diff = max - min,\r\n            add = max + min,\r\n            l = add * 0.5,\r\n            h, s;\r\n\r\n        if (min === max) {\r\n            h = 0;\r\n        } else if (r === max) {\r\n            h = (60 * (g - b) \/ diff) + 360;\r\n        } else if (g === max) {\r\n            h = (60 * (b - r) \/ diff) + 120;\r\n        } else {\r\n            h = (60 * (r - g) \/ diff) + 240;\r\n        }\r\n\r\n        \/\/ chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\r\n        \/\/ otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\r\n        if (diff === 0) {\r\n            s = 0;\r\n        } else if (l &lt;= 0.5) {\r\n            s = diff \/ add;\r\n        } else {\r\n            s = diff \/ (2 - add);\r\n        }\r\n        return [Math.round(h) % 360, s, l, a == null ? 1 : a];\r\n    };\r\n\r\n    spaces.hsla.from = function(hsla) {\r\n        if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {\r\n            return [null, null, null, hsla[3]];\r\n        }\r\n        var h = hsla[0] \/ 360,\r\n            s = hsla[1],\r\n            l = hsla[2],\r\n            a = hsla[3],\r\n            q = l &lt;= 0.5 ? l * (1 + s) : l + s - l * s,\r\n            p = 2 * l - q;\r\n\r\n        return [\r\n            Math.round(hue2rgb(p, q, h + (1 \/ 3)) * 255),\r\n            Math.round(hue2rgb(p, q, h) * 255),\r\n            Math.round(hue2rgb(p, q, h - (1 \/ 3)) * 255),\r\n            a\r\n        ];\r\n    };\r\n\r\n\r\n    each(spaces, function(spaceName, space) {\r\n        var props = space.props,\r\n            cache = space.cache,\r\n            to = space.to,\r\n            from = space.from;\r\n\r\n        \/\/ makes rgba() and hsla()\r\n        color.fn[spaceName] = function(value) {\r\n\r\n            \/\/ generate a cache for this space if it doesn&#039;t exist\r\n            if (to &amp;&amp; !this[cache]) {\r\n                this[cache] = to(this._rgba);\r\n            }\r\n            if (value === undefined) {\r\n                return this[cache].slice();\r\n            }\r\n\r\n            var ret,\r\n                type = getType(value),\r\n                arr = (type === &quot;array&quot; || type === &quot;object&quot;) ? value : arguments,\r\n                local = this[cache].slice();\r\n\r\n            each(props, function(key, prop) {\r\n                var val = arr[type === &quot;object&quot; ? key : prop.idx];\r\n                if (val == null) {\r\n                    val = local[prop.idx];\r\n                }\r\n                local[prop.idx] = clamp(val, prop);\r\n            });\r\n\r\n            if (from) {\r\n                ret = color(from(local));\r\n                ret[cache] = local;\r\n                return ret;\r\n            } else {\r\n                return color(local);\r\n            }\r\n        };\r\n\r\n        \/\/ makes red() green() blue() alpha() hue() saturation() lightness()\r\n        each(props, function(key, prop) {\r\n\r\n            \/\/ alpha is included in more than one space\r\n            if (color.fn[key]) {\r\n                return;\r\n            }\r\n            color.fn[key] = function(value) {\r\n                var local, cur, match, fn,\r\n                    vtype = getType(value);\r\n\r\n                if (key === &quot;alpha&quot;) {\r\n                    fn = this._hsla ? &quot;hsla&quot; : &quot;rgba&quot;;\r\n                } else {\r\n                    fn = spaceName;\r\n                }\r\n                local = this[fn]();\r\n                cur = local[prop.idx];\r\n\r\n                if (vtype === &quot;undefined&quot;) {\r\n                    return cur;\r\n                }\r\n\r\n                if (vtype === &quot;function&quot;) {\r\n                    value = value.call(this, cur);\r\n                    vtype = getType(value);\r\n                }\r\n                if (value == null &amp;&amp; prop.empty) {\r\n                    return this;\r\n                }\r\n                if (vtype === &quot;string&quot;) {\r\n                    match = rplusequals.exec(value);\r\n                    if (match) {\r\n                        value = cur + parseFloat(match[2]) * (match[1] === &quot;+&quot; ? 1 : -1);\r\n                    }\r\n                }\r\n                local[prop.idx] = value;\r\n                return this[fn](local);\r\n            };\r\n        });\r\n    });\r\n\r\n    \/\/ add cssHook and .fx.step function for each named hook.\r\n    \/\/ accept a space separated string of properties\r\n    color.hook = function(hook) {\r\n        var hooks = hook.split(&quot; &quot;);\r\n        each(hooks, function(_i, hook) {\r\n            jQuery.cssHooks[hook] = {\r\n                set: function(elem, value) {\r\n                    var parsed;\r\n\r\n                    if (value !== &quot;transparent&quot; &amp;&amp;\r\n                        (getType(value) !== &quot;string&quot; ||\r\n                            (parsed = stringParse(value)))) {\r\n                        value = color(parsed || value);\r\n                        value = value.toRgbaString();\r\n                    }\r\n                    elem.style[hook] = value;\r\n                }\r\n            };\r\n            jQuery.fx.step[hook] = function(fx) {\r\n                if (!fx.colorInit) {\r\n                    fx.start = color(fx.elem, hook);\r\n                    fx.end = color(fx.end);\r\n                    fx.colorInit = true;\r\n                }\r\n                jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));\r\n            };\r\n        });\r\n\r\n    };\r\n\r\n    color.hook(stepHooks);\r\n\r\n    jQuery.cssHooks.borderColor = {\r\n        expand: function(value) {\r\n            var expanded = {};\r\n\r\n            each([&quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot;], function(_i, part) {\r\n                expanded[&quot;border&quot; + part + &quot;Color&quot;] = value;\r\n            });\r\n            return expanded;\r\n        }\r\n    };\r\n\r\n    \/\/ Basic color names only.\r\n    \/\/ Usage of any of the other color names requires adding yourself or including\r\n    \/\/ jquery.color.svg-names.js.\r\n    colors = jQuery.Color.names = {\r\n\r\n        \/\/ 4.1. Basic color keywords\r\n        aqua: &quot;#00ffff&quot;,\r\n        black: &quot;#000000&quot;,\r\n        blue: &quot;#0000ff&quot;,\r\n        fuchsia: &quot;#ff00ff&quot;,\r\n        gray: &quot;#808080&quot;,\r\n        green: &quot;#008000&quot;,\r\n        lime: &quot;#00ff00&quot;,\r\n        maroon: &quot;#800000&quot;,\r\n        navy: &quot;#000080&quot;,\r\n        olive: &quot;#808000&quot;,\r\n        purple: &quot;#800080&quot;,\r\n        red: &quot;#ff0000&quot;,\r\n        silver: &quot;#c0c0c0&quot;,\r\n        teal: &quot;#008080&quot;,\r\n        white: &quot;#ffffff&quot;,\r\n        yellow: &quot;#ffff00&quot;,\r\n\r\n        \/\/ 4.2.3. &quot;transparent&quot; color keyword\r\n        transparent: [null, null, null, 0],\r\n\r\n        _default: &quot;#ffffff&quot;\r\n    };\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Effects Core\r\n    \/\/&gt;&gt;group: Effects\r\n    \/* eslint-disable max-len *\/\r\n    \/\/&gt;&gt;description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.\r\n    \/* eslint-enable max-len *\/\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/category\/effects-core\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var dataSpace = &quot;ui-effects-&quot;,\r\n        dataSpaceStyle = &quot;ui-effects-style&quot;,\r\n        dataSpaceAnimated = &quot;ui-effects-animated&quot;;\r\n\r\n    $.effects = {\r\n        effect: {}\r\n    };\r\n\r\n    \/******************************************************************************\/\r\n    \/****************************** CLASS ANIMATIONS ******************************\/\r\n    \/******************************************************************************\/\r\n    (function() {\r\n\r\n        var classAnimationActions = [&quot;add&quot;, &quot;remove&quot;, &quot;toggle&quot;],\r\n            shorthandStyles = {\r\n                border: 1,\r\n                borderBottom: 1,\r\n                borderColor: 1,\r\n                borderLeft: 1,\r\n                borderRight: 1,\r\n                borderTop: 1,\r\n                borderWidth: 1,\r\n                margin: 1,\r\n                padding: 1\r\n            };\r\n\r\n        $.each(\r\n            [&quot;borderLeftStyle&quot;, &quot;borderRightStyle&quot;, &quot;borderBottomStyle&quot;, &quot;borderTopStyle&quot;],\r\n            function(_, prop) {\r\n                $.fx.step[prop] = function(fx) {\r\n                    if (fx.end !== &quot;none&quot; &amp;&amp; !fx.setAttr || fx.pos === 1 &amp;&amp; !fx.setAttr) {\r\n                        jQuery.style(fx.elem, prop, fx.end);\r\n                        fx.setAttr = true;\r\n                    }\r\n                };\r\n            }\r\n        );\r\n\r\n        function camelCase(string) {\r\n            return string.replace(\/-([\\da-z])\/gi, function(all, letter) {\r\n                return letter.toUpperCase();\r\n            });\r\n        }\r\n\r\n        function getElementStyles(elem) {\r\n            var key, len,\r\n                style = elem.ownerDocument.defaultView.getComputedStyle(elem),\r\n                styles = {};\r\n\r\n            len = style.length;\r\n            while (len--) {\r\n                key = style[len];\r\n                if (typeof style[key] === &quot;string&quot;) {\r\n                    styles[camelCase(key)] = style[key];\r\n                }\r\n            }\r\n\r\n            return styles;\r\n        }\r\n\r\n        function styleDifference(oldStyle, newStyle) {\r\n            var diff = {},\r\n                name, value;\r\n\r\n            for (name in newStyle) {\r\n                value = newStyle[name];\r\n                if (oldStyle[name] !== value) {\r\n                    if (!shorthandStyles[name]) {\r\n                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {\r\n                            diff[name] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return diff;\r\n        }\r\n\r\n        $.effects.animateClass = function(value, duration, easing, callback) {\r\n            var o = $.speed(duration, easing, callback);\r\n\r\n            return this.queue(function() {\r\n                var animated = $(this),\r\n                    baseClass = animated.attr(&quot;class&quot;) || &quot;&quot;,\r\n                    applyClassChange,\r\n                    allAnimations = o.children ? animated.find(&quot;*&quot;).addBack() : animated;\r\n\r\n                \/\/ Map the animated objects to store the original styles.\r\n                allAnimations = allAnimations.map(function() {\r\n                    var el = $(this);\r\n                    return {\r\n                        el: el,\r\n                        start: getElementStyles(this)\r\n                    };\r\n                });\r\n\r\n                \/\/ Apply class change\r\n                applyClassChange = function() {\r\n                    $.each(classAnimationActions, function(i, action) {\r\n                        if (value[action]) {\r\n                            animated[action + &quot;Class&quot;](value[action]);\r\n                        }\r\n                    });\r\n                };\r\n                applyClassChange();\r\n\r\n                \/\/ Map all animated objects again - calculate new styles and diff\r\n                allAnimations = allAnimations.map(function() {\r\n                    this.end = getElementStyles(this.el[0]);\r\n                    this.diff = styleDifference(this.start, this.end);\r\n                    return this;\r\n                });\r\n\r\n                \/\/ Apply original class\r\n                animated.attr(&quot;class&quot;, baseClass);\r\n\r\n                \/\/ Map all animated objects again - this time collecting a promise\r\n                allAnimations = allAnimations.map(function() {\r\n                    var styleInfo = this,\r\n                        dfd = $.Deferred(),\r\n                        opts = $.extend({}, o, {\r\n                            queue: false,\r\n                            complete: function() {\r\n                                dfd.resolve(styleInfo);\r\n                            }\r\n                        });\r\n\r\n                    this.el.animate(this.diff, opts);\r\n                    return dfd.promise();\r\n                });\r\n\r\n                \/\/ Once all animations have completed:\r\n                $.when.apply($, allAnimations.get()).done(function() {\r\n\r\n                    \/\/ Set the final class\r\n                    applyClassChange();\r\n\r\n                    \/\/ For each animated element,\r\n                    \/\/ clear all css properties that were animated\r\n                    $.each(arguments, function() {\r\n                        var el = this.el;\r\n                        $.each(this.diff, function(key) {\r\n                            el.css(key, &quot;&quot;);\r\n                        });\r\n                    });\r\n\r\n                    \/\/ This is guarnteed to be there if you use jQuery.speed()\r\n                    \/\/ it also handles dequeuing the next anim...\r\n                    o.complete.call(animated[0]);\r\n                });\r\n            });\r\n        };\r\n\r\n        $.fn.extend({\r\n            addClass: (function(orig) {\r\n                return function(classNames, speed, easing, callback) {\r\n                    return speed ?\r\n                        $.effects.animateClass.call(this, {\r\n                            add: classNames\r\n                        }, speed, easing, callback) :\r\n                        orig.apply(this, arguments);\r\n                };\r\n            })($.fn.addClass),\r\n\r\n            removeClass: (function(orig) {\r\n                return function(classNames, speed, easing, callback) {\r\n                    return arguments.length &gt; 1 ?\r\n                        $.effects.animateClass.call(this, {\r\n                            remove: classNames\r\n                        }, speed, easing, callback) :\r\n                        orig.apply(this, arguments);\r\n                };\r\n            })($.fn.removeClass),\r\n\r\n            toggleClass: (function(orig) {\r\n                return function(classNames, force, speed, easing, callback) {\r\n                    if (typeof force === &quot;boolean&quot; || force === undefined) {\r\n                        if (!speed) {\r\n\r\n                            \/\/ Without speed parameter\r\n                            return orig.apply(this, arguments);\r\n                        } else {\r\n                            return $.effects.animateClass.call(this,\r\n                                (force ? {\r\n                                    add: classNames\r\n                                } : {\r\n                                    remove: classNames\r\n                                }),\r\n                                speed, easing, callback);\r\n                        }\r\n                    } else {\r\n\r\n                        \/\/ Without force parameter\r\n                        return $.effects.animateClass.call(this, {\r\n                            toggle: classNames\r\n                        }, force, speed, easing);\r\n                    }\r\n                };\r\n            })($.fn.toggleClass),\r\n\r\n            switchClass: function(remove, add, speed, easing, callback) {\r\n                return $.effects.animateClass.call(this, {\r\n                    add: add,\r\n                    remove: remove\r\n                }, speed, easing, callback);\r\n            }\r\n        });\r\n\r\n    })();\r\n\r\n    \/******************************************************************************\/\r\n    \/*********************************** EFFECTS **********************************\/\r\n    \/******************************************************************************\/\r\n\r\n    (function() {\r\n\r\n        if ($.expr &amp;&amp; $.expr.pseudos &amp;&amp; $.expr.pseudos.animated) {\r\n            $.expr.pseudos.animated = (function(orig) {\r\n                return function(elem) {\r\n                    return !!$(elem).data(dataSpaceAnimated) || orig(elem);\r\n                };\r\n            })($.expr.pseudos.animated);\r\n        }\r\n\r\n        if ($.uiBackCompat === true) {\r\n            $.extend($.effects, {\r\n\r\n                \/\/ Saves a set of properties in a data storage\r\n                save: function(element, set) {\r\n                    var i = 0,\r\n                        length = set.length;\r\n                    for (; i &lt; length; i++) {\r\n                        if (set[i] !== null) {\r\n                            element.data(dataSpace + set[i], element[0].style[set[i]]);\r\n                        }\r\n                    }\r\n                },\r\n\r\n                \/\/ Restores a set of previously saved properties from a data storage\r\n                restore: function(element, set) {\r\n                    var val, i = 0,\r\n                        length = set.length;\r\n                    for (; i &lt; length; i++) {\r\n                        if (set[i] !== null) {\r\n                            val = element.data(dataSpace + set[i]);\r\n                            element.css(set[i], val);\r\n                        }\r\n                    }\r\n                },\r\n\r\n                setMode: function(el, mode) {\r\n                    if (mode === &quot;toggle&quot;) {\r\n                        mode = el.is(&quot;:hidden&quot;) ? &quot;show&quot; : &quot;hide&quot;;\r\n                    }\r\n                    return mode;\r\n                },\r\n\r\n                \/\/ Wraps the element around a wrapper that copies position properties\r\n                createWrapper: function(element) {\r\n\r\n                    \/\/ If the element is already wrapped, return it\r\n                    if (element.parent().is(&quot;.ui-effects-wrapper&quot;)) {\r\n                        return element.parent();\r\n                    }\r\n\r\n                    \/\/ Wrap the element\r\n                    var props = {\r\n                            width: element.outerWidth(true),\r\n                            height: element.outerHeight(true),\r\n                            &quot;float&quot;: element.css(&quot;float&quot;)\r\n                        },\r\n                        wrapper = $(&quot;&lt;div&gt;&lt;\/div&gt;&quot;)\r\n                        .addClass(&quot;ui-effects-wrapper&quot;)\r\n                        .css({\r\n                            fontSize: &quot;100%&quot;,\r\n                            background: &quot;transparent&quot;,\r\n                            border: &quot;none&quot;,\r\n                            margin: 0,\r\n                            padding: 0\r\n                        }),\r\n\r\n                        \/\/ Store the size in case width\/height are defined in % - Fixes #5245\r\n                        size = {\r\n                            width: element.width(),\r\n                            height: element.height()\r\n                        },\r\n                        active = document.activeElement;\r\n\r\n                    \/\/ Support: Firefox\r\n                    \/\/ Firefox incorrectly exposes anonymous content\r\n                    \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=561664\r\n                    try {\r\n                        \/\/ eslint-disable-next-line no-unused-expressions\r\n                        active.id;\r\n                    } catch (e) {\r\n                        active = document.body;\r\n                    }\r\n\r\n                    element.wrap(wrapper);\r\n\r\n                    \/\/ Fixes #7595 - Elements lose focus when wrapped.\r\n                    if (element[0] === active || $.contains(element[0], active)) {\r\n                        $(active).trigger(&quot;focus&quot;);\r\n                    }\r\n\r\n                    \/\/ Hotfix for jQuery 1.4 since some change in wrap() seems to actually\r\n                    \/\/ lose the reference to the wrapped element\r\n                    wrapper = element.parent();\r\n\r\n                    \/\/ Transfer positioning properties to the wrapper\r\n                    if (element.css(&quot;position&quot;) === &quot;static&quot;) {\r\n                        wrapper.css({\r\n                            position: &quot;relative&quot;\r\n                        });\r\n                        element.css({\r\n                            position: &quot;relative&quot;\r\n                        });\r\n                    } else {\r\n                        $.extend(props, {\r\n                            position: element.css(&quot;position&quot;),\r\n                            zIndex: element.css(&quot;z-index&quot;)\r\n                        });\r\n                        $.each([&quot;top&quot;, &quot;left&quot;, &quot;bottom&quot;, &quot;right&quot;], function(i, pos) {\r\n                            props[pos] = element.css(pos);\r\n                            if (isNaN(parseInt(props[pos], 10))) {\r\n                                props[pos] = &quot;auto&quot;;\r\n                            }\r\n                        });\r\n                        element.css({\r\n                            position: &quot;relative&quot;,\r\n                            top: 0,\r\n                            left: 0,\r\n                            right: &quot;auto&quot;,\r\n                            bottom: &quot;auto&quot;\r\n                        });\r\n                    }\r\n                    element.css(size);\r\n\r\n                    return wrapper.css(props).show();\r\n                },\r\n\r\n                removeWrapper: function(element) {\r\n                    var active = document.activeElement;\r\n\r\n                    if (element.parent().is(&quot;.ui-effects-wrapper&quot;)) {\r\n                        element.parent().replaceWith(element);\r\n\r\n                        \/\/ Fixes #7595 - Elements lose focus when wrapped.\r\n                        if (element[0] === active || $.contains(element[0], active)) {\r\n                            $(active).trigger(&quot;focus&quot;);\r\n                        }\r\n                    }\r\n\r\n                    return element;\r\n                }\r\n            });\r\n        }\r\n\r\n        $.extend($.effects, {\r\n            version: &quot;1.14.1&quot;,\r\n\r\n            define: function(name, mode, effect) {\r\n                if (!effect) {\r\n                    effect = mode;\r\n                    mode = &quot;effect&quot;;\r\n                }\r\n\r\n                $.effects.effect[name] = effect;\r\n                $.effects.effect[name].mode = mode;\r\n\r\n                return effect;\r\n            },\r\n\r\n            scaledDimensions: function(element, percent, direction) {\r\n                if (percent === 0) {\r\n                    return {\r\n                        height: 0,\r\n                        width: 0,\r\n                        outerHeight: 0,\r\n                        outerWidth: 0\r\n                    };\r\n                }\r\n\r\n                var x = direction !== &quot;horizontal&quot; ? ((percent || 100) \/ 100) : 1,\r\n                    y = direction !== &quot;vertical&quot; ? ((percent || 100) \/ 100) : 1;\r\n\r\n                return {\r\n                    height: element.height() * y,\r\n                    width: element.width() * x,\r\n                    outerHeight: element.outerHeight() * y,\r\n                    outerWidth: element.outerWidth() * x\r\n                };\r\n\r\n            },\r\n\r\n            clipToBox: function(animation) {\r\n                return {\r\n                    width: animation.clip.right - animation.clip.left,\r\n                    height: animation.clip.bottom - animation.clip.top,\r\n                    left: animation.clip.left,\r\n                    top: animation.clip.top\r\n                };\r\n            },\r\n\r\n            \/\/ Injects recently queued functions to be first in line (after &quot;inprogress&quot;)\r\n            unshift: function(element, queueLength, count) {\r\n                var queue = element.queue();\r\n\r\n                if (queueLength &gt; 1) {\r\n                    queue.splice.apply(queue,\r\n                        [1, 0].concat(queue.splice(queueLength, count)));\r\n                }\r\n                element.dequeue();\r\n            },\r\n\r\n            saveStyle: function(element) {\r\n                element.data(dataSpaceStyle, element[0].style.cssText);\r\n            },\r\n\r\n            restoreStyle: function(element) {\r\n                element[0].style.cssText = element.data(dataSpaceStyle) || &quot;&quot;;\r\n                element.removeData(dataSpaceStyle);\r\n            },\r\n\r\n            mode: function(element, mode) {\r\n                var hidden = element.is(&quot;:hidden&quot;);\r\n\r\n                if (mode === &quot;toggle&quot;) {\r\n                    mode = hidden ? &quot;show&quot; : &quot;hide&quot;;\r\n                }\r\n                if (hidden ? mode === &quot;hide&quot; : mode === &quot;show&quot;) {\r\n                    mode = &quot;none&quot;;\r\n                }\r\n                return mode;\r\n            },\r\n\r\n            \/\/ Translates a [top,left] array into a baseline value\r\n            getBaseline: function(origin, original) {\r\n                var y, x;\r\n\r\n                switch (origin[0]) {\r\n                    case &quot;top&quot;:\r\n                        y = 0;\r\n                        break;\r\n                    case &quot;middle&quot;:\r\n                        y = 0.5;\r\n                        break;\r\n                    case &quot;bottom&quot;:\r\n                        y = 1;\r\n                        break;\r\n                    default:\r\n                        y = origin[0] \/ original.height;\r\n                }\r\n\r\n                switch (origin[1]) {\r\n                    case &quot;left&quot;:\r\n                        x = 0;\r\n                        break;\r\n                    case &quot;center&quot;:\r\n                        x = 0.5;\r\n                        break;\r\n                    case &quot;right&quot;:\r\n                        x = 1;\r\n                        break;\r\n                    default:\r\n                        x = origin[1] \/ original.width;\r\n                }\r\n\r\n                return {\r\n                    x: x,\r\n                    y: y\r\n                };\r\n            },\r\n\r\n            \/\/ Creates a placeholder element so that the original element can be made absolute\r\n            createPlaceholder: function(element) {\r\n                var placeholder,\r\n                    cssPosition = element.css(&quot;position&quot;),\r\n                    position = element.position();\r\n\r\n                \/\/ Lock in margins first to account for form elements, which\r\n                \/\/ will change margin if you explicitly set height\r\n                \/\/ see: https:\/\/jsfiddle.net\/JZSMt\/3\/ https:\/\/bugs.webkit.org\/show_bug.cgi?id=107380\r\n                \/\/ Support: Safari\r\n                element.css({\r\n                        marginTop: element.css(&quot;marginTop&quot;),\r\n                        marginBottom: element.css(&quot;marginBottom&quot;),\r\n                        marginLeft: element.css(&quot;marginLeft&quot;),\r\n                        marginRight: element.css(&quot;marginRight&quot;)\r\n                    })\r\n                    .outerWidth(element.outerWidth())\r\n                    .outerHeight(element.outerHeight());\r\n\r\n                if (\/^(static|relative)\/.test(cssPosition)) {\r\n                    cssPosition = &quot;absolute&quot;;\r\n\r\n                    placeholder = $(&quot;&lt;&quot; + element[0].nodeName + &quot;&gt;&quot;).insertAfter(element).css({\r\n\r\n                            \/\/ Convert inline to inline block to account for inline elements\r\n                            \/\/ that turn to inline block based on content (like img)\r\n                            display: \/^(inline|ruby)\/.test(element.css(&quot;display&quot;)) ?\r\n                                &quot;inline-block&quot; : &quot;block&quot;,\r\n                            visibility: &quot;hidden&quot;,\r\n\r\n                            \/\/ Margins need to be set to account for margin collapse\r\n                            marginTop: element.css(&quot;marginTop&quot;),\r\n                            marginBottom: element.css(&quot;marginBottom&quot;),\r\n                            marginLeft: element.css(&quot;marginLeft&quot;),\r\n                            marginRight: element.css(&quot;marginRight&quot;),\r\n                            &quot;float&quot;: element.css(&quot;float&quot;)\r\n                        })\r\n                        .outerWidth(element.outerWidth())\r\n                        .outerHeight(element.outerHeight())\r\n                        .addClass(&quot;ui-effects-placeholder&quot;);\r\n\r\n                    element.data(dataSpace + &quot;placeholder&quot;, placeholder);\r\n                }\r\n\r\n                element.css({\r\n                    position: cssPosition,\r\n                    left: position.left,\r\n                    top: position.top\r\n                });\r\n\r\n                return placeholder;\r\n            },\r\n\r\n            removePlaceholder: function(element) {\r\n                var dataKey = dataSpace + &quot;placeholder&quot;,\r\n                    placeholder = element.data(dataKey);\r\n\r\n                if (placeholder) {\r\n                    placeholder.remove();\r\n                    element.removeData(dataKey);\r\n                }\r\n            },\r\n\r\n            \/\/ Removes a placeholder if it exists and restores\r\n            \/\/ properties that were modified during placeholder creation\r\n            cleanUp: function(element) {\r\n                $.effects.restoreStyle(element);\r\n                $.effects.removePlaceholder(element);\r\n            },\r\n\r\n            setTransition: function(element, list, factor, value) {\r\n                value = value || {};\r\n                $.each(list, function(i, x) {\r\n                    var unit = element.cssUnit(x);\r\n                    if (unit[0] &gt; 0) {\r\n                        value[x] = unit[0] * factor + unit[1];\r\n                    }\r\n                });\r\n                return value;\r\n            }\r\n        });\r\n\r\n        \/\/ Return an effect options object for the given parameters:\r\n        function _normalizeArguments(effect, options, speed, callback) {\r\n\r\n            \/\/ Allow passing all options as the first parameter\r\n            if ($.isPlainObject(effect)) {\r\n                options = effect;\r\n                effect = effect.effect;\r\n            }\r\n\r\n            \/\/ Convert to an object\r\n            effect = {\r\n                effect: effect\r\n            };\r\n\r\n            \/\/ Catch (effect, null, ...)\r\n            if (options == null) {\r\n                options = {};\r\n            }\r\n\r\n            \/\/ Catch (effect, callback)\r\n            if (typeof options === &quot;function&quot;) {\r\n                callback = options;\r\n                speed = null;\r\n                options = {};\r\n            }\r\n\r\n            \/\/ Catch (effect, speed, ?)\r\n            if (typeof options === &quot;number&quot; || $.fx.speeds[options]) {\r\n                callback = speed;\r\n                speed = options;\r\n                options = {};\r\n            }\r\n\r\n            \/\/ Catch (effect, options, callback)\r\n            if (typeof speed === &quot;function&quot;) {\r\n                callback = speed;\r\n                speed = null;\r\n            }\r\n\r\n            \/\/ Add options to effect\r\n            if (options) {\r\n                $.extend(effect, options);\r\n            }\r\n\r\n            speed = speed || options.duration;\r\n            effect.duration = $.fx.off ? 0 :\r\n                typeof speed === &quot;number&quot; ? speed :\r\n                speed in $.fx.speeds ? $.fx.speeds[speed] :\r\n                $.fx.speeds._default;\r\n\r\n            effect.complete = callback || options.complete;\r\n\r\n            return effect;\r\n        }\r\n\r\n        function standardAnimationOption(option) {\r\n\r\n            \/\/ Valid standard speeds (nothing, number, named speed)\r\n            if (!option || typeof option === &quot;number&quot; || $.fx.speeds[option]) {\r\n                return true;\r\n            }\r\n\r\n            \/\/ Invalid strings - treat as &quot;normal&quot; speed\r\n            if (typeof option === &quot;string&quot; &amp;&amp; !$.effects.effect[option]) {\r\n                return true;\r\n            }\r\n\r\n            \/\/ Complete callback\r\n            if (typeof option === &quot;function&quot;) {\r\n                return true;\r\n            }\r\n\r\n            \/\/ Options hash (but not naming an effect)\r\n            if (typeof option === &quot;object&quot; &amp;&amp; !option.effect) {\r\n                return true;\r\n            }\r\n\r\n            \/\/ Didn&#039;t match any standard API\r\n            return false;\r\n        }\r\n\r\n        $.fn.extend({\r\n            effect: function( \/* effect, options, speed, callback *\/ ) {\r\n                var args = _normalizeArguments.apply(this, arguments),\r\n                    effectMethod = $.effects.effect[args.effect],\r\n                    defaultMode = effectMethod.mode,\r\n                    queue = args.queue,\r\n                    queueName = queue || &quot;fx&quot;,\r\n                    complete = args.complete,\r\n                    mode = args.mode,\r\n                    modes = [],\r\n                    prefilter = function(next) {\r\n                        var el = $(this),\r\n                            normalizedMode = $.effects.mode(el, mode) || defaultMode;\r\n\r\n                        \/\/ Sentinel for duck-punching the :animated pseudo-selector\r\n                        el.data(dataSpaceAnimated, true);\r\n\r\n                        \/\/ Save effect mode for later use,\r\n                        \/\/ we can&#039;t just call $.effects.mode again later,\r\n                        \/\/ as the .show() below destroys the initial state\r\n                        modes.push(normalizedMode);\r\n\r\n                        \/\/ See $.uiBackCompat inside of run() for removal of defaultMode in 1.14\r\n                        if (defaultMode &amp;&amp; (normalizedMode === &quot;show&quot; ||\r\n                                (normalizedMode === defaultMode &amp;&amp; normalizedMode === &quot;hide&quot;))) {\r\n                            el.show();\r\n                        }\r\n\r\n                        if (!defaultMode || normalizedMode !== &quot;none&quot;) {\r\n                            $.effects.saveStyle(el);\r\n                        }\r\n\r\n                        if (typeof next === &quot;function&quot;) {\r\n                            next();\r\n                        }\r\n                    };\r\n\r\n                if ($.fx.off || !effectMethod) {\r\n\r\n                    \/\/ Delegate to the original method (e.g., .show()) if possible\r\n                    if (mode) {\r\n                        return this[mode](args.duration, complete);\r\n                    } else {\r\n                        return this.each(function() {\r\n                            if (complete) {\r\n                                complete.call(this);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                function run(next) {\r\n                    var elem = $(this);\r\n\r\n                    function cleanup() {\r\n                        elem.removeData(dataSpaceAnimated);\r\n\r\n                        $.effects.cleanUp(elem);\r\n\r\n                        if (args.mode === &quot;hide&quot;) {\r\n                            elem.hide();\r\n                        }\r\n\r\n                        done();\r\n                    }\r\n\r\n                    function done() {\r\n                        if (typeof complete === &quot;function&quot;) {\r\n                            complete.call(elem[0]);\r\n                        }\r\n\r\n                        if (typeof next === &quot;function&quot;) {\r\n                            next();\r\n                        }\r\n                    }\r\n\r\n                    \/\/ Override mode option on a per element basis,\r\n                    \/\/ as toggle can be either show or hide depending on element state\r\n                    args.mode = modes.shift();\r\n\r\n                    if ($.uiBackCompat === true &amp;&amp; !defaultMode) {\r\n                        if (elem.is(&quot;:hidden&quot;) ? mode === &quot;hide&quot; : mode === &quot;show&quot;) {\r\n\r\n                            \/\/ Call the core method to track &quot;olddisplay&quot; properly\r\n                            elem[mode]();\r\n                            done();\r\n                        } else {\r\n                            effectMethod.call(elem[0], args, done);\r\n                        }\r\n                    } else {\r\n                        if (args.mode === &quot;none&quot;) {\r\n\r\n                            \/\/ Call the core method to track &quot;olddisplay&quot; properly\r\n                            elem[mode]();\r\n                            done();\r\n                        } else {\r\n                            effectMethod.call(elem[0], args, cleanup);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \/\/ Run prefilter on all elements first to ensure that\r\n                \/\/ any showing or hiding happens before placeholder creation,\r\n                \/\/ which ensures that any layout changes are correctly captured.\r\n                return queue === false ?\r\n                    this.each(prefilter).each(run) :\r\n                    this.queue(queueName, prefilter).queue(queueName, run);\r\n            },\r\n\r\n            show: (function(orig) {\r\n                return function(option) {\r\n                    if (standardAnimationOption(option)) {\r\n                        return orig.apply(this, arguments);\r\n                    } else {\r\n                        var args = _normalizeArguments.apply(this, arguments);\r\n                        args.mode = &quot;show&quot;;\r\n                        return this.effect.call(this, args);\r\n                    }\r\n                };\r\n            })($.fn.show),\r\n\r\n            hide: (function(orig) {\r\n                return function(option) {\r\n                    if (standardAnimationOption(option)) {\r\n                        return orig.apply(this, arguments);\r\n                    } else {\r\n                        var args = _normalizeArguments.apply(this, arguments);\r\n                        args.mode = &quot;hide&quot;;\r\n                        return this.effect.call(this, args);\r\n                    }\r\n                };\r\n            })($.fn.hide),\r\n\r\n            toggle: (function(orig) {\r\n                return function(option) {\r\n                    if (standardAnimationOption(option) || typeof option === &quot;boolean&quot;) {\r\n                        return orig.apply(this, arguments);\r\n                    } else {\r\n                        var args = _normalizeArguments.apply(this, arguments);\r\n                        args.mode = &quot;toggle&quot;;\r\n                        return this.effect.call(this, args);\r\n                    }\r\n                };\r\n            })($.fn.toggle),\r\n\r\n            cssUnit: function(key) {\r\n                var style = this.css(key),\r\n                    val = [];\r\n\r\n                $.each([&quot;em&quot;, &quot;px&quot;, &quot;%&quot;, &quot;pt&quot;], function(i, unit) {\r\n                    if (style.indexOf(unit) &gt; 0) {\r\n                        val = [parseFloat(style), unit];\r\n                    }\r\n                });\r\n                return val;\r\n            },\r\n\r\n            cssClip: function(clipObj) {\r\n                if (clipObj) {\r\n                    return this.css(&quot;clip&quot;, &quot;rect(&quot; + clipObj.top + &quot;px &quot; + clipObj.right + &quot;px &quot; +\r\n                        clipObj.bottom + &quot;px &quot; + clipObj.left + &quot;px)&quot;);\r\n                }\r\n                return parseClip(this.css(&quot;clip&quot;), this);\r\n            },\r\n\r\n            transfer: function(options, done) {\r\n                var element = $(this),\r\n                    target = $(options.to),\r\n                    targetFixed = target.css(&quot;position&quot;) === &quot;fixed&quot;,\r\n                    body = $(&quot;body&quot;),\r\n                    fixTop = targetFixed ? body.scrollTop() : 0,\r\n                    fixLeft = targetFixed ? body.scrollLeft() : 0,\r\n                    endPosition = target.offset(),\r\n                    animation = {\r\n                        top: endPosition.top - fixTop,\r\n                        left: endPosition.left - fixLeft,\r\n                        height: target.innerHeight(),\r\n                        width: target.innerWidth()\r\n                    },\r\n                    startPosition = element.offset(),\r\n                    transfer = $(&quot;&lt;div class=&#039;ui-effects-transfer&#039;&gt;&lt;\/div&gt;&quot;);\r\n\r\n                transfer\r\n                    .appendTo(&quot;body&quot;)\r\n                    .addClass(options.className)\r\n                    .css({\r\n                        top: startPosition.top - fixTop,\r\n                        left: startPosition.left - fixLeft,\r\n                        height: element.innerHeight(),\r\n                        width: element.innerWidth(),\r\n                        position: targetFixed ? &quot;fixed&quot; : &quot;absolute&quot;\r\n                    })\r\n                    .animate(animation, options.duration, options.easing, function() {\r\n                        transfer.remove();\r\n                        if (typeof done === &quot;function&quot;) {\r\n                            done();\r\n                        }\r\n                    });\r\n            }\r\n        });\r\n\r\n        function parseClip(str, element) {\r\n            var outerWidth = element.outerWidth(),\r\n                outerHeight = element.outerHeight(),\r\n                clipRegex = \/^rect\\((-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto)\\)$\/,\r\n                values = clipRegex.exec(str) || [&quot;&quot;, 0, outerWidth, outerHeight, 0];\r\n\r\n            return {\r\n                top: parseFloat(values[1]) || 0,\r\n                right: values[2] === &quot;auto&quot; ? outerWidth : parseFloat(values[2]),\r\n                bottom: values[3] === &quot;auto&quot; ? outerHeight : parseFloat(values[3]),\r\n                left: parseFloat(values[4]) || 0\r\n            };\r\n        }\r\n\r\n        $.fx.step.clip = function(fx) {\r\n            if (!fx.clipInit) {\r\n                fx.start = $(fx.elem).cssClip();\r\n                if (typeof fx.end === &quot;string&quot;) {\r\n                    fx.end = parseClip(fx.end, fx.elem);\r\n                }\r\n                fx.clipInit = true;\r\n            }\r\n\r\n            $(fx.elem).cssClip({\r\n                top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,\r\n                right: fx.pos * (fx.end.right - fx.start.right) + fx.start.right,\r\n                bottom: fx.pos * (fx.end.bottom - fx.start.bottom) + fx.start.bottom,\r\n                left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left\r\n            });\r\n        };\r\n\r\n    })();\r\n\r\n    \/******************************************************************************\/\r\n    \/*********************************** EASING ***********************************\/\r\n    \/******************************************************************************\/\r\n\r\n    (function() {\r\n\r\n        \/\/ Based on easing equations from Robert Penner (http:\/\/robertpenner.com\/easing)\r\n\r\n        var baseEasings = {};\r\n\r\n        $.each([&quot;Quad&quot;, &quot;Cubic&quot;, &quot;Quart&quot;, &quot;Quint&quot;, &quot;Expo&quot;], function(i, name) {\r\n            baseEasings[name] = function(p) {\r\n                return Math.pow(p, i + 2);\r\n            };\r\n        });\r\n\r\n        $.extend(baseEasings, {\r\n            Sine: function(p) {\r\n                return 1 - Math.cos(p * Math.PI \/ 2);\r\n            },\r\n            Circ: function(p) {\r\n                return 1 - Math.sqrt(1 - p * p);\r\n            },\r\n            Elastic: function(p) {\r\n                return p === 0 || p === 1 ? p :\r\n                    -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI \/ 15);\r\n            },\r\n            Back: function(p) {\r\n                return p * p * (3 * p - 2);\r\n            },\r\n            Bounce: function(p) {\r\n                var pow2,\r\n                    bounce = 4;\r\n\r\n                while (p &lt; ((pow2 = Math.pow(2, --bounce)) - 1) \/ 11) {}\r\n                return 1 \/ Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) \/ 22 - p, 2);\r\n            }\r\n        });\r\n\r\n        $.each(baseEasings, function(name, easeIn) {\r\n            $.easing[&quot;easeIn&quot; + name] = easeIn;\r\n            $.easing[&quot;easeOut&quot; + name] = function(p) {\r\n                return 1 - easeIn(1 - p);\r\n            };\r\n            $.easing[&quot;easeInOut&quot; + name] = function(p) {\r\n                return p &lt; 0.5 ?\r\n                    easeIn(p * 2) \/ 2 :\r\n                    1 - easeIn(p * -2 + 2) \/ 2;\r\n            };\r\n        });\r\n\r\n    })();\r\n\r\n    var effect = $.effects;\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Blind 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Blind Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Blinds the element.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/blind-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectBlind = $.effects.define(&quot;blind&quot;, &quot;hide&quot;, function(options, done) {\r\n        var map = {\r\n                up: [&quot;bottom&quot;, &quot;top&quot;],\r\n                vertical: [&quot;bottom&quot;, &quot;top&quot;],\r\n                down: [&quot;top&quot;, &quot;bottom&quot;],\r\n                left: [&quot;right&quot;, &quot;left&quot;],\r\n                horizontal: [&quot;right&quot;, &quot;left&quot;],\r\n                right: [&quot;left&quot;, &quot;right&quot;]\r\n            },\r\n            element = $(this),\r\n            direction = options.direction || &quot;up&quot;,\r\n            start = element.cssClip(),\r\n            animate = {\r\n                clip: $.extend({}, start)\r\n            },\r\n            placeholder = $.effects.createPlaceholder(element);\r\n\r\n        animate.clip[map[direction][0]] = animate.clip[map[direction][1]];\r\n\r\n        if (options.mode === &quot;show&quot;) {\r\n            element.cssClip(animate.clip);\r\n            if (placeholder) {\r\n                placeholder.css($.effects.clipToBox(animate));\r\n            }\r\n\r\n            animate.clip = start;\r\n        }\r\n\r\n        if (placeholder) {\r\n            placeholder.animate($.effects.clipToBox(animate), options.duration, options.easing);\r\n        }\r\n\r\n        element.animate(animate, {\r\n            queue: false,\r\n            duration: options.duration,\r\n            easing: options.easing,\r\n            complete: done\r\n        });\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Bounce 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Bounce Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Bounces an element horizontally or vertically n times.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/bounce-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectBounce = $.effects.define(&quot;bounce&quot;, function(options, done) {\r\n        var upAnim, downAnim, refValue,\r\n            element = $(this),\r\n\r\n            \/\/ Defaults:\r\n            mode = options.mode,\r\n            hide = mode === &quot;hide&quot;,\r\n            show = mode === &quot;show&quot;,\r\n            direction = options.direction || &quot;up&quot;,\r\n            distance = options.distance,\r\n            times = options.times || 5,\r\n\r\n            \/\/ Number of internal animations\r\n            anims = times * 2 + (show || hide ? 1 : 0),\r\n            speed = options.duration \/ anims,\r\n            easing = options.easing,\r\n\r\n            \/\/ Utility:\r\n            ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,\r\n            motion = (direction === &quot;up&quot; || direction === &quot;left&quot;),\r\n            i = 0,\r\n\r\n            queuelen = element.queue().length;\r\n\r\n        $.effects.createPlaceholder(element);\r\n\r\n        refValue = element.css(ref);\r\n\r\n        \/\/ Default distance for the BIGGEST bounce is the outer Distance \/ 3\r\n        if (!distance) {\r\n            distance = element[ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot;]() \/ 3;\r\n        }\r\n\r\n        if (show) {\r\n            downAnim = {\r\n                opacity: 1\r\n            };\r\n            downAnim[ref] = refValue;\r\n\r\n            \/\/ If we are showing, force opacity 0 and set the initial position\r\n            \/\/ then do the &quot;first&quot; animation\r\n            element\r\n                .css(&quot;opacity&quot;, 0)\r\n                .css(ref, motion ? -distance * 2 : distance * 2)\r\n                .animate(downAnim, speed, easing);\r\n        }\r\n\r\n        \/\/ Start at the smallest distance if we are hiding\r\n        if (hide) {\r\n            distance = distance \/ Math.pow(2, times - 1);\r\n        }\r\n\r\n        downAnim = {};\r\n        downAnim[ref] = refValue;\r\n\r\n        \/\/ Bounces up\/down\/left\/right then back to 0 -- times * 2 animations happen here\r\n        for (; i &lt; times; i++) {\r\n            upAnim = {};\r\n            upAnim[ref] = (motion ? &quot;-=&quot; : &quot;+=&quot;) + distance;\r\n\r\n            element\r\n                .animate(upAnim, speed, easing)\r\n                .animate(downAnim, speed, easing);\r\n\r\n            distance = hide ? distance * 2 : distance \/ 2;\r\n        }\r\n\r\n        \/\/ Last Bounce when Hiding\r\n        if (hide) {\r\n            upAnim = {\r\n                opacity: 0\r\n            };\r\n            upAnim[ref] = (motion ? &quot;-=&quot; : &quot;+=&quot;) + distance;\r\n\r\n            element.animate(upAnim, speed, easing);\r\n        }\r\n\r\n        element.queue(done);\r\n\r\n        $.effects.unshift(element, queuelen, anims + 1);\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Clip 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Clip Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Clips the element on and off like an old TV.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/clip-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectClip = $.effects.define(&quot;clip&quot;, &quot;hide&quot;, function(options, done) {\r\n        var start,\r\n            animate = {},\r\n            element = $(this),\r\n            direction = options.direction || &quot;vertical&quot;,\r\n            both = direction === &quot;both&quot;,\r\n            horizontal = both || direction === &quot;horizontal&quot;,\r\n            vertical = both || direction === &quot;vertical&quot;;\r\n\r\n        start = element.cssClip();\r\n        animate.clip = {\r\n            top: vertical ? (start.bottom - start.top) \/ 2 : start.top,\r\n            right: horizontal ? (start.right - start.left) \/ 2 : start.right,\r\n            bottom: vertical ? (start.bottom - start.top) \/ 2 : start.bottom,\r\n            left: horizontal ? (start.right - start.left) \/ 2 : start.left\r\n        };\r\n\r\n        $.effects.createPlaceholder(element);\r\n\r\n        if (options.mode === &quot;show&quot;) {\r\n            element.cssClip(animate.clip);\r\n            animate.clip = start;\r\n        }\r\n\r\n        element.animate(animate, {\r\n            queue: false,\r\n            duration: options.duration,\r\n            easing: options.easing,\r\n            complete: done\r\n        });\r\n\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Drop 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Drop Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Moves an element in one direction and hides it at the same time.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/drop-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectDrop = $.effects.define(&quot;drop&quot;, &quot;hide&quot;, function(options, done) {\r\n\r\n        var distance,\r\n            element = $(this),\r\n            mode = options.mode,\r\n            show = mode === &quot;show&quot;,\r\n            direction = options.direction || &quot;left&quot;,\r\n            ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,\r\n            motion = (direction === &quot;up&quot; || direction === &quot;left&quot;) ? &quot;-=&quot; : &quot;+=&quot;,\r\n            oppositeMotion = (motion === &quot;+=&quot;) ? &quot;-=&quot; : &quot;+=&quot;,\r\n            animation = {\r\n                opacity: 0\r\n            };\r\n\r\n        $.effects.createPlaceholder(element);\r\n\r\n        distance = options.distance ||\r\n            element[ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot;](true) \/ 2;\r\n\r\n        animation[ref] = motion + distance;\r\n\r\n        if (show) {\r\n            element.css(animation);\r\n\r\n            animation[ref] = oppositeMotion + distance;\r\n            animation.opacity = 1;\r\n        }\r\n\r\n        \/\/ Animate\r\n        element.animate(animation, {\r\n            queue: false,\r\n            duration: options.duration,\r\n            easing: options.easing,\r\n            complete: done\r\n        });\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Explode 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Explode Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/* eslint-disable max-len *\/\r\n    \/\/&gt;&gt;description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.\r\n    \/* eslint-enable max-len *\/\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/explode-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectExplode = $.effects.define(&quot;explode&quot;, &quot;hide&quot;, function(options, done) {\r\n\r\n        var i, j, left, top, mx, my,\r\n            rows = options.pieces ? Math.round(Math.sqrt(options.pieces)) : 3,\r\n            cells = rows,\r\n            element = $(this),\r\n            mode = options.mode,\r\n            show = mode === &quot;show&quot;,\r\n\r\n            \/\/ Show and then visibility:hidden the element before calculating offset\r\n            offset = element.show().css(&quot;visibility&quot;, &quot;hidden&quot;).offset(),\r\n\r\n            \/\/ Width and height of a piece\r\n            width = Math.ceil(element.outerWidth() \/ cells),\r\n            height = Math.ceil(element.outerHeight() \/ rows),\r\n            pieces = [];\r\n\r\n        \/\/ Children animate complete:\r\n        function childComplete() {\r\n            pieces.push(this);\r\n            if (pieces.length === rows * cells) {\r\n                animComplete();\r\n            }\r\n        }\r\n\r\n        \/\/ Clone the element for each row and cell.\r\n        for (i = 0; i &lt; rows; i++) { \/\/ ===&gt;\r\n            top = offset.top + i * height;\r\n            my = i - (rows - 1) \/ 2;\r\n\r\n            for (j = 0; j &lt; cells; j++) { \/\/ |||\r\n                left = offset.left + j * width;\r\n                mx = j - (cells - 1) \/ 2;\r\n\r\n                \/\/ Create a clone of the now hidden main element that will be absolute positioned\r\n                \/\/ within a wrapper div off the -left and -top equal to size of our pieces\r\n                element\r\n                    .clone()\r\n                    .appendTo(&quot;body&quot;)\r\n                    .wrap(&quot;&lt;div&gt;&lt;\/div&gt;&quot;)\r\n                    .css({\r\n                        position: &quot;absolute&quot;,\r\n                        visibility: &quot;visible&quot;,\r\n                        left: -j * width,\r\n                        top: -i * height\r\n                    })\r\n\r\n                    \/\/ Select the wrapper - make it overflow: hidden and absolute positioned based on\r\n                    \/\/ where the original was located +left and +top equal to the size of pieces\r\n                    .parent()\r\n                    .addClass(&quot;ui-effects-explode&quot;)\r\n                    .css({\r\n                        position: &quot;absolute&quot;,\r\n                        overflow: &quot;hidden&quot;,\r\n                        width: width,\r\n                        height: height,\r\n                        left: left + (show ? mx * width : 0),\r\n                        top: top + (show ? my * height : 0),\r\n                        opacity: show ? 0 : 1\r\n                    })\r\n                    .animate({\r\n                        left: left + (show ? 0 : mx * width),\r\n                        top: top + (show ? 0 : my * height),\r\n                        opacity: show ? 1 : 0\r\n                    }, options.duration || 500, options.easing, childComplete);\r\n            }\r\n        }\r\n\r\n        function animComplete() {\r\n            element.css({\r\n                visibility: &quot;visible&quot;\r\n            });\r\n            $(pieces).remove();\r\n            done();\r\n        }\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Fade 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Fade Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Fades the element.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/fade-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectFade = $.effects.define(&quot;fade&quot;, &quot;toggle&quot;, function(options, done) {\r\n        var show = options.mode === &quot;show&quot;;\r\n\r\n        $(this)\r\n            .css(&quot;opacity&quot;, show ? 0 : 1)\r\n            .animate({\r\n                opacity: show ? 1 : 0\r\n            }, {\r\n                queue: false,\r\n                duration: options.duration,\r\n                easing: options.easing,\r\n                complete: done\r\n            });\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Fold 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Fold Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Folds an element first horizontally and then vertically.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/fold-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectFold = $.effects.define(&quot;fold&quot;, &quot;hide&quot;, function(options, done) {\r\n\r\n        \/\/ Create element\r\n        var element = $(this),\r\n            mode = options.mode,\r\n            show = mode === &quot;show&quot;,\r\n            hide = mode === &quot;hide&quot;,\r\n            size = options.size || 15,\r\n            percent = \/([0-9]+)%\/.exec(size),\r\n            horizFirst = !!options.horizFirst,\r\n            ref = horizFirst ? [&quot;right&quot;, &quot;bottom&quot;] : [&quot;bottom&quot;, &quot;right&quot;],\r\n            duration = options.duration \/ 2,\r\n\r\n            placeholder = $.effects.createPlaceholder(element),\r\n\r\n            start = element.cssClip(),\r\n            animation1 = {\r\n                clip: $.extend({}, start)\r\n            },\r\n            animation2 = {\r\n                clip: $.extend({}, start)\r\n            },\r\n\r\n            distance = [start[ref[0]], start[ref[1]]],\r\n\r\n            queuelen = element.queue().length;\r\n\r\n        if (percent) {\r\n            size = parseInt(percent[1], 10) \/ 100 * distance[hide ? 0 : 1];\r\n        }\r\n        animation1.clip[ref[0]] = size;\r\n        animation2.clip[ref[0]] = size;\r\n        animation2.clip[ref[1]] = 0;\r\n\r\n        if (show) {\r\n            element.cssClip(animation2.clip);\r\n            if (placeholder) {\r\n                placeholder.css($.effects.clipToBox(animation2));\r\n            }\r\n\r\n            animation2.clip = start;\r\n        }\r\n\r\n        \/\/ Animate\r\n        element\r\n            .queue(function(next) {\r\n                if (placeholder) {\r\n                    placeholder\r\n                        .animate($.effects.clipToBox(animation1), duration, options.easing)\r\n                        .animate($.effects.clipToBox(animation2), duration, options.easing);\r\n                }\r\n\r\n                next();\r\n            })\r\n            .animate(animation1, duration, options.easing)\r\n            .animate(animation2, duration, options.easing)\r\n            .queue(done);\r\n\r\n        $.effects.unshift(element, queuelen, 4);\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Highlight 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Highlight Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Highlights the background of an element in a defined color for a custom duration.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/highlight-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectHighlight = $.effects.define(&quot;highlight&quot;, &quot;show&quot;, function(options, done) {\r\n        var element = $(this),\r\n            animation = {\r\n                backgroundColor: element.css(&quot;backgroundColor&quot;)\r\n            };\r\n\r\n        if (options.mode === &quot;hide&quot;) {\r\n            animation.opacity = 0;\r\n        }\r\n\r\n        $.effects.saveStyle(element);\r\n\r\n        element\r\n            .css({\r\n                backgroundImage: &quot;none&quot;,\r\n                backgroundColor: options.color || &quot;#ffff99&quot;\r\n            })\r\n            .animate(animation, {\r\n                queue: false,\r\n                duration: options.duration,\r\n                easing: options.easing,\r\n                complete: done\r\n            });\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Size 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Size Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Resize an element to a specified width and height.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/size-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectSize = $.effects.define(&quot;size&quot;, function(options, done) {\r\n\r\n        \/\/ Create element\r\n        var baseline, factor, temp,\r\n            element = $(this),\r\n\r\n            \/\/ Copy for children\r\n            cProps = [&quot;fontSize&quot;],\r\n            vProps = [&quot;borderTopWidth&quot;, &quot;borderBottomWidth&quot;, &quot;paddingTop&quot;, &quot;paddingBottom&quot;],\r\n            hProps = [&quot;borderLeftWidth&quot;, &quot;borderRightWidth&quot;, &quot;paddingLeft&quot;, &quot;paddingRight&quot;],\r\n\r\n            \/\/ Set options\r\n            mode = options.mode,\r\n            restore = mode !== &quot;effect&quot;,\r\n            scale = options.scale || &quot;both&quot;,\r\n            origin = options.origin || [&quot;middle&quot;, &quot;center&quot;],\r\n            position = element.css(&quot;position&quot;),\r\n            pos = element.position(),\r\n            original = $.effects.scaledDimensions(element),\r\n            from = options.from || original,\r\n            to = options.to || $.effects.scaledDimensions(element, 0);\r\n\r\n        $.effects.createPlaceholder(element);\r\n\r\n        if (mode === &quot;show&quot;) {\r\n            temp = from;\r\n            from = to;\r\n            to = temp;\r\n        }\r\n\r\n        \/\/ Set scaling factor\r\n        factor = {\r\n            from: {\r\n                y: from.height \/ original.height,\r\n                x: from.width \/ original.width\r\n            },\r\n            to: {\r\n                y: to.height \/ original.height,\r\n                x: to.width \/ original.width\r\n            }\r\n        };\r\n\r\n        \/\/ Scale the css box\r\n        if (scale === &quot;box&quot; || scale === &quot;both&quot;) {\r\n\r\n            \/\/ Vertical props scaling\r\n            if (factor.from.y !== factor.to.y) {\r\n                from = $.effects.setTransition(element, vProps, factor.from.y, from);\r\n                to = $.effects.setTransition(element, vProps, factor.to.y, to);\r\n            }\r\n\r\n            \/\/ Horizontal props scaling\r\n            if (factor.from.x !== factor.to.x) {\r\n                from = $.effects.setTransition(element, hProps, factor.from.x, from);\r\n                to = $.effects.setTransition(element, hProps, factor.to.x, to);\r\n            }\r\n        }\r\n\r\n        \/\/ Scale the content\r\n        if (scale === &quot;content&quot; || scale === &quot;both&quot;) {\r\n\r\n            \/\/ Vertical props scaling\r\n            if (factor.from.y !== factor.to.y) {\r\n                from = $.effects.setTransition(element, cProps, factor.from.y, from);\r\n                to = $.effects.setTransition(element, cProps, factor.to.y, to);\r\n            }\r\n        }\r\n\r\n        \/\/ Adjust the position properties based on the provided origin points\r\n        if (origin) {\r\n            baseline = $.effects.getBaseline(origin, original);\r\n            from.top = (original.outerHeight - from.outerHeight) * baseline.y + pos.top;\r\n            from.left = (original.outerWidth - from.outerWidth) * baseline.x + pos.left;\r\n            to.top = (original.outerHeight - to.outerHeight) * baseline.y + pos.top;\r\n            to.left = (original.outerWidth - to.outerWidth) * baseline.x + pos.left;\r\n        }\r\n        delete from.outerHeight;\r\n        delete from.outerWidth;\r\n        element.css(from);\r\n\r\n        \/\/ Animate the children if desired\r\n        if (scale === &quot;content&quot; || scale === &quot;both&quot;) {\r\n\r\n            vProps = vProps.concat([&quot;marginTop&quot;, &quot;marginBottom&quot;]).concat(cProps);\r\n            hProps = hProps.concat([&quot;marginLeft&quot;, &quot;marginRight&quot;]);\r\n\r\n            \/\/ Only animate children with width attributes specified\r\n            \/\/ TODO: is this right? should we include anything with css width specified as well\r\n            element.find(&quot;*[width]&quot;).each(function() {\r\n                var child = $(this),\r\n                    childOriginal = $.effects.scaledDimensions(child),\r\n                    childFrom = {\r\n                        height: childOriginal.height * factor.from.y,\r\n                        width: childOriginal.width * factor.from.x,\r\n                        outerHeight: childOriginal.outerHeight * factor.from.y,\r\n                        outerWidth: childOriginal.outerWidth * factor.from.x\r\n                    },\r\n                    childTo = {\r\n                        height: childOriginal.height * factor.to.y,\r\n                        width: childOriginal.width * factor.to.x,\r\n                        outerHeight: childOriginal.height * factor.to.y,\r\n                        outerWidth: childOriginal.width * factor.to.x\r\n                    };\r\n\r\n                \/\/ Vertical props scaling\r\n                if (factor.from.y !== factor.to.y) {\r\n                    childFrom = $.effects.setTransition(child, vProps, factor.from.y, childFrom);\r\n                    childTo = $.effects.setTransition(child, vProps, factor.to.y, childTo);\r\n                }\r\n\r\n                \/\/ Horizontal props scaling\r\n                if (factor.from.x !== factor.to.x) {\r\n                    childFrom = $.effects.setTransition(child, hProps, factor.from.x, childFrom);\r\n                    childTo = $.effects.setTransition(child, hProps, factor.to.x, childTo);\r\n                }\r\n\r\n                if (restore) {\r\n                    $.effects.saveStyle(child);\r\n                }\r\n\r\n                \/\/ Animate children\r\n                child.css(childFrom);\r\n                child.animate(childTo, options.duration, options.easing, function() {\r\n\r\n                    \/\/ Restore children\r\n                    if (restore) {\r\n                        $.effects.restoreStyle(child);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        \/\/ Animate\r\n        element.animate(to, {\r\n            queue: false,\r\n            duration: options.duration,\r\n            easing: options.easing,\r\n            complete: function() {\r\n\r\n                var offset = element.offset();\r\n\r\n                if (to.opacity === 0) {\r\n                    element.css(&quot;opacity&quot;, from.opacity);\r\n                }\r\n\r\n                if (!restore) {\r\n                    element\r\n                        .css(&quot;position&quot;, position === &quot;static&quot; ? &quot;relative&quot; : position)\r\n                        .offset(offset);\r\n\r\n                    \/\/ Need to save style here so that automatic style restoration\r\n                    \/\/ doesn&#039;t restore to the original styles from before the animation.\r\n                    $.effects.saveStyle(element);\r\n                }\r\n\r\n                done();\r\n            }\r\n        });\r\n\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Scale 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Scale Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Grows or shrinks an element and its content.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/scale-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectScale = $.effects.define(&quot;scale&quot;, function(options, done) {\r\n\r\n        \/\/ Create element\r\n        var el = $(this),\r\n            mode = options.mode,\r\n            percent = parseInt(options.percent, 10) ||\r\n            (parseInt(options.percent, 10) === 0 ? 0 : (mode !== &quot;effect&quot; ? 0 : 100)),\r\n\r\n            newOptions = $.extend(true, {\r\n                from: $.effects.scaledDimensions(el),\r\n                to: $.effects.scaledDimensions(el, percent, options.direction || &quot;both&quot;),\r\n                origin: options.origin || [&quot;middle&quot;, &quot;center&quot;]\r\n            }, options);\r\n\r\n        \/\/ Fade option to support puff\r\n        if (options.fade) {\r\n            newOptions.from.opacity = 1;\r\n            newOptions.to.opacity = 0;\r\n        }\r\n\r\n        $.effects.effect.size.call(this, newOptions, done);\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Puff 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Puff Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Creates a puff effect by scaling the element up and hiding it at the same time.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/puff-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectPuff = $.effects.define(&quot;puff&quot;, &quot;hide&quot;, function(options, done) {\r\n        var newOptions = $.extend(true, {}, options, {\r\n            fade: true,\r\n            percent: parseInt(options.percent, 10) || 150\r\n        });\r\n\r\n        $.effects.effect.scale.call(this, newOptions, done);\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Pulsate 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Pulsate Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Pulsates an element n times by changing the opacity to zero and back.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/pulsate-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectPulsate = $.effects.define(&quot;pulsate&quot;, &quot;show&quot;, function(options, done) {\r\n        var element = $(this),\r\n            mode = options.mode,\r\n            show = mode === &quot;show&quot;,\r\n            hide = mode === &quot;hide&quot;,\r\n            showhide = show || hide,\r\n\r\n            \/\/ Showing or hiding leaves off the &quot;last&quot; animation\r\n            anims = ((options.times || 5) * 2) + (showhide ? 1 : 0),\r\n            duration = options.duration \/ anims,\r\n            animateTo = 0,\r\n            i = 1,\r\n            queuelen = element.queue().length;\r\n\r\n        if (show || !element.is(&quot;:visible&quot;)) {\r\n            element.css(&quot;opacity&quot;, 0).show();\r\n            animateTo = 1;\r\n        }\r\n\r\n        \/\/ Anims - 1 opacity &quot;toggles&quot;\r\n        for (; i &lt; anims; i++) {\r\n            element.animate({\r\n                opacity: animateTo\r\n            }, duration, options.easing);\r\n            animateTo = 1 - animateTo;\r\n        }\r\n\r\n        element.animate({\r\n            opacity: animateTo\r\n        }, duration, options.easing);\r\n\r\n        element.queue(done);\r\n\r\n        $.effects.unshift(element, queuelen, anims + 1);\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Shake 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Shake Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Shakes an element horizontally or vertically n times.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/shake-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectShake = $.effects.define(&quot;shake&quot;, function(options, done) {\r\n\r\n        var i = 1,\r\n            element = $(this),\r\n            direction = options.direction || &quot;left&quot;,\r\n            distance = options.distance || 20,\r\n            times = options.times || 3,\r\n            anims = times * 2 + 1,\r\n            speed = Math.round(options.duration \/ anims),\r\n            ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,\r\n            positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),\r\n            animation = {},\r\n            animation1 = {},\r\n            animation2 = {},\r\n\r\n            queuelen = element.queue().length;\r\n\r\n        $.effects.createPlaceholder(element);\r\n\r\n        \/\/ Animation\r\n        animation[ref] = (positiveMotion ? &quot;-=&quot; : &quot;+=&quot;) + distance;\r\n        animation1[ref] = (positiveMotion ? &quot;+=&quot; : &quot;-=&quot;) + distance * 2;\r\n        animation2[ref] = (positiveMotion ? &quot;-=&quot; : &quot;+=&quot;) + distance * 2;\r\n\r\n        \/\/ Animate\r\n        element.animate(animation, speed, options.easing);\r\n\r\n        \/\/ Shakes\r\n        for (; i &lt; times; i++) {\r\n            element\r\n                .animate(animation1, speed, options.easing)\r\n                .animate(animation2, speed, options.easing);\r\n        }\r\n\r\n        element\r\n            .animate(animation1, speed, options.easing)\r\n            .animate(animation, speed \/ 2, options.easing)\r\n            .queue(done);\r\n\r\n        $.effects.unshift(element, queuelen, anims + 1);\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Slide 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Slide Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Slides an element in and out of the viewport.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/slide-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effectsEffectSlide = $.effects.define(&quot;slide&quot;, &quot;show&quot;, function(options, done) {\r\n        var startClip, startRef,\r\n            element = $(this),\r\n            map = {\r\n                up: [&quot;bottom&quot;, &quot;top&quot;],\r\n                down: [&quot;top&quot;, &quot;bottom&quot;],\r\n                left: [&quot;right&quot;, &quot;left&quot;],\r\n                right: [&quot;left&quot;, &quot;right&quot;]\r\n            },\r\n            mode = options.mode,\r\n            direction = options.direction || &quot;left&quot;,\r\n            ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,\r\n            positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),\r\n            distance = options.distance ||\r\n            element[ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot;](true),\r\n            animation = {};\r\n\r\n        $.effects.createPlaceholder(element);\r\n\r\n        startClip = element.cssClip();\r\n        startRef = element.position()[ref];\r\n\r\n        \/\/ Define hide animation\r\n        animation[ref] = (positiveMotion ? -1 : 1) * distance + startRef;\r\n        animation.clip = element.cssClip();\r\n        animation.clip[map[direction][1]] = animation.clip[map[direction][0]];\r\n\r\n        \/\/ Reverse the animation if we&#039;re showing\r\n        if (mode === &quot;show&quot;) {\r\n            element.cssClip(animation.clip);\r\n            element.css(ref, animation[ref]);\r\n            animation.clip = startClip;\r\n            animation[ref] = startRef;\r\n        }\r\n\r\n        \/\/ Actually animate\r\n        element.animate(animation, {\r\n            queue: false,\r\n            duration: options.duration,\r\n            easing: options.easing,\r\n            complete: done\r\n        });\r\n    });\r\n\r\n\r\n    \/*!\r\n     * jQuery UI Effects Transfer 1.14.1\r\n     * https:\/\/jqueryui.com\r\n     *\r\n     * Copyright OpenJS Foundation and other contributors\r\n     * Released under the MIT license.\r\n     * https:\/\/jquery.org\/license\r\n     *\/\r\n\r\n    \/\/&gt;&gt;label: Transfer Effect\r\n    \/\/&gt;&gt;group: Effects\r\n    \/\/&gt;&gt;description: Displays a transfer effect from one element to another.\r\n    \/\/&gt;&gt;docs: https:\/\/api.jqueryui.com\/transfer-effect\/\r\n    \/\/&gt;&gt;demos: https:\/\/jqueryui.com\/effect\/\r\n\r\n\r\n    var effect;\r\n    if ($.uiBackCompat === true) {\r\n        effect = $.effects.define(&quot;transfer&quot;, function(options, done) {\r\n            $(this).transfer(options, done);\r\n        });\r\n    }\r\n    var effectsEffectTransfer = effect;\r\n\r\n\r\n\r\n\r\n});","Category":"Extension","Chats":[],"Created":"2025-04-12 09:33:16AM","Description":"User Interface enhancements for jQuery.","Forums":[],"ForumPosts":[],"Members":[],"Modified":"2025-04-12 09:33:16AM","ModifiedBy":{"2025-04-12 09:33:16AM":"Mike"},"Polls":[],"Products":[],"Purge":0,"Shops":[],"Title":"App: jQuery UI","UN":"Mike","Updates":[]}