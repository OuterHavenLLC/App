{"Albums":[],"Articles":[],"Attachments":[],"Blogs":[],"BlogPosts":[],"Body":"\/**\r\n * Skipped minification because the original files appears to be already minified.\r\n * Original file: \/npm\/chart.js@4.4.3\/dist\/chart.umd.js\r\n *\r\n * Do NOT use SRI with dynamically generated files! More information: https:\/\/www.jsdelivr.com\/using-sri-with-dynamic-files\r\n *\/\r\n\/*!\r\n * Chart.js v4.4.3\r\n * https:\/\/www.chartjs.org\r\n * (c) 2024 Chart.js Contributors\r\n * Released under the MIT License\r\n *\/\r\n! function(t, e) {\r\n  &quot;object&quot; == typeof exports &amp;&amp; &quot;undefined&quot; != typeof module ? module.exports = e() : &quot;function&quot; == typeof define &amp;&amp; define.amd ? define(e) : (t = &quot;undefined&quot; != typeof globalThis ? globalThis : t || self).Chart = e()\r\n}(this, (function() {\r\n  &quot;use strict&quot;;\r\n  var t = Object.freeze({\r\n    __proto__: null,\r\n    get Colors() {\r\n      return Go\r\n    },\r\n    get Decimation() {\r\n      return Qo\r\n    },\r\n    get Filler() {\r\n      return ma\r\n    },\r\n    get Legend() {\r\n      return ya\r\n    },\r\n    get SubTitle() {\r\n      return ka\r\n    },\r\n    get Title() {\r\n      return Ma\r\n    },\r\n    get Tooltip() {\r\n      return Ba\r\n    }\r\n  });\r\n\r\n  function e() {}\r\n  const i = (() =&gt; {\r\n    let t = 0;\r\n    return () =&gt; t++\r\n  })();\r\n\r\n  function s(t) {\r\n    return null == t\r\n  }\r\n\r\n  function n(t) {\r\n    if (Array.isArray &amp;&amp; Array.isArray(t)) return !0;\r\n    const e = Object.prototype.toString.call(t);\r\n    return &quot;[object&quot; === e.slice(0, 7) &amp;&amp; &quot;Array]&quot; === e.slice(-6)\r\n  }\r\n\r\n  function o(t) {\r\n    return null !== t &amp;&amp; &quot;[object Object]&quot; === Object.prototype.toString.call(t)\r\n  }\r\n\r\n  function a(t) {\r\n    return (&quot;number&quot; == typeof t || t instanceof Number) &amp;&amp; isFinite(+t)\r\n  }\r\n\r\n  function r(t, e) {\r\n    return a(t) ? t : e\r\n  }\r\n\r\n  function l(t, e) {\r\n    return void 0 === t ? e : t\r\n  }\r\n  const h = (t, e) =&gt; &quot;string&quot; == typeof t &amp;&amp; t.endsWith(&quot;%&quot;) ? parseFloat(t) \/ 100 : +t \/ e,\r\n    c = (t, e) =&gt; &quot;string&quot; == typeof t &amp;&amp; t.endsWith(&quot;%&quot;) ? parseFloat(t) \/ 100 * e : +t;\r\n\r\n  function d(t, e, i) {\r\n    if (t &amp;&amp; &quot;function&quot; == typeof t.call) return t.apply(i, e)\r\n  }\r\n\r\n  function u(t, e, i, s) {\r\n    let a, r, l;\r\n    if (n(t))\r\n      if (r = t.length, s)\r\n        for (a = r - 1; a &gt;= 0; a--) e.call(i, t[a], a);\r\n      else\r\n        for (a = 0; a &lt; r; a++) e.call(i, t[a], a);\r\n    else if (o(t))\r\n      for (l = Object.keys(t), r = l.length, a = 0; a &lt; r; a++) e.call(i, t[l[a]], l[a])\r\n  }\r\n\r\n  function f(t, e) {\r\n    let i, s, n, o;\r\n    if (!t || !e || t.length !== e.length) return !1;\r\n    for (i = 0, s = t.length; i &lt; s; ++i)\r\n      if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\r\n    return !0\r\n  }\r\n\r\n  function g(t) {\r\n    if (n(t)) return t.map(g);\r\n    if (o(t)) {\r\n      const e = Object.create(null),\r\n        i = Object.keys(t),\r\n        s = i.length;\r\n      let n = 0;\r\n      for (; n &lt; s; ++n) e[i[n]] = g(t[i[n]]);\r\n      return e\r\n    }\r\n    return t\r\n  }\r\n\r\n  function p(t) {\r\n    return -1 === [&quot;__proto__&quot;, &quot;prototype&quot;, &quot;constructor&quot;].indexOf(t)\r\n  }\r\n\r\n  function m(t, e, i, s) {\r\n    if (!p(t)) return;\r\n    const n = e[t],\r\n      a = i[t];\r\n    o(n) &amp;&amp; o(a) ? x(n, a, s) : e[t] = g(a)\r\n  }\r\n\r\n  function x(t, e, i) {\r\n    const s = n(e) ? e : [e],\r\n      a = s.length;\r\n    if (!o(t)) return t;\r\n    const r = (i = i || {}).merger || m;\r\n    let l;\r\n    for (let e = 0; e &lt; a; ++e) {\r\n      if (l = s[e], !o(l)) continue;\r\n      const n = Object.keys(l);\r\n      for (let e = 0, s = n.length; e &lt; s; ++e) r(n[e], t, l, i)\r\n    }\r\n    return t\r\n  }\r\n\r\n  function b(t, e) {\r\n    return x(t, e, {\r\n      merger: _\r\n    })\r\n  }\r\n\r\n  function _(t, e, i) {\r\n    if (!p(t)) return;\r\n    const s = e[t],\r\n      n = i[t];\r\n    o(s) &amp;&amp; o(n) ? b(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n))\r\n  }\r\n  const y = {\r\n    &quot;&quot;: t =&gt; t,\r\n    x: t =&gt; t.x,\r\n    y: t =&gt; t.y\r\n  };\r\n\r\n  function v(t) {\r\n    const e = t.split(&quot;.&quot;),\r\n      i = [];\r\n    let s = &quot;&quot;;\r\n    for (const t of e) s += t, s.endsWith(&quot;\\\\&quot;) ? s = s.slice(0, -1) + &quot;.&quot; : (i.push(s), s = &quot;&quot;);\r\n    return i\r\n  }\r\n\r\n  function M(t, e) {\r\n    const i = y[e] || (y[e] = function(t) {\r\n      const e = v(t);\r\n      return t =&gt; {\r\n        for (const i of e) {\r\n          if (&quot;&quot; === i) break;\r\n          t = t &amp;&amp; t[i]\r\n        }\r\n        return t\r\n      }\r\n    }(e));\r\n    return i(t)\r\n  }\r\n\r\n  function w(t) {\r\n    return t.charAt(0).toUpperCase() + t.slice(1)\r\n  }\r\n  const k = t =&gt; void 0 !== t,\r\n    S = t =&gt; &quot;function&quot; == typeof t,\r\n    P = (t, e) =&gt; {\r\n      if (t.size !== e.size) return !1;\r\n      for (const i of t)\r\n        if (!e.has(i)) return !1;\r\n      return !0\r\n    };\r\n\r\n  function D(t) {\r\n    return &quot;mouseup&quot; === t.type || &quot;click&quot; === t.type || &quot;contextmenu&quot; === t.type\r\n  }\r\n  const C = Math.PI,\r\n    O = 2 * C,\r\n    A = O + C,\r\n    T = Number.POSITIVE_INFINITY,\r\n    L = C \/ 180,\r\n    E = C \/ 2,\r\n    R = C \/ 4,\r\n    I = 2 * C \/ 3,\r\n    z = Math.log10,\r\n    F = Math.sign;\r\n\r\n  function V(t, e, i) {\r\n    return Math.abs(t - e) &lt; i\r\n  }\r\n\r\n  function B(t) {\r\n    const e = Math.round(t);\r\n    t = V(t, e, t \/ 1e3) ? e : t;\r\n    const i = Math.pow(10, Math.floor(z(t))),\r\n      s = t \/ i;\r\n    return (s &lt;= 1 ? 1 : s &lt;= 2 ? 2 : s &lt;= 5 ? 5 : 10) * i\r\n  }\r\n\r\n  function W(t) {\r\n    const e = [],\r\n      i = Math.sqrt(t);\r\n    let s;\r\n    for (s = 1; s &lt; i; s++) t % s == 0 &amp;&amp; (e.push(s), e.push(t \/ s));\r\n    return i === (0 | i) &amp;&amp; e.push(i), e.sort(((t, e) =&gt; t - e)).pop(), e\r\n  }\r\n\r\n  function N(t) {\r\n    return !isNaN(parseFloat(t)) &amp;&amp; isFinite(t)\r\n  }\r\n\r\n  function H(t, e) {\r\n    const i = Math.round(t);\r\n    return i - e &lt;= t &amp;&amp; i + e &gt;= t\r\n  }\r\n\r\n  function j(t, e, i) {\r\n    let s, n, o;\r\n    for (s = 0, n = t.length; s &lt; n; s++) o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o))\r\n  }\r\n\r\n  function $(t) {\r\n    return t * (C \/ 180)\r\n  }\r\n\r\n  function Y(t) {\r\n    return t * (180 \/ C)\r\n  }\r\n\r\n  function U(t) {\r\n    if (!a(t)) return;\r\n    let e = 1,\r\n      i = 0;\r\n    for (; Math.round(t * e) \/ e !== t;) e *= 10, i++;\r\n    return i\r\n  }\r\n\r\n  function X(t, e) {\r\n    const i = e.x - t.x,\r\n      s = e.y - t.y,\r\n      n = Math.sqrt(i * i + s * s);\r\n    let o = Math.atan2(s, i);\r\n    return o &lt; -.5 * C &amp;&amp; (o += O), {\r\n      angle: o,\r\n      distance: n\r\n    }\r\n  }\r\n\r\n  function q(t, e) {\r\n    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))\r\n  }\r\n\r\n  function K(t, e) {\r\n    return (t - e + A) % O - C\r\n  }\r\n\r\n  function G(t) {\r\n    return (t % O + O) % O\r\n  }\r\n\r\n  function Z(t, e, i, s) {\r\n    const n = G(t),\r\n      o = G(e),\r\n      a = G(i),\r\n      r = G(o - n),\r\n      l = G(a - n),\r\n      h = G(n - o),\r\n      c = G(n - a);\r\n    return n === o || n === a || s &amp;&amp; o === a || r &gt; l &amp;&amp; h &lt; c\r\n  }\r\n\r\n  function J(t, e, i) {\r\n    return Math.max(e, Math.min(i, t))\r\n  }\r\n\r\n  function Q(t) {\r\n    return J(t, -32768, 32767)\r\n  }\r\n\r\n  function tt(t, e, i, s = 1e-6) {\r\n    return t &gt;= Math.min(e, i) - s &amp;&amp; t &lt;= Math.max(e, i) + s\r\n  }\r\n\r\n  function et(t, e, i) {\r\n    i = i || (i =&gt; t[i] &lt; e);\r\n    let s, n = t.length - 1,\r\n      o = 0;\r\n    for (; n - o &gt; 1;) s = o + n &gt;&gt; 1, i(s) ? o = s : n = s;\r\n    return {\r\n      lo: o,\r\n      hi: n\r\n    }\r\n  }\r\n  const it = (t, e, i, s) =&gt; et(t, i, s ? s =&gt; {\r\n      const n = t[s][e];\r\n      return n &lt; i || n === i &amp;&amp; t[s + 1][e] === i\r\n    } : s =&gt; t[s][e] &lt; i),\r\n    st = (t, e, i) =&gt; et(t, i, (s =&gt; t[s][e] &gt;= i));\r\n\r\n  function nt(t, e, i) {\r\n    let s = 0,\r\n      n = t.length;\r\n    for (; s &lt; n &amp;&amp; t[s] &lt; e;) s++;\r\n    for (; n &gt; s &amp;&amp; t[n - 1] &gt; i;) n--;\r\n    return s &gt; 0 || n &lt; t.length ? t.slice(s, n) : t\r\n  }\r\n  const ot = [&quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;splice&quot;, &quot;unshift&quot;];\r\n\r\n  function at(t, e) {\r\n    t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, &quot;_chartjs&quot;, {\r\n      configurable: !0,\r\n      enumerable: !1,\r\n      value: {\r\n        listeners: [e]\r\n      }\r\n    }), ot.forEach((e =&gt; {\r\n      const i = &quot;_onData&quot; + w(e),\r\n        s = t[e];\r\n      Object.defineProperty(t, e, {\r\n        configurable: !0,\r\n        enumerable: !1,\r\n        value(...e) {\r\n          const n = s.apply(this, e);\r\n          return t._chartjs.listeners.forEach((t =&gt; {\r\n            &quot;function&quot; == typeof t[i] &amp;&amp; t[i](...e)\r\n          })), n\r\n        }\r\n      })\r\n    })))\r\n  }\r\n\r\n  function rt(t, e) {\r\n    const i = t._chartjs;\r\n    if (!i) return;\r\n    const s = i.listeners,\r\n      n = s.indexOf(e); - 1 !== n &amp;&amp; s.splice(n, 1), s.length &gt; 0 || (ot.forEach((e =&gt; {\r\n      delete t[e]\r\n    })), delete t._chartjs)\r\n  }\r\n\r\n  function lt(t) {\r\n    const e = new Set(t);\r\n    return e.size === t.length ? t : Array.from(e)\r\n  }\r\n  const ht = &quot;undefined&quot; == typeof window ? function(t) {\r\n    return t()\r\n  } : window.requestAnimationFrame;\r\n\r\n  function ct(t, e) {\r\n    let i = [],\r\n      s = !1;\r\n    return function(...n) {\r\n      i = n, s || (s = !0, ht.call(window, (() =&gt; {\r\n        s = !1, t.apply(e, i)\r\n      })))\r\n    }\r\n  }\r\n\r\n  function dt(t, e) {\r\n    let i;\r\n    return function(...s) {\r\n      return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e\r\n    }\r\n  }\r\n  const ut = t =&gt; &quot;start&quot; === t ? &quot;left&quot; : &quot;end&quot; === t ? &quot;right&quot; : &quot;center&quot;,\r\n    ft = (t, e, i) =&gt; &quot;start&quot; === t ? e : &quot;end&quot; === t ? i : (e + i) \/ 2,\r\n    gt = (t, e, i, s) =&gt; t === (s ? &quot;left&quot; : &quot;right&quot;) ? i : &quot;center&quot; === t ? (e + i) \/ 2 : e;\r\n\r\n  function pt(t, e, i) {\r\n    const s = e.length;\r\n    let n = 0,\r\n      o = s;\r\n    if (t._sorted) {\r\n      const {\r\n        iScale: a,\r\n        _parsed: r\r\n      } = t, l = a.axis, {\r\n        min: h,\r\n        max: c,\r\n        minDefined: d,\r\n        maxDefined: u\r\n      } = a.getUserBounds();\r\n      d &amp;&amp; (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n\r\n    }\r\n    return {\r\n      start: n,\r\n      count: o\r\n    }\r\n  }\r\n\r\n  function mt(t) {\r\n    const {\r\n      xScale: e,\r\n      yScale: i,\r\n      _scaleRanges: s\r\n    } = t, n = {\r\n      xmin: e.min,\r\n      xmax: e.max,\r\n      ymin: i.min,\r\n      ymax: i.max\r\n    };\r\n    if (!s) return t._scaleRanges = n, !0;\r\n    const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;\r\n    return Object.assign(s, n), o\r\n  }\r\n  class xt {\r\n    constructor() {\r\n      this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0\r\n    }\r\n    _notify(t, e, i, s) {\r\n      const n = e.listeners[s],\r\n        o = e.duration;\r\n      n.forEach((s =&gt; s({\r\n        chart: t,\r\n        initial: e.initial,\r\n        numSteps: o,\r\n        currentStep: Math.min(i - e.start, o)\r\n      })))\r\n    }\r\n    _refresh() {\r\n      this._request || (this._running = !0, this._request = ht.call(window, (() =&gt; {\r\n        this._update(), this._request = null, this._running &amp;&amp; this._refresh()\r\n      })))\r\n    }\r\n    _update(t = Date.now()) {\r\n      let e = 0;\r\n      this._charts.forEach(((i, s) =&gt; {\r\n        if (!i.running || !i.items.length) return;\r\n        const n = i.items;\r\n        let o, a = n.length - 1,\r\n          r = !1;\r\n        for (; a &gt;= 0; --a) o = n[a], o._active ? (o._total &gt; i.duration &amp;&amp; (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());\r\n        r &amp;&amp; (s.draw(), this._notify(s, i, t, &quot;progress&quot;)), n.length || (i.running = !1, this._notify(s, i, t, &quot;complete&quot;), i.initial = !1), e += n.length\r\n      })), this._lastDate = t, 0 === e &amp;&amp; (this._running = !1)\r\n    }\r\n    _getAnims(t) {\r\n      const e = this._charts;\r\n      let i = e.get(t);\r\n      return i || (i = {\r\n        running: !1,\r\n        initial: !0,\r\n        items: [],\r\n        listeners: {\r\n          complete: [],\r\n          progress: []\r\n        }\r\n      }, e.set(t, i)), i\r\n    }\r\n    listen(t, e, i) {\r\n      this._getAnims(t).listeners[e].push(i)\r\n    }\r\n    add(t, e) {\r\n      e &amp;&amp; e.length &amp;&amp; this._getAnims(t).items.push(...e)\r\n    }\r\n    has(t) {\r\n      return this._getAnims(t).items.length &gt; 0\r\n    }\r\n    start(t) {\r\n      const e = this._charts.get(t);\r\n      e &amp;&amp; (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) =&gt; Math.max(t, e._duration)), 0), this._refresh())\r\n    }\r\n    running(t) {\r\n      if (!this._running) return !1;\r\n      const e = this._charts.get(t);\r\n      return !!(e &amp;&amp; e.running &amp;&amp; e.items.length)\r\n    }\r\n    stop(t) {\r\n      const e = this._charts.get(t);\r\n      if (!e || !e.items.length) return;\r\n      const i = e.items;\r\n      let s = i.length - 1;\r\n      for (; s &gt;= 0; --s) i[s].cancel();\r\n      e.items = [], this._notify(t, e, Date.now(), &quot;complete&quot;)\r\n    }\r\n    remove(t) {\r\n      return this._charts.delete(t)\r\n    }\r\n  }\r\n  var bt = new xt;\r\n  \/*!\r\n   * @kurkle\/color v0.3.2\r\n   * https:\/\/github.com\/kurkle\/color#readme\r\n   * (c) 2023 Jukka Kurkela\r\n   * Released under the MIT License\r\n   *\/\r\n  function _t(t) {\r\n    return t + .5 | 0\r\n  }\r\n  const yt = (t, e, i) =&gt; Math.max(Math.min(t, i), e);\r\n\r\n  function vt(t) {\r\n    return yt(_t(2.55 * t), 0, 255)\r\n  }\r\n\r\n  function Mt(t) {\r\n    return yt(_t(255 * t), 0, 255)\r\n  }\r\n\r\n  function wt(t) {\r\n    return yt(_t(t \/ 2.55) \/ 100, 0, 1)\r\n  }\r\n\r\n  function kt(t) {\r\n    return yt(_t(100 * t), 0, 100)\r\n  }\r\n  const St = {\r\n      0: 0,\r\n      1: 1,\r\n      2: 2,\r\n      3: 3,\r\n      4: 4,\r\n      5: 5,\r\n      6: 6,\r\n      7: 7,\r\n      8: 8,\r\n      9: 9,\r\n      A: 10,\r\n      B: 11,\r\n      C: 12,\r\n      D: 13,\r\n      E: 14,\r\n      F: 15,\r\n      a: 10,\r\n      b: 11,\r\n      c: 12,\r\n      d: 13,\r\n      e: 14,\r\n      f: 15\r\n    },\r\n    Pt = [...&quot;0123456789ABCDEF&quot;],\r\n    Dt = t =&gt; Pt[15 &amp; t],\r\n    Ct = t =&gt; Pt[(240 &amp; t) &gt;&gt; 4] + Pt[15 &amp; t],\r\n    Ot = t =&gt; (240 &amp; t) &gt;&gt; 4 == (15 &amp; t);\r\n\r\n  function At(t) {\r\n    var e = (t =&gt; Ot(t.r) &amp;&amp; Ot(t.g) &amp;&amp; Ot(t.b) &amp;&amp; Ot(t.a))(t) ? Dt : Ct;\r\n    return t ? &quot;#&quot; + e(t.r) + e(t.g) + e(t.b) + ((t, e) =&gt; t &lt; 255 ? e(t) : &quot;&quot;)(t.a, e) : void 0\r\n  }\r\n  const Tt = \/^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$\/;\r\n\r\n  function Lt(t, e, i) {\r\n    const s = e * Math.min(i, 1 - i),\r\n      n = (e, n = (e + t \/ 30) % 12) =&gt; i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);\r\n    return [n(0), n(8), n(4)]\r\n  }\r\n\r\n  function Et(t, e, i) {\r\n    const s = (s, n = (s + t \/ 60) % 6) =&gt; i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);\r\n    return [s(5), s(3), s(1)]\r\n  }\r\n\r\n  function Rt(t, e, i) {\r\n    const s = Lt(t, 1, .5);\r\n    let n;\r\n    for (e + i &gt; 1 &amp;&amp; (n = 1 \/ (e + i), e *= n, i *= n), n = 0; n &lt; 3; n++) s[n] *= 1 - e - i, s[n] += e;\r\n    return s\r\n  }\r\n\r\n  function It(t) {\r\n    const e = t.r \/ 255,\r\n      i = t.g \/ 255,\r\n      s = t.b \/ 255,\r\n      n = Math.max(e, i, s),\r\n      o = Math.min(e, i, s),\r\n      a = (n + o) \/ 2;\r\n    let r, l, h;\r\n    return n !== o &amp;&amp; (h = n - o, l = a &gt; .5 ? h \/ (2 - n - o) : h \/ (n + o), r = function(t, e, i, s, n) {\r\n      return t === n ? (e - i) \/ s + (e &lt; i ? 6 : 0) : e === n ? (i - t) \/ s + 2 : (t - e) \/ s + 4\r\n    }(e, i, s, h, n), r = 60 * r + .5), [0 | r, l || 0, a]\r\n  }\r\n\r\n  function zt(t, e, i, s) {\r\n    return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt)\r\n  }\r\n\r\n  function Ft(t, e, i) {\r\n    return zt(Lt, t, e, i)\r\n  }\r\n\r\n  function Vt(t) {\r\n    return (t % 360 + 360) % 360\r\n  }\r\n\r\n  function Bt(t) {\r\n    const e = Tt.exec(t);\r\n    let i, s = 255;\r\n    if (!e) return;\r\n    e[5] !== i &amp;&amp; (s = e[6] ? vt(+e[5]) : Mt(+e[5]));\r\n    const n = Vt(+e[2]),\r\n      o = +e[3] \/ 100,\r\n      a = +e[4] \/ 100;\r\n    return i = &quot;hwb&quot; === e[1] ? function(t, e, i) {\r\n      return zt(Rt, t, e, i)\r\n    }(n, o, a) : &quot;hsv&quot; === e[1] ? function(t, e, i) {\r\n      return zt(Et, t, e, i)\r\n    }(n, o, a) : Ft(n, o, a), {\r\n      r: i[0],\r\n      g: i[1],\r\n      b: i[2],\r\n      a: s\r\n    }\r\n  }\r\n  const Wt = {\r\n      x: &quot;dark&quot;,\r\n      Z: &quot;light&quot;,\r\n      Y: &quot;re&quot;,\r\n      X: &quot;blu&quot;,\r\n      W: &quot;gr&quot;,\r\n      V: &quot;medium&quot;,\r\n      U: &quot;slate&quot;,\r\n      A: &quot;ee&quot;,\r\n      T: &quot;ol&quot;,\r\n      S: &quot;or&quot;,\r\n      B: &quot;ra&quot;,\r\n      C: &quot;lateg&quot;,\r\n      D: &quot;ights&quot;,\r\n      R: &quot;in&quot;,\r\n      Q: &quot;turquois&quot;,\r\n      E: &quot;hi&quot;,\r\n      P: &quot;ro&quot;,\r\n      O: &quot;al&quot;,\r\n      N: &quot;le&quot;,\r\n      M: &quot;de&quot;,\r\n      L: &quot;yello&quot;,\r\n      F: &quot;en&quot;,\r\n      K: &quot;ch&quot;,\r\n      G: &quot;arks&quot;,\r\n      H: &quot;ea&quot;,\r\n      I: &quot;ightg&quot;,\r\n      J: &quot;wh&quot;\r\n    },\r\n    Nt = {\r\n      OiceXe: &quot;f0f8ff&quot;,\r\n      antiquewEte: &quot;faebd7&quot;,\r\n      aqua: &quot;ffff&quot;,\r\n      aquamarRe: &quot;7fffd4&quot;,\r\n      azuY: &quot;f0ffff&quot;,\r\n      beige: &quot;f5f5dc&quot;,\r\n      bisque: &quot;ffe4c4&quot;,\r\n      black: &quot;0&quot;,\r\n      blanKedOmond: &quot;ffebcd&quot;,\r\n      Xe: &quot;ff&quot;,\r\n      XeviTet: &quot;8a2be2&quot;,\r\n      bPwn: &quot;a52a2a&quot;,\r\n      burlywood: &quot;deb887&quot;,\r\n      caMtXe: &quot;5f9ea0&quot;,\r\n      KartYuse: &quot;7fff00&quot;,\r\n      KocTate: &quot;d2691e&quot;,\r\n      cSO: &quot;ff7f50&quot;,\r\n      cSnflowerXe: &quot;6495ed&quot;,\r\n      cSnsilk: &quot;fff8dc&quot;,\r\n      crimson: &quot;dc143c&quot;,\r\n      cyan: &quot;ffff&quot;,\r\n      xXe: &quot;8b&quot;,\r\n      xcyan: &quot;8b8b&quot;,\r\n      xgTMnPd: &quot;b8860b&quot;,\r\n      xWay: &quot;a9a9a9&quot;,\r\n      xgYF: &quot;6400&quot;,\r\n      xgYy: &quot;a9a9a9&quot;,\r\n      xkhaki: &quot;bdb76b&quot;,\r\n      xmagFta: &quot;8b008b&quot;,\r\n      xTivegYF: &quot;556b2f&quot;,\r\n      xSange: &quot;ff8c00&quot;,\r\n      xScEd: &quot;9932cc&quot;,\r\n      xYd: &quot;8b0000&quot;,\r\n      xsOmon: &quot;e9967a&quot;,\r\n      xsHgYF: &quot;8fbc8f&quot;,\r\n      xUXe: &quot;483d8b&quot;,\r\n      xUWay: &quot;2f4f4f&quot;,\r\n      xUgYy: &quot;2f4f4f&quot;,\r\n      xQe: &quot;ced1&quot;,\r\n      xviTet: &quot;9400d3&quot;,\r\n      dAppRk: &quot;ff1493&quot;,\r\n      dApskyXe: &quot;bfff&quot;,\r\n      dimWay: &quot;696969&quot;,\r\n      dimgYy: &quot;696969&quot;,\r\n      dodgerXe: &quot;1e90ff&quot;,\r\n      fiYbrick: &quot;b22222&quot;,\r\n      flSOwEte: &quot;fffaf0&quot;,\r\n      foYstWAn: &quot;228b22&quot;,\r\n      fuKsia: &quot;ff00ff&quot;,\r\n      gaRsbSo: &quot;dcdcdc&quot;,\r\n      ghostwEte: &quot;f8f8ff&quot;,\r\n      gTd: &quot;ffd700&quot;,\r\n      gTMnPd: &quot;daa520&quot;,\r\n      Way: &quot;808080&quot;,\r\n      gYF: &quot;8000&quot;,\r\n      gYFLw: &quot;adff2f&quot;,\r\n      gYy: &quot;808080&quot;,\r\n      honeyMw: &quot;f0fff0&quot;,\r\n      hotpRk: &quot;ff69b4&quot;,\r\n      RdianYd: &quot;cd5c5c&quot;,\r\n      Rdigo: &quot;4b0082&quot;,\r\n      ivSy: &quot;fffff0&quot;,\r\n      khaki: &quot;f0e68c&quot;,\r\n      lavFMr: &quot;e6e6fa&quot;,\r\n      lavFMrXsh: &quot;fff0f5&quot;,\r\n      lawngYF: &quot;7cfc00&quot;,\r\n      NmoncEffon: &quot;fffacd&quot;,\r\n      ZXe: &quot;add8e6&quot;,\r\n      ZcSO: &quot;f08080&quot;,\r\n      Zcyan: &quot;e0ffff&quot;,\r\n      ZgTMnPdLw: &quot;fafad2&quot;,\r\n      ZWay: &quot;d3d3d3&quot;,\r\n      ZgYF: &quot;90ee90&quot;,\r\n      ZgYy: &quot;d3d3d3&quot;,\r\n      ZpRk: &quot;ffb6c1&quot;,\r\n      ZsOmon: &quot;ffa07a&quot;,\r\n      ZsHgYF: &quot;20b2aa&quot;,\r\n      ZskyXe: &quot;87cefa&quot;,\r\n      ZUWay: &quot;778899&quot;,\r\n      ZUgYy: &quot;778899&quot;,\r\n      ZstAlXe: &quot;b0c4de&quot;,\r\n      ZLw: &quot;ffffe0&quot;,\r\n      lime: &quot;ff00&quot;,\r\n      limegYF: &quot;32cd32&quot;,\r\n      lRF: &quot;faf0e6&quot;,\r\n      magFta: &quot;ff00ff&quot;,\r\n      maPon: &quot;800000&quot;,\r\n      VaquamarRe: &quot;66cdaa&quot;,\r\n      VXe: &quot;cd&quot;,\r\n      VScEd: &quot;ba55d3&quot;,\r\n      VpurpN: &quot;9370db&quot;,\r\n      VsHgYF: &quot;3cb371&quot;,\r\n      VUXe: &quot;7b68ee&quot;,\r\n      VsprRggYF: &quot;fa9a&quot;,\r\n      VQe: &quot;48d1cc&quot;,\r\n      VviTetYd: &quot;c71585&quot;,\r\n      midnightXe: &quot;191970&quot;,\r\n      mRtcYam: &quot;f5fffa&quot;,\r\n      mistyPse: &quot;ffe4e1&quot;,\r\n      moccasR: &quot;ffe4b5&quot;,\r\n      navajowEte: &quot;ffdead&quot;,\r\n      navy: &quot;80&quot;,\r\n      Tdlace: &quot;fdf5e6&quot;,\r\n      Tive: &quot;808000&quot;,\r\n      TivedBb: &quot;6b8e23&quot;,\r\n      Sange: &quot;ffa500&quot;,\r\n      SangeYd: &quot;ff4500&quot;,\r\n      ScEd: &quot;da70d6&quot;,\r\n      pOegTMnPd: &quot;eee8aa&quot;,\r\n      pOegYF: &quot;98fb98&quot;,\r\n      pOeQe: &quot;afeeee&quot;,\r\n      pOeviTetYd: &quot;db7093&quot;,\r\n      papayawEp: &quot;ffefd5&quot;,\r\n      pHKpuff: &quot;ffdab9&quot;,\r\n      peru: &quot;cd853f&quot;,\r\n      pRk: &quot;ffc0cb&quot;,\r\n      plum: &quot;dda0dd&quot;,\r\n      powMrXe: &quot;b0e0e6&quot;,\r\n      purpN: &quot;800080&quot;,\r\n      YbeccapurpN: &quot;663399&quot;,\r\n      Yd: &quot;ff0000&quot;,\r\n      Psybrown: &quot;bc8f8f&quot;,\r\n      PyOXe: &quot;4169e1&quot;,\r\n      saddNbPwn: &quot;8b4513&quot;,\r\n      sOmon: &quot;fa8072&quot;,\r\n      sandybPwn: &quot;f4a460&quot;,\r\n      sHgYF: &quot;2e8b57&quot;,\r\n      sHshell: &quot;fff5ee&quot;,\r\n      siFna: &quot;a0522d&quot;,\r\n      silver: &quot;c0c0c0&quot;,\r\n      skyXe: &quot;87ceeb&quot;,\r\n      UXe: &quot;6a5acd&quot;,\r\n      UWay: &quot;708090&quot;,\r\n      UgYy: &quot;708090&quot;,\r\n      snow: &quot;fffafa&quot;,\r\n      sprRggYF: &quot;ff7f&quot;,\r\n      stAlXe: &quot;4682b4&quot;,\r\n      tan: &quot;d2b48c&quot;,\r\n      teO: &quot;8080&quot;,\r\n      tEstN: &quot;d8bfd8&quot;,\r\n      tomato: &quot;ff6347&quot;,\r\n      Qe: &quot;40e0d0&quot;,\r\n      viTet: &quot;ee82ee&quot;,\r\n      JHt: &quot;f5deb3&quot;,\r\n      wEte: &quot;ffffff&quot;,\r\n      wEtesmoke: &quot;f5f5f5&quot;,\r\n      Lw: &quot;ffff00&quot;,\r\n      LwgYF: &quot;9acd32&quot;\r\n    };\r\n  let Ht;\r\n\r\n  function jt(t) {\r\n    Ht || (Ht = function() {\r\n      const t = {},\r\n        e = Object.keys(Nt),\r\n        i = Object.keys(Wt);\r\n      let s, n, o, a, r;\r\n      for (s = 0; s &lt; e.length; s++) {\r\n        for (a = r = e[s], n = 0; n &lt; i.length; n++) o = i[n], r = r.replace(o, Wt[o]);\r\n        o = parseInt(Nt[a], 16), t[r] = [o &gt;&gt; 16 &amp; 255, o &gt;&gt; 8 &amp; 255, 255 &amp; o]\r\n      }\r\n      return t\r\n    }(), Ht.transparent = [0, 0, 0, 0]);\r\n    const e = Ht[t.toLowerCase()];\r\n    return e &amp;&amp; {\r\n      r: e[0],\r\n      g: e[1],\r\n      b: e[2],\r\n      a: 4 === e.length ? e[3] : 255\r\n    }\r\n  }\r\n  const $t = \/^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,\/]+([-+.e\\d]+)(%)?)?\\s*\\)$\/;\r\n  const Yt = t =&gt; t &lt;= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 \/ 2.4) - .055,\r\n    Ut = t =&gt; t &lt;= .04045 ? t \/ 12.92 : Math.pow((t + .055) \/ 1.055, 2.4);\r\n\r\n  function Xt(t, e, i) {\r\n    if (t) {\r\n      let s = It(t);\r\n      s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = Ft(s), t.r = s[0], t.g = s[1], t.b = s[2]\r\n    }\r\n  }\r\n\r\n  function qt(t, e) {\r\n    return t ? Object.assign(e || {}, t) : t\r\n  }\r\n\r\n  function Kt(t) {\r\n    var e = {\r\n      r: 0,\r\n      g: 0,\r\n      b: 0,\r\n      a: 255\r\n    };\r\n    return Array.isArray(t) ? t.length &gt;= 3 &amp;&amp; (e = {\r\n      r: t[0],\r\n      g: t[1],\r\n      b: t[2],\r\n      a: 255\r\n    }, t.length &gt; 3 &amp;&amp; (e.a = Mt(t[3]))) : (e = qt(t, {\r\n      r: 0,\r\n      g: 0,\r\n      b: 0,\r\n      a: 1\r\n    })).a = Mt(e.a), e\r\n  }\r\n\r\n  function Gt(t) {\r\n    return &quot;r&quot; === t.charAt(0) ? function(t) {\r\n      const e = $t.exec(t);\r\n      let i, s, n, o = 255;\r\n      if (e) {\r\n        if (e[7] !== i) {\r\n          const t = +e[7];\r\n          o = e[8] ? vt(t) : yt(255 * t, 0, 255)\r\n        }\r\n        return i = +e[1], s = +e[3], n = +e[5], i = 255 &amp; (e[2] ? vt(i) : yt(i, 0, 255)), s = 255 &amp; (e[4] ? vt(s) : yt(s, 0, 255)), n = 255 &amp; (e[6] ? vt(n) : yt(n, 0, 255)), {\r\n          r: i,\r\n          g: s,\r\n          b: n,\r\n          a: o\r\n        }\r\n      }\r\n    }(t) : Bt(t)\r\n  }\r\n  class Zt {\r\n    constructor(t) {\r\n      if (t instanceof Zt) return t;\r\n      const e = typeof t;\r\n      let i;\r\n      var s, n, o;\r\n      &quot;object&quot; === e ? i = Kt(t) : &quot;string&quot; === e &amp;&amp; (o = (s = t).length, &quot;#&quot; === s[0] &amp;&amp; (4 === o || 5 === o ? n = {\r\n        r: 255 &amp; 17 * St[s[1]],\r\n        g: 255 &amp; 17 * St[s[2]],\r\n        b: 255 &amp; 17 * St[s[3]],\r\n        a: 5 === o ? 17 * St[s[4]] : 255\r\n      } : 7 !== o &amp;&amp; 9 !== o || (n = {\r\n        r: St[s[1]] &lt;&lt; 4 | St[s[2]],\r\n        g: St[s[3]] &lt;&lt; 4 | St[s[4]],\r\n        b: St[s[5]] &lt;&lt; 4 | St[s[6]],\r\n        a: 9 === o ? St[s[7]] &lt;&lt; 4 | St[s[8]] : 255\r\n      })), i = n || jt(t) || Gt(t)), this._rgb = i, this._valid = !!i\r\n    }\r\n    get valid() {\r\n      return this._valid\r\n    }\r\n    get rgb() {\r\n      var t = qt(this._rgb);\r\n      return t &amp;&amp; (t.a = wt(t.a)), t\r\n    }\r\n    set rgb(t) {\r\n      this._rgb = Kt(t)\r\n    }\r\n    rgbString() {\r\n      return this._valid ? (t = this._rgb) &amp;&amp; (t.a &lt; 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;\r\n      var t\r\n    }\r\n    hexString() {\r\n      return this._valid ? At(this._rgb) : void 0\r\n    }\r\n    hslString() {\r\n      return this._valid ? function(t) {\r\n        if (!t) return;\r\n        const e = It(t),\r\n          i = e[0],\r\n          s = kt(e[1]),\r\n          n = kt(e[2]);\r\n        return t.a &lt; 255 ? `hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`\r\n      }(this._rgb) : void 0\r\n    }\r\n    mix(t, e) {\r\n      if (t) {\r\n        const i = this.rgb,\r\n          s = t.rgb;\r\n        let n;\r\n        const o = e === n ? .5 : e,\r\n          a = 2 * o - 1,\r\n          r = i.a - s.a,\r\n          l = ((a * r == -1 ? a : (a + r) \/ (1 + a * r)) + 1) \/ 2;\r\n        n = 1 - l, i.r = 255 &amp; l * i.r + n * s.r + .5, i.g = 255 &amp; l * i.g + n * s.g + .5, i.b = 255 &amp; l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i\r\n      }\r\n      return this\r\n    }\r\n    interpolate(t, e) {\r\n      return t &amp;&amp; (this._rgb = function(t, e, i) {\r\n        const s = Ut(wt(t.r)),\r\n          n = Ut(wt(t.g)),\r\n          o = Ut(wt(t.b));\r\n        return {\r\n          r: Mt(Yt(s + i * (Ut(wt(e.r)) - s))),\r\n          g: Mt(Yt(n + i * (Ut(wt(e.g)) - n))),\r\n          b: Mt(Yt(o + i * (Ut(wt(e.b)) - o))),\r\n          a: t.a + i * (e.a - t.a)\r\n        }\r\n      }(this._rgb, t._rgb, e)), this\r\n    }\r\n    clone() {\r\n      return new Zt(this.rgb)\r\n    }\r\n    alpha(t) {\r\n      return this._rgb.a = Mt(t), this\r\n    }\r\n    clearer(t) {\r\n      return this._rgb.a *= 1 - t, this\r\n    }\r\n    greyscale() {\r\n      const t = this._rgb,\r\n        e = _t(.3 * t.r + .59 * t.g + .11 * t.b);\r\n      return t.r = t.g = t.b = e, this\r\n    }\r\n    opaquer(t) {\r\n      return this._rgb.a *= 1 + t, this\r\n    }\r\n    negate() {\r\n      const t = this._rgb;\r\n      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this\r\n    }\r\n    lighten(t) {\r\n      return Xt(this._rgb, 2, t), this\r\n    }\r\n    darken(t) {\r\n      return Xt(this._rgb, 2, -t), this\r\n    }\r\n    saturate(t) {\r\n      return Xt(this._rgb, 1, t), this\r\n    }\r\n    desaturate(t) {\r\n      return Xt(this._rgb, 1, -t), this\r\n    }\r\n    rotate(t) {\r\n      return function(t, e) {\r\n        var i = It(t);\r\n        i[0] = Vt(i[0] + e), i = Ft(i), t.r = i[0], t.g = i[1], t.b = i[2]\r\n      }(this._rgb, t), this\r\n    }\r\n  }\r\n\r\n  function Jt(t) {\r\n    if (t &amp;&amp; &quot;object&quot; == typeof t) {\r\n      const e = t.toString();\r\n      return &quot;[object CanvasPattern]&quot; === e || &quot;[object CanvasGradient]&quot; === e\r\n    }\r\n    return !1\r\n  }\r\n\r\n  function Qt(t) {\r\n    return Jt(t) ? t : new Zt(t)\r\n  }\r\n\r\n  function te(t) {\r\n    return Jt(t) ? t : new Zt(t).saturate(.5).darken(.1).hexString()\r\n  }\r\n  const ee = [&quot;x&quot;, &quot;y&quot;, &quot;borderWidth&quot;, &quot;radius&quot;, &quot;tension&quot;],\r\n    ie = [&quot;color&quot;, &quot;borderColor&quot;, &quot;backgroundColor&quot;];\r\n  const se = new Map;\r\n\r\n  function ne(t, e, i) {\r\n    return function(t, e) {\r\n      e = e || {};\r\n      const i = t + JSON.stringify(e);\r\n      let s = se.get(i);\r\n      return s || (s = new Intl.NumberFormat(t, e), se.set(i, s)), s\r\n    }(e, i).format(t)\r\n  }\r\n  const oe = {\r\n    values: t =&gt; n(t) ? t : &quot;&quot; + t,\r\n    numeric(t, e, i) {\r\n      if (0 === t) return &quot;0&quot;;\r\n      const s = this.chart.options.locale;\r\n      let n, o = t;\r\n      if (i.length &gt; 1) {\r\n        const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));\r\n        (e &lt; 1e-4 || e &gt; 1e15) &amp;&amp; (n = &quot;scientific&quot;), o = function(t, e) {\r\n          let i = e.length &gt; 3 ? e[2].value - e[1].value : e[1].value - e[0].value;\r\n          Math.abs(i) &gt;= 1 &amp;&amp; t !== Math.floor(t) &amp;&amp; (i = t - Math.floor(t));\r\n          return i\r\n        }(t, i)\r\n      }\r\n      const a = z(Math.abs(o)),\r\n        r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0),\r\n        l = {\r\n          notation: n,\r\n          minimumFractionDigits: r,\r\n          maximumFractionDigits: r\r\n        };\r\n      return Object.assign(l, this.options.ticks.format), ne(t, s, l)\r\n    },\r\n    logarithmic(t, e, i) {\r\n      if (0 === t) return &quot;0&quot;;\r\n      const s = i[e].significand || t \/ Math.pow(10, Math.floor(z(t)));\r\n      return [1, 2, 3, 5, 10, 15].includes(s) || e &gt; .8 * i.length ? oe.numeric.call(this, t, e, i) : &quot;&quot;\r\n    }\r\n  };\r\n  var ae = {\r\n    formatters: oe\r\n  };\r\n  const re = Object.create(null),\r\n    le = Object.create(null);\r\n\r\n  function he(t, e) {\r\n    if (!e) return t;\r\n    const i = e.split(&quot;.&quot;);\r\n    for (let e = 0, s = i.length; e &lt; s; ++e) {\r\n      const s = i[e];\r\n      t = t[s] || (t[s] = Object.create(null))\r\n    }\r\n    return t\r\n  }\r\n\r\n  function ce(t, e, i) {\r\n    return &quot;string&quot; == typeof e ? x(he(t, e), i) : x(he(t, &quot;&quot;), e)\r\n  }\r\n  class de {\r\n    constructor(t, e) {\r\n      this.animation = void 0, this.backgroundColor = &quot;rgba(0,0,0,0.1)&quot;, this.borderColor = &quot;rgba(0,0,0,0.1)&quot;, this.color = &quot;#666&quot;, this.datasets = {}, this.devicePixelRatio = t =&gt; t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [&quot;mousemove&quot;, &quot;mouseout&quot;, &quot;click&quot;, &quot;touchstart&quot;, &quot;touchmove&quot;], this.font = {\r\n        family: &quot;&#039;Helvetica Neue&#039;, &#039;Helvetica&#039;, &#039;Arial&#039;, sans-serif&quot;,\r\n        size: 12,\r\n        style: &quot;normal&quot;,\r\n        lineHeight: 1.2,\r\n        weight: null\r\n      }, this.hover = {}, this.hoverBackgroundColor = (t, e) =&gt; te(e.backgroundColor), this.hoverBorderColor = (t, e) =&gt; te(e.borderColor), this.hoverColor = (t, e) =&gt; te(e.color), this.indexAxis = &quot;x&quot;, this.interaction = {\r\n        mode: &quot;nearest&quot;,\r\n        intersect: !0,\r\n        includeInvisible: !1\r\n      }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e)\r\n    }\r\n    set(t, e) {\r\n      return ce(this, t, e)\r\n    }\r\n    get(t) {\r\n      return he(this, t)\r\n    }\r\n    describe(t, e) {\r\n      return ce(le, t, e)\r\n    }\r\n    override(t, e) {\r\n      return ce(re, t, e)\r\n    }\r\n    route(t, e, i, s) {\r\n      const n = he(this, t),\r\n        a = he(this, i),\r\n        r = &quot;_&quot; + e;\r\n      Object.defineProperties(n, {\r\n        [r]: {\r\n          value: n[e],\r\n          writable: !0\r\n        },\r\n        [e]: {\r\n          enumerable: !0,\r\n          get() {\r\n            const t = this[r],\r\n              e = a[s];\r\n            return o(t) ? Object.assign({}, e, t) : l(t, e)\r\n          },\r\n          set(t) {\r\n            this[r] = t\r\n          }\r\n        }\r\n      })\r\n    }\r\n    apply(t) {\r\n      t.forEach((t =&gt; t(this)))\r\n    }\r\n  }\r\n  var ue = new de({\r\n    _scriptable: t =&gt; !t.startsWith(&quot;on&quot;),\r\n    _indexable: t =&gt; &quot;events&quot; !== t,\r\n    hover: {\r\n      _fallback: &quot;interaction&quot;\r\n    },\r\n    interaction: {\r\n      _scriptable: !1,\r\n      _indexable: !1\r\n    }\r\n  }, [function(t) {\r\n    t.set(&quot;animation&quot;, {\r\n      delay: void 0,\r\n      duration: 1e3,\r\n      easing: &quot;easeOutQuart&quot;,\r\n      fn: void 0,\r\n      from: void 0,\r\n      loop: void 0,\r\n      to: void 0,\r\n      type: void 0\r\n    }), t.describe(&quot;animation&quot;, {\r\n      _fallback: !1,\r\n      _indexable: !1,\r\n      _scriptable: t =&gt; &quot;onProgress&quot; !== t &amp;&amp; &quot;onComplete&quot; !== t &amp;&amp; &quot;fn&quot; !== t\r\n    }), t.set(&quot;animations&quot;, {\r\n      colors: {\r\n        type: &quot;color&quot;,\r\n        properties: ie\r\n      },\r\n      numbers: {\r\n        type: &quot;number&quot;,\r\n        properties: ee\r\n      }\r\n    }), t.describe(&quot;animations&quot;, {\r\n      _fallback: &quot;animation&quot;\r\n    }), t.set(&quot;transitions&quot;, {\r\n      active: {\r\n        animation: {\r\n          duration: 400\r\n        }\r\n      },\r\n      resize: {\r\n        animation: {\r\n          duration: 0\r\n        }\r\n      },\r\n      show: {\r\n        animations: {\r\n          colors: {\r\n            from: &quot;transparent&quot;\r\n          },\r\n          visible: {\r\n            type: &quot;boolean&quot;,\r\n            duration: 0\r\n          }\r\n        }\r\n      },\r\n      hide: {\r\n        animations: {\r\n          colors: {\r\n            to: &quot;transparent&quot;\r\n          },\r\n          visible: {\r\n            type: &quot;boolean&quot;,\r\n            easing: &quot;linear&quot;,\r\n            fn: t =&gt; 0 | t\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }, function(t) {\r\n    t.set(&quot;layout&quot;, {\r\n      autoPadding: !0,\r\n      padding: {\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0\r\n      }\r\n    })\r\n  }, function(t) {\r\n    t.set(&quot;scale&quot;, {\r\n      display: !0,\r\n      offset: !1,\r\n      reverse: !1,\r\n      beginAtZero: !1,\r\n      bounds: &quot;ticks&quot;,\r\n      clip: !0,\r\n      grace: 0,\r\n      grid: {\r\n        display: !0,\r\n        lineWidth: 1,\r\n        drawOnChartArea: !0,\r\n        drawTicks: !0,\r\n        tickLength: 8,\r\n        tickWidth: (t, e) =&gt; e.lineWidth,\r\n        tickColor: (t, e) =&gt; e.color,\r\n        offset: !1\r\n      },\r\n      border: {\r\n        display: !0,\r\n        dash: [],\r\n        dashOffset: 0,\r\n        width: 1\r\n      },\r\n      title: {\r\n        display: !1,\r\n        text: &quot;&quot;,\r\n        padding: {\r\n          top: 4,\r\n          bottom: 4\r\n        }\r\n      },\r\n      ticks: {\r\n        minRotation: 0,\r\n        maxRotation: 50,\r\n        mirror: !1,\r\n        textStrokeWidth: 0,\r\n        textStrokeColor: &quot;&quot;,\r\n        padding: 3,\r\n        display: !0,\r\n        autoSkip: !0,\r\n        autoSkipPadding: 3,\r\n        labelOffset: 0,\r\n        callback: ae.formatters.values,\r\n        minor: {},\r\n        major: {},\r\n        align: &quot;center&quot;,\r\n        crossAlign: &quot;near&quot;,\r\n        showLabelBackdrop: !1,\r\n        backdropColor: &quot;rgba(255, 255, 255, 0.75)&quot;,\r\n        backdropPadding: 2\r\n      }\r\n    }), t.route(&quot;scale.ticks&quot;, &quot;color&quot;, &quot;&quot;, &quot;color&quot;), t.route(&quot;scale.grid&quot;, &quot;color&quot;, &quot;&quot;, &quot;borderColor&quot;), t.route(&quot;scale.border&quot;, &quot;color&quot;, &quot;&quot;, &quot;borderColor&quot;), t.route(&quot;scale.title&quot;, &quot;color&quot;, &quot;&quot;, &quot;color&quot;), t.describe(&quot;scale&quot;, {\r\n      _fallback: !1,\r\n      _scriptable: t =&gt; !t.startsWith(&quot;before&quot;) &amp;&amp; !t.startsWith(&quot;after&quot;) &amp;&amp; &quot;callback&quot; !== t &amp;&amp; &quot;parser&quot; !== t,\r\n      _indexable: t =&gt; &quot;borderDash&quot; !== t &amp;&amp; &quot;tickBorderDash&quot; !== t &amp;&amp; &quot;dash&quot; !== t\r\n    }), t.describe(&quot;scales&quot;, {\r\n      _fallback: &quot;scale&quot;\r\n    }), t.describe(&quot;scale.ticks&quot;, {\r\n      _scriptable: t =&gt; &quot;backdropPadding&quot; !== t &amp;&amp; &quot;callback&quot; !== t,\r\n      _indexable: t =&gt; &quot;backdropPadding&quot; !== t\r\n    })\r\n  }]);\r\n\r\n  function fe() {\r\n    return &quot;undefined&quot; != typeof window &amp;&amp; &quot;undefined&quot; != typeof document\r\n  }\r\n\r\n  function ge(t) {\r\n    let e = t.parentNode;\r\n    return e &amp;&amp; &quot;[object ShadowRoot]&quot; === e.toString() &amp;&amp; (e = e.host), e\r\n  }\r\n\r\n  function pe(t, e, i) {\r\n    let s;\r\n    return &quot;string&quot; == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf(&quot;%&quot;) &amp;&amp; (s = s \/ 100 * e.parentNode[i])) : s = t, s\r\n  }\r\n  const me = t =&gt; t.ownerDocument.defaultView.getComputedStyle(t, null);\r\n\r\n  function xe(t, e) {\r\n    return me(t).getPropertyValue(e)\r\n  }\r\n  const be = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];\r\n\r\n  function _e(t, e, i) {\r\n    const s = {};\r\n    i = i ? &quot;-&quot; + i : &quot;&quot;;\r\n    for (let n = 0; n &lt; 4; n++) {\r\n      const o = be[n];\r\n      s[o] = parseFloat(t[e + &quot;-&quot; + o + i]) || 0\r\n    }\r\n    return s.width = s.left + s.right, s.height = s.top + s.bottom, s\r\n  }\r\n  const ye = (t, e, i) =&gt; (t &gt; 0 || e &gt; 0) &amp;&amp; (!i || !i.shadowRoot);\r\n\r\n  function ve(t, e) {\r\n    if (&quot;native&quot; in t) return t;\r\n    const {\r\n      canvas: i,\r\n      currentDevicePixelRatio: s\r\n    } = e, n = me(i), o = &quot;border-box&quot; === n.boxSizing, a = _e(n, &quot;padding&quot;), r = _e(n, &quot;border&quot;, &quot;width&quot;), {\r\n      x: l,\r\n      y: h,\r\n      box: c\r\n    } = function(t, e) {\r\n      const i = t.touches,\r\n        s = i &amp;&amp; i.length ? i[0] : t,\r\n        {\r\n          offsetX: n,\r\n          offsetY: o\r\n        } = s;\r\n      let a, r, l = !1;\r\n      if (ye(n, o, t.target)) a = n, r = o;\r\n      else {\r\n        const t = e.getBoundingClientRect();\r\n        a = s.clientX - t.left, r = s.clientY - t.top, l = !0\r\n      }\r\n      return {\r\n        x: a,\r\n        y: r,\r\n        box: l\r\n      }\r\n    }(t, i), d = a.left + (c &amp;&amp; r.left), u = a.top + (c &amp;&amp; r.top);\r\n    let {\r\n      width: f,\r\n      height: g\r\n    } = e;\r\n    return o &amp;&amp; (f -= a.width + r.width, g -= a.height + r.height), {\r\n      x: Math.round((l - d) \/ f * i.width \/ s),\r\n      y: Math.round((h - u) \/ g * i.height \/ s)\r\n    }\r\n  }\r\n  const Me = t =&gt; Math.round(10 * t) \/ 10;\r\n\r\n  function we(t, e, i, s) {\r\n    const n = me(t),\r\n      o = _e(n, &quot;margin&quot;),\r\n      a = pe(n.maxWidth, t, &quot;clientWidth&quot;) || T,\r\n      r = pe(n.maxHeight, t, &quot;clientHeight&quot;) || T,\r\n      l = function(t, e, i) {\r\n        let s, n;\r\n        if (void 0 === e || void 0 === i) {\r\n          const o = t &amp;&amp; ge(t);\r\n          if (o) {\r\n            const t = o.getBoundingClientRect(),\r\n              a = me(o),\r\n              r = _e(a, &quot;border&quot;, &quot;width&quot;),\r\n              l = _e(a, &quot;padding&quot;);\r\n            e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = pe(a.maxWidth, o, &quot;clientWidth&quot;), n = pe(a.maxHeight, o, &quot;clientHeight&quot;)\r\n          } else e = t.clientWidth, i = t.clientHeight\r\n        }\r\n        return {\r\n          width: e,\r\n          height: i,\r\n          maxWidth: s || T,\r\n          maxHeight: n || T\r\n        }\r\n      }(t, e, i);\r\n    let {\r\n      width: h,\r\n      height: c\r\n    } = l;\r\n    if (&quot;content-box&quot; === n.boxSizing) {\r\n      const t = _e(n, &quot;border&quot;, &quot;width&quot;),\r\n        e = _e(n, &quot;padding&quot;);\r\n      h -= e.width + t.width, c -= e.height + t.height\r\n    }\r\n    h = Math.max(0, h - o.width), c = Math.max(0, s ? h \/ s : c - o.height), h = Me(Math.min(h, a, l.maxWidth)), c = Me(Math.min(c, r, l.maxHeight)), h &amp;&amp; !c &amp;&amp; (c = Me(h \/ 2));\r\n    return (void 0 !== e || void 0 !== i) &amp;&amp; s &amp;&amp; l.height &amp;&amp; c &gt; l.height &amp;&amp; (c = l.height, h = Me(Math.floor(c * s))), {\r\n      width: h,\r\n      height: c\r\n    }\r\n  }\r\n\r\n  function ke(t, e, i) {\r\n    const s = e || 1,\r\n      n = Math.floor(t.height * s),\r\n      o = Math.floor(t.width * s);\r\n    t.height = Math.floor(t.height), t.width = Math.floor(t.width);\r\n    const a = t.canvas;\r\n    return a.style &amp;&amp; (i || !a.style.height &amp;&amp; !a.style.width) &amp;&amp; (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) &amp;&amp; (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0)\r\n  }\r\n  const Se = function() {\r\n    let t = !1;\r\n    try {\r\n      const e = {\r\n        get passive() {\r\n          return t = !0, !1\r\n        }\r\n      };\r\n      fe() &amp;&amp; (window.addEventListener(&quot;test&quot;, null, e), window.removeEventListener(&quot;test&quot;, null, e))\r\n    } catch (t) {}\r\n    return t\r\n  }();\r\n\r\n  function Pe(t, e) {\r\n    const i = xe(t, e),\r\n      s = i &amp;&amp; i.match(\/^(\\d+)(\\.\\d+)?px$\/);\r\n    return s ? +s[1] : void 0\r\n  }\r\n\r\n  function De(t) {\r\n    return !t || s(t.size) || s(t.family) ? null : (t.style ? t.style + &quot; &quot; : &quot;&quot;) + (t.weight ? t.weight + &quot; &quot; : &quot;&quot;) + t.size + &quot;px &quot; + t.family\r\n  }\r\n\r\n  function Ce(t, e, i, s, n) {\r\n    let o = e[n];\r\n    return o || (o = e[n] = t.measureText(n).width, i.push(n)), o &gt; s &amp;&amp; (s = o), s\r\n  }\r\n\r\n  function Oe(t, e, i, s) {\r\n    let o = (s = s || {}).data = s.data || {},\r\n      a = s.garbageCollect = s.garbageCollect || [];\r\n    s.font !== e &amp;&amp; (o = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;\r\n    let r = 0;\r\n    const l = i.length;\r\n    let h, c, d, u, f;\r\n    for (h = 0; h &lt; l; h++)\r\n      if (u = i[h], null == u || n(u)) {\r\n        if (n(u))\r\n          for (c = 0, d = u.length; c &lt; d; c++) f = u[c], null == f || n(f) || (r = Ce(t, o, a, r, f))\r\n      } else r = Ce(t, o, a, r, u);\r\n    t.restore();\r\n    const g = a.length \/ 2;\r\n    if (g &gt; i.length) {\r\n      for (h = 0; h &lt; g; h++) delete o[a[h]];\r\n      a.splice(0, g)\r\n    }\r\n    return r\r\n  }\r\n\r\n  function Ae(t, e, i) {\r\n    const s = t.currentDevicePixelRatio,\r\n      n = 0 !== i ? Math.max(i \/ 2, .5) : 0;\r\n    return Math.round((e - n) * s) \/ s + n\r\n  }\r\n\r\n  function Te(t, e) {\r\n    (e || t) &amp;&amp; ((e = e || t.getContext(&quot;2d&quot;)).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore())\r\n  }\r\n\r\n  function Le(t, e, i, s) {\r\n    Ee(t, e, i, s, null)\r\n  }\r\n\r\n  function Ee(t, e, i, s, n) {\r\n    let o, a, r, l, h, c, d, u;\r\n    const f = e.pointStyle,\r\n      g = e.rotation,\r\n      p = e.radius;\r\n    let m = (g || 0) * L;\r\n    if (f &amp;&amp; &quot;object&quot; == typeof f &amp;&amp; (o = f.toString(), &quot;[object HTMLImageElement]&quot; === o || &quot;[object HTMLCanvasElement]&quot; === o)) return t.save(), t.translate(i, s), t.rotate(m), t.drawImage(f, -f.width \/ 2, -f.height \/ 2, f.width, f.height), void t.restore();\r\n    if (!(isNaN(p) || p &lt;= 0)) {\r\n      switch (t.beginPath(), f) {\r\n        default:\r\n          n ? t.ellipse(i, s, n \/ 2, p, 0, 0, O) : t.arc(i, s, p, 0, O), t.closePath();\r\n          break;\r\n        case &quot;triangle&quot;:\r\n          c = n ? n \/ 2 : p, t.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), t.closePath();\r\n          break;\r\n        case &quot;rectRounded&quot;:\r\n          h = .516 * p, l = p - h, a = Math.cos(m + R) * l, d = Math.cos(m + R) * (n ? n \/ 2 - h : l), r = Math.sin(m + R) * l, u = Math.sin(m + R) * (n ? n \/ 2 - h : l), t.arc(i - d, s - r, h, m - C, m - E), t.arc(i + u, s - a, h, m - E, m), t.arc(i + d, s + r, h, m, m + E), t.arc(i - u, s + a, h, m + E, m + C), t.closePath();\r\n          break;\r\n        case &quot;rect&quot;:\r\n          if (!g) {\r\n            l = Math.SQRT1_2 * p, c = n ? n \/ 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);\r\n            break\r\n          }\r\n          m += R;\r\n        case &quot;rectRot&quot;:\r\n          d = Math.cos(m) * (n ? n \/ 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n \/ 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + u, s - a), t.lineTo(i + d, s + r), t.lineTo(i - u, s + a), t.closePath();\r\n          break;\r\n        case &quot;crossRot&quot;:\r\n          m += R;\r\n        case &quot;cross&quot;:\r\n          d = Math.cos(m) * (n ? n \/ 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n \/ 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\r\n          break;\r\n        case &quot;star&quot;:\r\n          d = Math.cos(m) * (n ? n \/ 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n \/ 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a), m += R, d = Math.cos(m) * (n ? n \/ 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n \/ 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\r\n          break;\r\n        case &quot;line&quot;:\r\n          a = n ? n \/ 2 : Math.cos(m) * p, r = Math.sin(m) * p, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);\r\n          break;\r\n        case &quot;dash&quot;:\r\n          t.moveTo(i, s), t.lineTo(i + Math.cos(m) * (n ? n \/ 2 : p), s + Math.sin(m) * p);\r\n          break;\r\n        case !1:\r\n          t.closePath()\r\n      }\r\n      t.fill(), e.borderWidth &gt; 0 &amp;&amp; t.stroke()\r\n    }\r\n  }\r\n\r\n  function Re(t, e, i) {\r\n    return i = i || .5, !e || t &amp;&amp; t.x &gt; e.left - i &amp;&amp; t.x &lt; e.right + i &amp;&amp; t.y &gt; e.top - i &amp;&amp; t.y &lt; e.bottom + i\r\n  }\r\n\r\n  function Ie(t, e) {\r\n    t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()\r\n  }\r\n\r\n  function ze(t) {\r\n    t.restore()\r\n  }\r\n\r\n  function Fe(t, e, i, s, n) {\r\n    if (!e) return t.lineTo(i.x, i.y);\r\n    if (&quot;middle&quot; === n) {\r\n      const s = (e.x + i.x) \/ 2;\r\n      t.lineTo(s, e.y), t.lineTo(s, i.y)\r\n    } else &quot;after&quot; === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);\r\n    t.lineTo(i.x, i.y)\r\n  }\r\n\r\n  function Ve(t, e, i, s) {\r\n    if (!e) return t.lineTo(i.x, i.y);\r\n    t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y)\r\n  }\r\n\r\n  function Be(t, e, i, s, n) {\r\n    if (n.strikethrough || n.underline) {\r\n      const o = t.measureText(s),\r\n        a = e - o.actualBoundingBoxLeft,\r\n        r = e + o.actualBoundingBoxRight,\r\n        l = i - o.actualBoundingBoxAscent,\r\n        h = i + o.actualBoundingBoxDescent,\r\n        c = n.strikethrough ? (l + h) \/ 2 : h;\r\n      t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke()\r\n    }\r\n  }\r\n\r\n  function We(t, e) {\r\n    const i = t.fillStyle;\r\n    t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i\r\n  }\r\n\r\n  function Ne(t, e, i, o, a, r = {}) {\r\n    const l = n(e) ? e : [e],\r\n      h = r.strokeWidth &gt; 0 &amp;&amp; &quot;&quot; !== r.strokeColor;\r\n    let c, d;\r\n    for (t.save(), t.font = a.string, function(t, e) {\r\n        e.translation &amp;&amp; t.translate(e.translation[0], e.translation[1]), s(e.rotation) || t.rotate(e.rotation), e.color &amp;&amp; (t.fillStyle = e.color), e.textAlign &amp;&amp; (t.textAlign = e.textAlign), e.textBaseline &amp;&amp; (t.textBaseline = e.textBaseline)\r\n      }(t, r), c = 0; c &lt; l.length; ++c) d = l[c], r.backdrop &amp;&amp; We(t, r.backdrop), h &amp;&amp; (r.strokeColor &amp;&amp; (t.strokeStyle = r.strokeColor), s(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, i, o, r.maxWidth)), t.fillText(d, i, o, r.maxWidth), Be(t, i, o, d, r), o += Number(a.lineHeight);\r\n    t.restore()\r\n  }\r\n\r\n  function He(t, e) {\r\n    const {\r\n      x: i,\r\n      y: s,\r\n      w: n,\r\n      h: o,\r\n      radius: a\r\n    } = e;\r\n    t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, 1.5 * C, C, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, C, E, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, E, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -E, !0), t.lineTo(i + a.topLeft, s)\r\n  }\r\n\r\n  function je(t, e = [&quot;&quot;], i, s, n = (() =&gt; t[0])) {\r\n    const o = i || t;\r\n    void 0 === s &amp;&amp; (s = ti(&quot;_fallback&quot;, t));\r\n    const a = {\r\n      [Symbol.toStringTag]: &quot;Object&quot;,\r\n      _cacheable: !0,\r\n      _scopes: t,\r\n      _rootScopes: o,\r\n      _fallback: s,\r\n      _getTarget: n,\r\n      override: i =&gt; je([i, ...t], e, o, s)\r\n    };\r\n    return new Proxy(a, {\r\n      deleteProperty: (e, i) =&gt; (delete e[i], delete e._keys, delete t[0][i], !0),\r\n      get: (i, s) =&gt; qe(i, s, (() =&gt; function(t, e, i, s) {\r\n        let n;\r\n        for (const o of e)\r\n          if (n = ti(Ue(o, t), i), void 0 !== n) return Xe(t, n) ? Je(i, s, t, n) : n\r\n      }(s, e, t, i))),\r\n      getOwnPropertyDescriptor: (t, e) =&gt; Reflect.getOwnPropertyDescriptor(t._scopes[0], e),\r\n      getPrototypeOf: () =&gt; Reflect.getPrototypeOf(t[0]),\r\n      has: (t, e) =&gt; ei(t).includes(e),\r\n      ownKeys: t =&gt; ei(t),\r\n      set(t, e, i) {\r\n        const s = t._storage || (t._storage = n());\r\n        return t[e] = s[e] = i, delete t._keys, !0\r\n      }\r\n    })\r\n  }\r\n\r\n  function $e(t, e, i, s) {\r\n    const a = {\r\n      _cacheable: !1,\r\n      _proxy: t,\r\n      _context: e,\r\n      _subProxy: i,\r\n      _stack: new Set,\r\n      _descriptors: Ye(t, s),\r\n      setContext: e =&gt; $e(t, e, i, s),\r\n      override: n =&gt; $e(t.override(n), e, i, s)\r\n    };\r\n    return new Proxy(a, {\r\n      deleteProperty: (e, i) =&gt; (delete e[i], delete t[i], !0),\r\n      get: (t, e, i) =&gt; qe(t, e, (() =&gt; function(t, e, i) {\r\n        const {\r\n          _proxy: s,\r\n          _context: a,\r\n          _subProxy: r,\r\n          _descriptors: l\r\n        } = t;\r\n        let h = s[e];\r\n        S(h) &amp;&amp; l.isScriptable(e) &amp;&amp; (h = function(t, e, i, s) {\r\n          const {\r\n            _proxy: n,\r\n            _context: o,\r\n            _subProxy: a,\r\n            _stack: r\r\n          } = i;\r\n          if (r.has(t)) throw new Error(&quot;Recursion detected: &quot; + Array.from(r).join(&quot;-&gt;&quot;) + &quot;-&gt;&quot; + t);\r\n          r.add(t);\r\n          let l = e(o, a || s);\r\n          r.delete(t), Xe(t, l) &amp;&amp; (l = Je(n._scopes, n, t, l));\r\n          return l\r\n        }(e, h, t, i));\r\n        n(h) &amp;&amp; h.length &amp;&amp; (h = function(t, e, i, s) {\r\n          const {\r\n            _proxy: n,\r\n            _context: a,\r\n            _subProxy: r,\r\n            _descriptors: l\r\n          } = i;\r\n          if (void 0 !== a.index &amp;&amp; s(t)) return e[a.index % e.length];\r\n          if (o(e[0])) {\r\n            const i = e,\r\n              s = n._scopes.filter((t =&gt; t !== i));\r\n            e = [];\r\n            for (const o of i) {\r\n              const i = Je(s, n, t, o);\r\n              e.push($e(i, a, r &amp;&amp; r[t], l))\r\n            }\r\n          }\r\n          return e\r\n        }(e, h, t, l.isIndexable));\r\n        Xe(e, h) &amp;&amp; (h = $e(h, a, r &amp;&amp; r[e], l));\r\n        return h\r\n      }(t, e, i))),\r\n      getOwnPropertyDescriptor: (e, i) =&gt; e._descriptors.allKeys ? Reflect.has(t, i) ? {\r\n        enumerable: !0,\r\n        configurable: !0\r\n      } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),\r\n      getPrototypeOf: () =&gt; Reflect.getPrototypeOf(t),\r\n      has: (e, i) =&gt; Reflect.has(t, i),\r\n      ownKeys: () =&gt; Reflect.ownKeys(t),\r\n      set: (e, i, s) =&gt; (t[i] = s, delete e[i], !0)\r\n    })\r\n  }\r\n\r\n  function Ye(t, e = {\r\n    scriptable: !0,\r\n    indexable: !0\r\n  }) {\r\n    const {\r\n      _scriptable: i = e.scriptable,\r\n      _indexable: s = e.indexable,\r\n      _allKeys: n = e.allKeys\r\n    } = t;\r\n    return {\r\n      allKeys: n,\r\n      scriptable: i,\r\n      indexable: s,\r\n      isScriptable: S(i) ? i : () =&gt; i,\r\n      isIndexable: S(s) ? s : () =&gt; s\r\n    }\r\n  }\r\n  const Ue = (t, e) =&gt; t ? t + w(e) : e,\r\n    Xe = (t, e) =&gt; o(e) &amp;&amp; &quot;adapters&quot; !== t &amp;&amp; (null === Object.getPrototypeOf(e) || e.constructor === Object);\r\n\r\n  function qe(t, e, i) {\r\n    if (Object.prototype.hasOwnProperty.call(t, e) || &quot;constructor&quot; === e) return t[e];\r\n    const s = i();\r\n    return t[e] = s, s\r\n  }\r\n\r\n  function Ke(t, e, i) {\r\n    return S(t) ? t(e, i) : t\r\n  }\r\n  const Ge = (t, e) =&gt; !0 === t ? e : &quot;string&quot; == typeof t ? M(e, t) : void 0;\r\n\r\n  function Ze(t, e, i, s, n) {\r\n    for (const o of e) {\r\n      const e = Ge(i, o);\r\n      if (e) {\r\n        t.add(e);\r\n        const o = Ke(e._fallback, i, n);\r\n        if (void 0 !== o &amp;&amp; o !== i &amp;&amp; o !== s) return o\r\n      } else if (!1 === e &amp;&amp; void 0 !== s &amp;&amp; i !== s) return null\r\n    }\r\n    return !1\r\n  }\r\n\r\n  function Je(t, e, i, s) {\r\n    const a = e._rootScopes,\r\n      r = Ke(e._fallback, i, s),\r\n      l = [...t, ...a],\r\n      h = new Set;\r\n    h.add(s);\r\n    let c = Qe(h, l, i, r || i, s);\r\n    return null !== c &amp;&amp; ((void 0 === r || r === i || (c = Qe(h, l, r, c, s), null !== c)) &amp;&amp; je(Array.from(h), [&quot;&quot;], a, r, (() =&gt; function(t, e, i) {\r\n      const s = t._getTarget();\r\n      e in s || (s[e] = {});\r\n      const a = s[e];\r\n      if (n(a) &amp;&amp; o(i)) return i;\r\n      return a || {}\r\n    }(e, i, s))))\r\n  }\r\n\r\n  function Qe(t, e, i, s, n) {\r\n    for (; i;) i = Ze(t, e, i, s, n);\r\n    return i\r\n  }\r\n\r\n  function ti(t, e) {\r\n    for (const i of e) {\r\n      if (!i) continue;\r\n      const e = i[t];\r\n      if (void 0 !== e) return e\r\n    }\r\n  }\r\n\r\n  function ei(t) {\r\n    let e = t._keys;\r\n    return e || (e = t._keys = function(t) {\r\n      const e = new Set;\r\n      for (const i of t)\r\n        for (const t of Object.keys(i).filter((t =&gt; !t.startsWith(&quot;_&quot;)))) e.add(t);\r\n      return Array.from(e)\r\n    }(t._scopes)), e\r\n  }\r\n\r\n  function ii(t, e, i, s) {\r\n    const {\r\n      iScale: n\r\n    } = t, {\r\n      key: o = &quot;r&quot;\r\n    } = this._parsing, a = new Array(s);\r\n    let r, l, h, c;\r\n    for (r = 0, l = s; r &lt; l; ++r) h = r + i, c = e[h], a[r] = {\r\n      r: n.parse(M(c, o), h)\r\n    };\r\n    return a\r\n  }\r\n  const si = Number.EPSILON || 1e-14,\r\n    ni = (t, e) =&gt; e &lt; t.length &amp;&amp; !t[e].skip &amp;&amp; t[e],\r\n    oi = t =&gt; &quot;x&quot; === t ? &quot;y&quot; : &quot;x&quot;;\r\n\r\n  function ai(t, e, i, s) {\r\n    const n = t.skip ? e : t,\r\n      o = e,\r\n      a = i.skip ? e : i,\r\n      r = q(o, n),\r\n      l = q(a, o);\r\n    let h = r \/ (r + l),\r\n      c = l \/ (r + l);\r\n    h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;\r\n    const d = s * h,\r\n      u = s * c;\r\n    return {\r\n      previous: {\r\n        x: o.x - d * (a.x - n.x),\r\n        y: o.y - d * (a.y - n.y)\r\n      },\r\n      next: {\r\n        x: o.x + u * (a.x - n.x),\r\n        y: o.y + u * (a.y - n.y)\r\n      }\r\n    }\r\n  }\r\n\r\n  function ri(t, e = &quot;x&quot;) {\r\n    const i = oi(e),\r\n      s = t.length,\r\n      n = Array(s).fill(0),\r\n      o = Array(s);\r\n    let a, r, l, h = ni(t, 0);\r\n    for (a = 0; a &lt; s; ++a)\r\n      if (r = l, l = h, h = ni(t, a + 1), l) {\r\n        if (h) {\r\n          const t = h[e] - l[e];\r\n          n[a] = 0 !== t ? (h[i] - l[i]) \/ t : 0\r\n        }\r\n        o[a] = r ? h ? F(n[a - 1]) !== F(n[a]) ? 0 : (n[a - 1] + n[a]) \/ 2 : n[a - 1] : n[a]\r\n      }!\r\n    function(t, e, i) {\r\n      const s = t.length;\r\n      let n, o, a, r, l, h = ni(t, 0);\r\n      for (let c = 0; c &lt; s - 1; ++c) l = h, h = ni(t, c + 1), l &amp;&amp; h &amp;&amp; (V(e[c], 0, si) ? i[c] = i[c + 1] = 0 : (n = i[c] \/ e[c], o = i[c + 1] \/ e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r &lt;= 9 || (a = 3 \/ Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])))\r\n    }(t, n, o),\r\n    function(t, e, i = &quot;x&quot;) {\r\n      const s = oi(i),\r\n        n = t.length;\r\n      let o, a, r, l = ni(t, 0);\r\n      for (let h = 0; h &lt; n; ++h) {\r\n        if (a = r, r = l, l = ni(t, h + 1), !r) continue;\r\n        const n = r[i],\r\n          c = r[s];\r\n        a &amp;&amp; (o = (n - a[i]) \/ 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l &amp;&amp; (o = (l[i] - n) \/ 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h])\r\n      }\r\n    }(t, o, e)\r\n  }\r\n\r\n  function li(t, e, i) {\r\n    return Math.max(Math.min(t, i), e)\r\n  }\r\n\r\n  function hi(t, e, i, s, n) {\r\n    let o, a, r, l;\r\n    if (e.spanGaps &amp;&amp; (t = t.filter((t =&gt; !t.skip))), &quot;monotone&quot; === e.cubicInterpolationMode) ri(t, n);\r\n    else {\r\n      let i = s ? t[t.length - 1] : t[0];\r\n      for (o = 0, a = t.length; o &lt; a; ++o) r = t[o], l = ai(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r\r\n    }\r\n    e.capBezierPoints &amp;&amp; function(t, e) {\r\n      let i, s, n, o, a, r = Re(t[0], e);\r\n      for (i = 0, s = t.length; i &lt; s; ++i) a = o, o = r, r = i &lt; s - 1 &amp;&amp; Re(t[i + 1], e), o &amp;&amp; (n = t[i], a &amp;&amp; (n.cp1x = li(n.cp1x, e.left, e.right), n.cp1y = li(n.cp1y, e.top, e.bottom)), r &amp;&amp; (n.cp2x = li(n.cp2x, e.left, e.right), n.cp2y = li(n.cp2y, e.top, e.bottom)))\r\n    }(t, i)\r\n  }\r\n  const ci = t =&gt; 0 === t || 1 === t,\r\n    di = (t, e, i) =&gt; -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O \/ i),\r\n    ui = (t, e, i) =&gt; Math.pow(2, -10 * t) * Math.sin((t - e) * O \/ i) + 1,\r\n    fi = {\r\n      linear: t =&gt; t,\r\n      easeInQuad: t =&gt; t * t,\r\n      easeOutQuad: t =&gt; -t * (t - 2),\r\n      easeInOutQuad: t =&gt; (t \/= .5) &lt; 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),\r\n      easeInCubic: t =&gt; t * t * t,\r\n      easeOutCubic: t =&gt; (t -= 1) * t * t + 1,\r\n      easeInOutCubic: t =&gt; (t \/= .5) &lt; 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),\r\n      easeInQuart: t =&gt; t * t * t * t,\r\n      easeOutQuart: t =&gt; -((t -= 1) * t * t * t - 1),\r\n      easeInOutQuart: t =&gt; (t \/= .5) &lt; 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),\r\n      easeInQuint: t =&gt; t * t * t * t * t,\r\n      easeOutQuint: t =&gt; (t -= 1) * t * t * t * t + 1,\r\n      easeInOutQuint: t =&gt; (t \/= .5) &lt; 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),\r\n      easeInSine: t =&gt; 1 - Math.cos(t * E),\r\n      easeOutSine: t =&gt; Math.sin(t * E),\r\n      easeInOutSine: t =&gt; -.5 * (Math.cos(C * t) - 1),\r\n      easeInExpo: t =&gt; 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),\r\n      easeOutExpo: t =&gt; 1 === t ? 1 : 1 - Math.pow(2, -10 * t),\r\n      easeInOutExpo: t =&gt; ci(t) ? t : t &lt; .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),\r\n      easeInCirc: t =&gt; t &gt;= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\r\n      easeOutCirc: t =&gt; Math.sqrt(1 - (t -= 1) * t),\r\n      easeInOutCirc: t =&gt; (t \/= .5) &lt; 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\r\n      easeInElastic: t =&gt; ci(t) ? t : di(t, .075, .3),\r\n      easeOutElastic: t =&gt; ci(t) ? t : ui(t, .075, .3),\r\n      easeInOutElastic(t) {\r\n        const e = .1125;\r\n        return ci(t) ? t : t &lt; .5 ? .5 * di(2 * t, e, .45) : .5 + .5 * ui(2 * t - 1, e, .45)\r\n      },\r\n      easeInBack(t) {\r\n        const e = 1.70158;\r\n        return t * t * ((e + 1) * t - e)\r\n      },\r\n      easeOutBack(t) {\r\n        const e = 1.70158;\r\n        return (t -= 1) * t * ((e + 1) * t + e) + 1\r\n      },\r\n      easeInOutBack(t) {\r\n        let e = 1.70158;\r\n        return (t \/= .5) &lt; 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)\r\n      },\r\n      easeInBounce: t =&gt; 1 - fi.easeOutBounce(1 - t),\r\n      easeOutBounce(t) {\r\n        const e = 7.5625,\r\n          i = 2.75;\r\n        return t &lt; 1 \/ i ? e * t * t : t &lt; 2 \/ i ? e * (t -= 1.5 \/ i) * t + .75 : t &lt; 2.5 \/ i ? e * (t -= 2.25 \/ i) * t + .9375 : e * (t -= 2.625 \/ i) * t + .984375\r\n      },\r\n      easeInOutBounce: t =&gt; t &lt; .5 ? .5 * fi.easeInBounce(2 * t) : .5 * fi.easeOutBounce(2 * t - 1) + .5\r\n    };\r\n\r\n  function gi(t, e, i, s) {\r\n    return {\r\n      x: t.x + i * (e.x - t.x),\r\n      y: t.y + i * (e.y - t.y)\r\n    }\r\n  }\r\n\r\n  function pi(t, e, i, s) {\r\n    return {\r\n      x: t.x + i * (e.x - t.x),\r\n      y: &quot;middle&quot; === s ? i &lt; .5 ? t.y : e.y : &quot;after&quot; === s ? i &lt; 1 ? t.y : e.y : i &gt; 0 ? e.y : t.y\r\n    }\r\n  }\r\n\r\n  function mi(t, e, i, s) {\r\n    const n = {\r\n        x: t.cp2x,\r\n        y: t.cp2y\r\n      },\r\n      o = {\r\n        x: e.cp1x,\r\n        y: e.cp1y\r\n      },\r\n      a = gi(t, n, i),\r\n      r = gi(n, o, i),\r\n      l = gi(o, e, i),\r\n      h = gi(a, r, i),\r\n      c = gi(r, l, i);\r\n    return gi(h, c, i)\r\n  }\r\n  const xi = \/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$\/,\r\n    bi = \/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$\/;\r\n\r\n  function _i(t, e) {\r\n    const i = (&quot;&quot; + t).match(xi);\r\n    if (!i || &quot;normal&quot; === i[1]) return 1.2 * e;\r\n    switch (t = +i[2], i[3]) {\r\n      case &quot;px&quot;:\r\n        return t;\r\n      case &quot;%&quot;:\r\n        t \/= 100\r\n    }\r\n    return e * t\r\n  }\r\n  const yi = t =&gt; +t || 0;\r\n\r\n  function vi(t, e) {\r\n    const i = {},\r\n      s = o(e),\r\n      n = s ? Object.keys(e) : e,\r\n      a = o(t) ? s ? i =&gt; l(t[i], t[e[i]]) : e =&gt; t[e] : () =&gt; t;\r\n    for (const t of n) i[t] = yi(a(t));\r\n    return i\r\n  }\r\n\r\n  function Mi(t) {\r\n    return vi(t, {\r\n      top: &quot;y&quot;,\r\n      right: &quot;x&quot;,\r\n      bottom: &quot;y&quot;,\r\n      left: &quot;x&quot;\r\n    })\r\n  }\r\n\r\n  function wi(t) {\r\n    return vi(t, [&quot;topLeft&quot;, &quot;topRight&quot;, &quot;bottomLeft&quot;, &quot;bottomRight&quot;])\r\n  }\r\n\r\n  function ki(t) {\r\n    const e = Mi(t);\r\n    return e.width = e.left + e.right, e.height = e.top + e.bottom, e\r\n  }\r\n\r\n  function Si(t, e) {\r\n    t = t || {}, e = e || ue.font;\r\n    let i = l(t.size, e.size);\r\n    &quot;string&quot; == typeof i &amp;&amp; (i = parseInt(i, 10));\r\n    let s = l(t.style, e.style);\r\n    s &amp;&amp; !(&quot;&quot; + s).match(bi) &amp;&amp; (console.warn(&#039;Invalid font style specified: &quot;&#039; + s + &#039;&quot;&#039;), s = void 0);\r\n    const n = {\r\n      family: l(t.family, e.family),\r\n      lineHeight: _i(l(t.lineHeight, e.lineHeight), i),\r\n      size: i,\r\n      style: s,\r\n      weight: l(t.weight, e.weight),\r\n      string: &quot;&quot;\r\n    };\r\n    return n.string = De(n), n\r\n  }\r\n\r\n  function Pi(t, e, i, s) {\r\n    let o, a, r, l = !0;\r\n    for (o = 0, a = t.length; o &lt; a; ++o)\r\n      if (r = t[o], void 0 !== r &amp;&amp; (void 0 !== e &amp;&amp; &quot;function&quot; == typeof r &amp;&amp; (r = r(e), l = !1), void 0 !== i &amp;&amp; n(r) &amp;&amp; (r = r[i % r.length], l = !1), void 0 !== r)) return s &amp;&amp; !l &amp;&amp; (s.cacheable = !1), r\r\n  }\r\n\r\n  function Di(t, e, i) {\r\n    const {\r\n      min: s,\r\n      max: n\r\n    } = t, o = c(e, (n - s) \/ 2), a = (t, e) =&gt; i &amp;&amp; 0 === t ? 0 : t + e;\r\n    return {\r\n      min: a(s, -Math.abs(o)),\r\n      max: a(n, o)\r\n    }\r\n  }\r\n\r\n  function Ci(t, e) {\r\n    return Object.assign(Object.create(t), e)\r\n  }\r\n\r\n  function Oi(t, e, i) {\r\n    return t ? function(t, e) {\r\n      return {\r\n        x: i =&gt; t + t + e - i,\r\n        setWidth(t) {\r\n          e = t\r\n        },\r\n        textAlign: t =&gt; &quot;center&quot; === t ? t : &quot;right&quot; === t ? &quot;left&quot; : &quot;right&quot;,\r\n        xPlus: (t, e) =&gt; t - e,\r\n        leftForLtr: (t, e) =&gt; t - e\r\n      }\r\n    }(e, i) : {\r\n      x: t =&gt; t,\r\n      setWidth(t) {},\r\n      textAlign: t =&gt; t,\r\n      xPlus: (t, e) =&gt; t + e,\r\n      leftForLtr: (t, e) =&gt; t\r\n    }\r\n  }\r\n\r\n  function Ai(t, e) {\r\n    let i, s;\r\n    &quot;ltr&quot; !== e &amp;&amp; &quot;rtl&quot; !== e || (i = t.canvas.style, s = [i.getPropertyValue(&quot;direction&quot;), i.getPropertyPriority(&quot;direction&quot;)], i.setProperty(&quot;direction&quot;, e, &quot;important&quot;), t.prevTextDirection = s)\r\n  }\r\n\r\n  function Ti(t, e) {\r\n    void 0 !== e &amp;&amp; (delete t.prevTextDirection, t.canvas.style.setProperty(&quot;direction&quot;, e[0], e[1]))\r\n  }\r\n\r\n  function Li(t) {\r\n    return &quot;angle&quot; === t ? {\r\n      between: Z,\r\n      compare: K,\r\n      normalize: G\r\n    } : {\r\n      between: tt,\r\n      compare: (t, e) =&gt; t - e,\r\n      normalize: t =&gt; t\r\n    }\r\n  }\r\n\r\n  function Ei({\r\n    start: t,\r\n    end: e,\r\n    count: i,\r\n    loop: s,\r\n    style: n\r\n  }) {\r\n    return {\r\n      start: t % i,\r\n      end: e % i,\r\n      loop: s &amp;&amp; (e - t + 1) % i == 0,\r\n      style: n\r\n    }\r\n  }\r\n\r\n  function Ri(t, e, i) {\r\n    if (!i) return [t];\r\n    const {\r\n      property: s,\r\n      start: n,\r\n      end: o\r\n    } = i, a = e.length, {\r\n      compare: r,\r\n      between: l,\r\n      normalize: h\r\n    } = Li(s), {\r\n      start: c,\r\n      end: d,\r\n      loop: u,\r\n      style: f\r\n    } = function(t, e, i) {\r\n      const {\r\n        property: s,\r\n        start: n,\r\n        end: o\r\n      } = i, {\r\n        between: a,\r\n        normalize: r\r\n      } = Li(s), l = e.length;\r\n      let h, c, {\r\n        start: d,\r\n        end: u,\r\n        loop: f\r\n      } = t;\r\n      if (f) {\r\n        for (d += l, u += l, h = 0, c = l; h &lt; c &amp;&amp; a(r(e[d % l][s]), n, o); ++h) d--, u--;\r\n        d %= l, u %= l\r\n      }\r\n      return u &lt; d &amp;&amp; (u += l), {\r\n        start: d,\r\n        end: u,\r\n        loop: f,\r\n        style: t.style\r\n      }\r\n    }(t, e, i), g = [];\r\n    let p, m, x, b = !1,\r\n      _ = null;\r\n    const y = () =&gt; b || l(n, x, p) &amp;&amp; 0 !== r(n, x),\r\n      v = () =&gt; !b || 0 === r(o, p) || l(o, x, p);\r\n    for (let t = c, i = c; t &lt;= d; ++t) m = e[t % a], m.skip || (p = h(m[s]), p !== x &amp;&amp; (b = l(p, n, o), null === _ &amp;&amp; y() &amp;&amp; (_ = 0 === r(p, n) ? t : i), null !== _ &amp;&amp; v() &amp;&amp; (g.push(Ei({\r\n      start: _,\r\n      end: t,\r\n      loop: u,\r\n      count: a,\r\n      style: f\r\n    })), _ = null), i = t, x = p));\r\n    return null !== _ &amp;&amp; g.push(Ei({\r\n      start: _,\r\n      end: d,\r\n      loop: u,\r\n      count: a,\r\n      style: f\r\n    })), g\r\n  }\r\n\r\n  function Ii(t, e) {\r\n    const i = [],\r\n      s = t.segments;\r\n    for (let n = 0; n &lt; s.length; n++) {\r\n      const o = Ri(s[n], t.points, e);\r\n      o.length &amp;&amp; i.push(...o)\r\n    }\r\n    return i\r\n  }\r\n\r\n  function zi(t, e) {\r\n    const i = t.points,\r\n      s = t.options.spanGaps,\r\n      n = i.length;\r\n    if (!n) return [];\r\n    const o = !!t._loop,\r\n      {\r\n        start: a,\r\n        end: r\r\n      } = function(t, e, i, s) {\r\n        let n = 0,\r\n          o = e - 1;\r\n        if (i &amp;&amp; !s)\r\n          for (; n &lt; e &amp;&amp; !t[n].skip;) n++;\r\n        for (; n &lt; e &amp;&amp; t[n].skip;) n++;\r\n        for (n %= e, i &amp;&amp; (o += n); o &gt; n &amp;&amp; t[o % e].skip;) o--;\r\n        return o %= e, {\r\n          start: n,\r\n          end: o\r\n        }\r\n      }(i, n, o, s);\r\n    if (!0 === s) return Fi(t, [{\r\n      start: a,\r\n      end: r,\r\n      loop: o\r\n    }], i, e);\r\n    return Fi(t, function(t, e, i, s) {\r\n      const n = t.length,\r\n        o = [];\r\n      let a, r = e,\r\n        l = t[e];\r\n      for (a = e + 1; a &lt;= i; ++a) {\r\n        const i = t[a % n];\r\n        i.skip || i.stop ? l.skip || (s = !1, o.push({\r\n          start: e % n,\r\n          end: (a - 1) % n,\r\n          loop: s\r\n        }), e = r = i.stop ? a : null) : (r = a, l.skip &amp;&amp; (e = a)), l = i\r\n      }\r\n      return null !== r &amp;&amp; o.push({\r\n        start: e % n,\r\n        end: r % n,\r\n        loop: s\r\n      }), o\r\n    }(i, a, r &lt; a ? r + n : r, !!t._fullLoop &amp;&amp; 0 === a &amp;&amp; r === n - 1), i, e)\r\n  }\r\n\r\n  function Fi(t, e, i, s) {\r\n    return s &amp;&amp; s.setContext &amp;&amp; i ? function(t, e, i, s) {\r\n      const n = t._chart.getContext(),\r\n        o = Vi(t.options),\r\n        {\r\n          _datasetIndex: a,\r\n          options: {\r\n            spanGaps: r\r\n          }\r\n        } = t,\r\n        l = i.length,\r\n        h = [];\r\n      let c = o,\r\n        d = e[0].start,\r\n        u = d;\r\n\r\n      function f(t, e, s, n) {\r\n        const o = r ? -1 : 1;\r\n        if (t !== e) {\r\n          for (t += l; i[t % l].skip;) t -= o;\r\n          for (; i[e % l].skip;) e += o;\r\n          t % l != e % l &amp;&amp; (h.push({\r\n            start: t % l,\r\n            end: e % l,\r\n            loop: s,\r\n            style: n\r\n          }), c = n, d = e % l)\r\n        }\r\n      }\r\n      for (const t of e) {\r\n        d = r ? d : t.start;\r\n        let e, o = i[d % l];\r\n        for (u = d + 1; u &lt;= t.end; u++) {\r\n          const r = i[u % l];\r\n          e = Vi(s.setContext(Ci(n, {\r\n            type: &quot;segment&quot;,\r\n            p0: o,\r\n            p1: r,\r\n            p0DataIndex: (u - 1) % l,\r\n            p1DataIndex: u % l,\r\n            datasetIndex: a\r\n          }))), Bi(e, c) &amp;&amp; f(d, u - 1, t.loop, c), o = r, c = e\r\n        }\r\n        d &lt; u - 1 &amp;&amp; f(d, u - 1, t.loop, c)\r\n      }\r\n      return h\r\n    }(t, e, i, s) : e\r\n  }\r\n\r\n  function Vi(t) {\r\n    return {\r\n      backgroundColor: t.backgroundColor,\r\n      borderCapStyle: t.borderCapStyle,\r\n      borderDash: t.borderDash,\r\n      borderDashOffset: t.borderDashOffset,\r\n      borderJoinStyle: t.borderJoinStyle,\r\n      borderWidth: t.borderWidth,\r\n      borderColor: t.borderColor\r\n    }\r\n  }\r\n\r\n  function Bi(t, e) {\r\n    if (!e) return !1;\r\n    const i = [],\r\n      s = function(t, e) {\r\n        return Jt(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e\r\n      };\r\n    return JSON.stringify(t, s) !== JSON.stringify(e, s)\r\n  }\r\n  var Wi = Object.freeze({\r\n    __proto__: null,\r\n    HALF_PI: E,\r\n    INFINITY: T,\r\n    PI: C,\r\n    PITAU: A,\r\n    QUARTER_PI: R,\r\n    RAD_PER_DEG: L,\r\n    TAU: O,\r\n    TWO_THIRDS_PI: I,\r\n    _addGrace: Di,\r\n    _alignPixel: Ae,\r\n    _alignStartEnd: ft,\r\n    _angleBetween: Z,\r\n    _angleDiff: K,\r\n    _arrayUnique: lt,\r\n    _attachContext: $e,\r\n    _bezierCurveTo: Ve,\r\n    _bezierInterpolation: mi,\r\n    _boundSegment: Ri,\r\n    _boundSegments: Ii,\r\n    _capitalize: w,\r\n    _computeSegments: zi,\r\n    _createResolver: je,\r\n    _decimalPlaces: U,\r\n    _deprecated: function(t, e, i, s) {\r\n      void 0 !== e &amp;&amp; console.warn(t + &#039;: &quot;&#039; + i + &#039;&quot; is deprecated. Please use &quot;&#039; + s + &#039;&quot; instead&#039;)\r\n    },\r\n    _descriptors: Ye,\r\n    _elementsEqual: f,\r\n    _factorize: W,\r\n    _filterBetween: nt,\r\n    _getParentNode: ge,\r\n    _getStartAndCountOfVisiblePoints: pt,\r\n    _int16Range: Q,\r\n    _isBetween: tt,\r\n    _isClickEvent: D,\r\n    _isDomSupported: fe,\r\n    _isPointInArea: Re,\r\n    _limitValue: J,\r\n    _longestText: Oe,\r\n    _lookup: et,\r\n    _lookupByKey: it,\r\n    _measureText: Ce,\r\n    _merger: m,\r\n    _mergerIf: _,\r\n    _normalizeAngle: G,\r\n    _parseObjectDataRadialScale: ii,\r\n    _pointInLine: gi,\r\n    _readValueToProps: vi,\r\n    _rlookupByKey: st,\r\n    _scaleRangesChanged: mt,\r\n    _setMinAndMaxByKey: j,\r\n    _splitKey: v,\r\n    _steppedInterpolation: pi,\r\n    _steppedLineTo: Fe,\r\n    _textX: gt,\r\n    _toLeftRightCenter: ut,\r\n    _updateBezierControlPoints: hi,\r\n    addRoundedRectPath: He,\r\n    almostEquals: V,\r\n    almostWhole: H,\r\n    callback: d,\r\n    clearCanvas: Te,\r\n    clipArea: Ie,\r\n    clone: g,\r\n    color: Qt,\r\n    createContext: Ci,\r\n    debounce: dt,\r\n    defined: k,\r\n    distanceBetweenPoints: q,\r\n    drawPoint: Le,\r\n    drawPointLegend: Ee,\r\n    each: u,\r\n    easingEffects: fi,\r\n    finiteOrDefault: r,\r\n    fontString: function(t, e, i) {\r\n      return e + &quot; &quot; + t + &quot;px &quot; + i\r\n    },\r\n    formatNumber: ne,\r\n    getAngleFromPoint: X,\r\n    getHoverColor: te,\r\n    getMaximumSize: we,\r\n    getRelativePosition: ve,\r\n    getRtlAdapter: Oi,\r\n    getStyle: xe,\r\n    isArray: n,\r\n    isFinite: a,\r\n    isFunction: S,\r\n    isNullOrUndef: s,\r\n    isNumber: N,\r\n    isObject: o,\r\n    isPatternOrGradient: Jt,\r\n    listenArrayEvents: at,\r\n    log10: z,\r\n    merge: x,\r\n    mergeIf: b,\r\n    niceNum: B,\r\n    noop: e,\r\n    overrideTextDirection: Ai,\r\n    readUsedSize: Pe,\r\n    renderText: Ne,\r\n    requestAnimFrame: ht,\r\n    resolve: Pi,\r\n    resolveObjectKey: M,\r\n    restoreTextDirection: Ti,\r\n    retinaScale: ke,\r\n    setsEqual: P,\r\n    sign: F,\r\n    splineCurve: ai,\r\n    splineCurveMonotone: ri,\r\n    supportsEventListenerOptions: Se,\r\n    throttled: ct,\r\n    toDegrees: Y,\r\n    toDimension: c,\r\n    toFont: Si,\r\n    toFontString: De,\r\n    toLineHeight: _i,\r\n    toPadding: ki,\r\n    toPercentage: h,\r\n    toRadians: $,\r\n    toTRBL: Mi,\r\n    toTRBLCorners: wi,\r\n    uid: i,\r\n    unclipArea: ze,\r\n    unlistenArrayEvents: rt,\r\n    valueOrDefault: l\r\n  });\r\n\r\n  function Ni(t, e, i, s) {\r\n    const {\r\n      controller: n,\r\n      data: o,\r\n      _sorted: a\r\n    } = t, r = n._cachedMeta.iScale;\r\n    if (r &amp;&amp; e === r.axis &amp;&amp; &quot;r&quot; !== e &amp;&amp; a &amp;&amp; o.length) {\r\n      const t = r._reversePixels ? st : it;\r\n      if (!s) return t(o, e, i);\r\n      if (n._sharedOptions) {\r\n        const s = o[0],\r\n          n = &quot;function&quot; == typeof s.getRange &amp;&amp; s.getRange(e);\r\n        if (n) {\r\n          const s = t(o, e, i - n),\r\n            a = t(o, e, i + n);\r\n          return {\r\n            lo: s.lo,\r\n            hi: a.hi\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      lo: 0,\r\n      hi: o.length - 1\r\n    }\r\n  }\r\n\r\n  function Hi(t, e, i, s, n) {\r\n    const o = t.getSortedVisibleDatasetMetas(),\r\n      a = i[e];\r\n    for (let t = 0, i = o.length; t &lt; i; ++t) {\r\n      const {\r\n        index: i,\r\n        data: r\r\n      } = o[t], {\r\n        lo: l,\r\n        hi: h\r\n      } = Ni(o[t], e, a, n);\r\n      for (let t = l; t &lt;= h; ++t) {\r\n        const e = r[t];\r\n        e.skip || s(e, i, t)\r\n      }\r\n    }\r\n  }\r\n\r\n  function ji(t, e, i, s, n) {\r\n    const o = [];\r\n    if (!n &amp;&amp; !t.isPointInArea(e)) return o;\r\n    return Hi(t, i, e, (function(i, a, r) {\r\n      (n || Re(i, t.chartArea, 0)) &amp;&amp; i.inRange(e.x, e.y, s) &amp;&amp; o.push({\r\n        element: i,\r\n        datasetIndex: a,\r\n        index: r\r\n      })\r\n    }), !0), o\r\n  }\r\n\r\n  function $i(t, e, i, s, n, o) {\r\n    let a = [];\r\n    const r = function(t) {\r\n      const e = -1 !== t.indexOf(&quot;x&quot;),\r\n        i = -1 !== t.indexOf(&quot;y&quot;);\r\n      return function(t, s) {\r\n        const n = e ? Math.abs(t.x - s.x) : 0,\r\n          o = i ? Math.abs(t.y - s.y) : 0;\r\n        return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2))\r\n      }\r\n    }(i);\r\n    let l = Number.POSITIVE_INFINITY;\r\n    return Hi(t, i, e, (function(i, h, c) {\r\n      const d = i.inRange(e.x, e.y, n);\r\n      if (s &amp;&amp; !d) return;\r\n      const u = i.getCenterPoint(n);\r\n      if (!(!!o || t.isPointInArea(u)) &amp;&amp; !d) return;\r\n      const f = r(e, u);\r\n      f &lt; l ? (a = [{\r\n        element: i,\r\n        datasetIndex: h,\r\n        index: c\r\n      }], l = f) : f === l &amp;&amp; a.push({\r\n        element: i,\r\n        datasetIndex: h,\r\n        index: c\r\n      })\r\n    })), a\r\n  }\r\n\r\n  function Yi(t, e, i, s, n, o) {\r\n    return o || t.isPointInArea(e) ? &quot;r&quot; !== i || s ? $i(t, e, i, s, n, o) : function(t, e, i, s) {\r\n      let n = [];\r\n      return Hi(t, i, e, (function(t, i, o) {\r\n        const {\r\n          startAngle: a,\r\n          endAngle: r\r\n        } = t.getProps([&quot;startAngle&quot;, &quot;endAngle&quot;], s), {\r\n          angle: l\r\n        } = X(t, {\r\n          x: e.x,\r\n          y: e.y\r\n        });\r\n        Z(l, a, r) &amp;&amp; n.push({\r\n          element: t,\r\n          datasetIndex: i,\r\n          index: o\r\n        })\r\n      })), n\r\n    }(t, e, i, n) : []\r\n  }\r\n\r\n  function Ui(t, e, i, s, n) {\r\n    const o = [],\r\n      a = &quot;x&quot; === i ? &quot;inXRange&quot; : &quot;inYRange&quot;;\r\n    let r = !1;\r\n    return Hi(t, i, e, ((t, s, l) =&gt; {\r\n      t[a](e[i], n) &amp;&amp; (o.push({\r\n        element: t,\r\n        datasetIndex: s,\r\n        index: l\r\n      }), r = r || t.inRange(e.x, e.y, n))\r\n    })), s &amp;&amp; !r ? [] : o\r\n  }\r\n  var Xi = {\r\n    evaluateInteractionItems: Hi,\r\n    modes: {\r\n      index(t, e, i, s) {\r\n        const n = ve(e, t),\r\n          o = i.axis || &quot;x&quot;,\r\n          a = i.includeInvisible || !1,\r\n          r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a),\r\n          l = [];\r\n        return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t =&gt; {\r\n          const e = r[0].index,\r\n            i = t.data[e];\r\n          i &amp;&amp; !i.skip &amp;&amp; l.push({\r\n            element: i,\r\n            datasetIndex: t.index,\r\n            index: e\r\n          })\r\n        })), l) : []\r\n      },\r\n      dataset(t, e, i, s) {\r\n        const n = ve(e, t),\r\n          o = i.axis || &quot;xy&quot;,\r\n          a = i.includeInvisible || !1;\r\n        let r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a);\r\n        if (r.length &gt; 0) {\r\n          const e = r[0].datasetIndex,\r\n            i = t.getDatasetMeta(e).data;\r\n          r = [];\r\n          for (let t = 0; t &lt; i.length; ++t) r.push({\r\n            element: i[t],\r\n            datasetIndex: e,\r\n            index: t\r\n          })\r\n        }\r\n        return r\r\n      },\r\n      point: (t, e, i, s) =&gt; ji(t, ve(e, t), i.axis || &quot;xy&quot;, s, i.includeInvisible || !1),\r\n      nearest(t, e, i, s) {\r\n        const n = ve(e, t),\r\n          o = i.axis || &quot;xy&quot;,\r\n          a = i.includeInvisible || !1;\r\n        return Yi(t, n, o, i.intersect, s, a)\r\n      },\r\n      x: (t, e, i, s) =&gt; Ui(t, ve(e, t), &quot;x&quot;, i.intersect, s),\r\n      y: (t, e, i, s) =&gt; Ui(t, ve(e, t), &quot;y&quot;, i.intersect, s)\r\n    }\r\n  };\r\n  const qi = [&quot;left&quot;, &quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;];\r\n\r\n  function Ki(t, e) {\r\n    return t.filter((t =&gt; t.pos === e))\r\n  }\r\n\r\n  function Gi(t, e) {\r\n    return t.filter((t =&gt; -1 === qi.indexOf(t.pos) &amp;&amp; t.box.axis === e))\r\n  }\r\n\r\n  function Zi(t, e) {\r\n    return t.sort(((t, i) =&gt; {\r\n      const s = e ? i : t,\r\n        n = e ? t : i;\r\n      return s.weight === n.weight ? s.index - n.index : s.weight - n.weight\r\n    }))\r\n  }\r\n\r\n  function Ji(t, e) {\r\n    const i = function(t) {\r\n        const e = {};\r\n        for (const i of t) {\r\n          const {\r\n            stack: t,\r\n            pos: s,\r\n            stackWeight: n\r\n          } = i;\r\n          if (!t || !qi.includes(s)) continue;\r\n          const o = e[t] || (e[t] = {\r\n            count: 0,\r\n            placed: 0,\r\n            weight: 0,\r\n            size: 0\r\n          });\r\n          o.count++, o.weight += n\r\n        }\r\n        return e\r\n      }(t),\r\n      {\r\n        vBoxMaxWidth: s,\r\n        hBoxMaxHeight: n\r\n      } = e;\r\n    let o, a, r;\r\n    for (o = 0, a = t.length; o &lt; a; ++o) {\r\n      r = t[o];\r\n      const {\r\n        fullSize: a\r\n      } = r.box, l = i[r.stack], h = l &amp;&amp; r.stackWeight \/ l.weight;\r\n      r.horizontal ? (r.width = h ? h * s : a &amp;&amp; e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a &amp;&amp; e.availableHeight)\r\n    }\r\n    return i\r\n  }\r\n\r\n  function Qi(t, e, i, s) {\r\n    return Math.max(t[i], e[i]) + Math.max(t[s], e[s])\r\n  }\r\n\r\n  function ts(t, e) {\r\n    t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)\r\n  }\r\n\r\n  function es(t, e, i, s) {\r\n    const {\r\n      pos: n,\r\n      box: a\r\n    } = i, r = t.maxPadding;\r\n    if (!o(n)) {\r\n      i.size &amp;&amp; (t[n] -= i.size);\r\n      const e = s[i.stack] || {\r\n        size: 0,\r\n        count: 1\r\n      };\r\n      e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size \/ e.count, t[n] += i.size\r\n    }\r\n    a.getPadding &amp;&amp; ts(r, a.getPadding());\r\n    const l = Math.max(0, e.outerWidth - Qi(r, t, &quot;left&quot;, &quot;right&quot;)),\r\n      h = Math.max(0, e.outerHeight - Qi(r, t, &quot;top&quot;, &quot;bottom&quot;)),\r\n      c = l !== t.w,\r\n      d = h !== t.h;\r\n    return t.w = l, t.h = h, i.horizontal ? {\r\n      same: c,\r\n      other: d\r\n    } : {\r\n      same: d,\r\n      other: c\r\n    }\r\n  }\r\n\r\n  function is(t, e) {\r\n    const i = e.maxPadding;\r\n\r\n    function s(t) {\r\n      const s = {\r\n        left: 0,\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      };\r\n      return t.forEach((t =&gt; {\r\n        s[t] = Math.max(e[t], i[t])\r\n      })), s\r\n    }\r\n    return s(t ? [&quot;left&quot;, &quot;right&quot;] : [&quot;top&quot;, &quot;bottom&quot;])\r\n  }\r\n\r\n  function ss(t, e, i, s) {\r\n    const n = [];\r\n    let o, a, r, l, h, c;\r\n    for (o = 0, a = t.length, h = 0; o &lt; a; ++o) {\r\n      r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, is(r.horizontal, e));\r\n      const {\r\n        same: a,\r\n        other: d\r\n      } = es(e, i, r, s);\r\n      h |= a &amp;&amp; n.length, c = c || d, l.fullSize || n.push(r)\r\n    }\r\n    return h &amp;&amp; ss(n, e, i, s) || c\r\n  }\r\n\r\n  function ns(t, e, i, s, n) {\r\n    t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n\r\n  }\r\n\r\n  function os(t, e, i, s) {\r\n    const n = i.padding;\r\n    let {\r\n      x: o,\r\n      y: a\r\n    } = e;\r\n    for (const r of t) {\r\n      const t = r.box,\r\n        l = s[r.stack] || {\r\n          count: 1,\r\n          placed: 0,\r\n          weight: 1\r\n        },\r\n        h = r.stackWeight \/ l.weight || 1;\r\n      if (r.horizontal) {\r\n        const s = e.w * h,\r\n          o = l.size || t.height;\r\n        k(l.start) &amp;&amp; (a = l.start), t.fullSize ? ns(t, n.left, a, i.outerWidth - n.right - n.left, o) : ns(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom\r\n      } else {\r\n        const s = e.h * h,\r\n          a = l.size || t.width;\r\n        k(l.start) &amp;&amp; (o = l.start), t.fullSize ? ns(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : ns(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right\r\n      }\r\n    }\r\n    e.x = o, e.y = a\r\n  }\r\n  var as = {\r\n    addBox(t, e) {\r\n      t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || &quot;top&quot;, e.weight = e.weight || 0, e._layers = e._layers || function() {\r\n        return [{\r\n          z: 0,\r\n          draw(t) {\r\n            e.draw(t)\r\n          }\r\n        }]\r\n      }, t.boxes.push(e)\r\n    },\r\n    removeBox(t, e) {\r\n      const i = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== i &amp;&amp; t.boxes.splice(i, 1)\r\n    },\r\n    configure(t, e, i) {\r\n      e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight\r\n    },\r\n    update(t, e, i, s) {\r\n      if (!t) return;\r\n      const n = ki(t.options.layout.padding),\r\n        o = Math.max(e - n.width, 0),\r\n        a = Math.max(i - n.height, 0),\r\n        r = function(t) {\r\n          const e = function(t) {\r\n              const e = [];\r\n              let i, s, n, o, a, r;\r\n              for (i = 0, s = (t || []).length; i &lt; s; ++i) n = t[i], ({\r\n                position: o,\r\n                options: {\r\n                  stack: a,\r\n                  stackWeight: r = 1\r\n                }\r\n              } = n), e.push({\r\n                index: i,\r\n                box: n,\r\n                pos: o,\r\n                horizontal: n.isHorizontal(),\r\n                weight: n.weight,\r\n                stack: a &amp;&amp; o + a,\r\n                stackWeight: r\r\n              });\r\n              return e\r\n            }(t),\r\n            i = Zi(e.filter((t =&gt; t.box.fullSize)), !0),\r\n            s = Zi(Ki(e, &quot;left&quot;), !0),\r\n            n = Zi(Ki(e, &quot;right&quot;)),\r\n            o = Zi(Ki(e, &quot;top&quot;), !0),\r\n            a = Zi(Ki(e, &quot;bottom&quot;)),\r\n            r = Gi(e, &quot;x&quot;),\r\n            l = Gi(e, &quot;y&quot;);\r\n          return {\r\n            fullSize: i,\r\n            leftAndTop: s.concat(o),\r\n            rightAndBottom: n.concat(l).concat(a).concat(r),\r\n            chartArea: Ki(e, &quot;chartArea&quot;),\r\n            vertical: s.concat(n).concat(l),\r\n            horizontal: o.concat(a).concat(r)\r\n          }\r\n        }(t.boxes),\r\n        l = r.vertical,\r\n        h = r.horizontal;\r\n      u(t.boxes, (t =&gt; {\r\n        &quot;function&quot; == typeof t.beforeLayout &amp;&amp; t.beforeLayout()\r\n      }));\r\n      const c = l.reduce(((t, e) =&gt; e.box.options &amp;&amp; !1 === e.box.options.display ? t : t + 1), 0) || 1,\r\n        d = Object.freeze({\r\n          outerWidth: e,\r\n          outerHeight: i,\r\n          padding: n,\r\n          availableWidth: o,\r\n          availableHeight: a,\r\n          vBoxMaxWidth: o \/ 2 \/ c,\r\n          hBoxMaxHeight: a \/ 2\r\n        }),\r\n        f = Object.assign({}, n);\r\n      ts(f, ki(s));\r\n      const g = Object.assign({\r\n          maxPadding: f,\r\n          w: o,\r\n          h: a,\r\n          x: n.left,\r\n          y: n.top\r\n        }, n),\r\n        p = Ji(l.concat(h), d);\r\n      ss(r.fullSize, g, d, p), ss(l, g, d, p), ss(h, g, d, p) &amp;&amp; ss(l, g, d, p),\r\n        function(t) {\r\n          const e = t.maxPadding;\r\n\r\n          function i(i) {\r\n            const s = Math.max(e[i] - t[i], 0);\r\n            return t[i] += s, s\r\n          }\r\n          t.y += i(&quot;top&quot;), t.x += i(&quot;left&quot;), i(&quot;right&quot;), i(&quot;bottom&quot;)\r\n        }(g), os(r.leftAndTop, g, d, p), g.x += g.w, g.y += g.h, os(r.rightAndBottom, g, d, p), t.chartArea = {\r\n          left: g.left,\r\n          top: g.top,\r\n          right: g.left + g.w,\r\n          bottom: g.top + g.h,\r\n          height: g.h,\r\n          width: g.w\r\n        }, u(r.chartArea, (e =&gt; {\r\n          const i = e.box;\r\n          Object.assign(i, t.chartArea), i.update(g.w, g.h, {\r\n            left: 0,\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0\r\n          })\r\n        }))\r\n    }\r\n  };\r\n  class rs {\r\n    acquireContext(t, e) {}\r\n    releaseContext(t) {\r\n      return !1\r\n    }\r\n    addEventListener(t, e, i) {}\r\n    removeEventListener(t, e, i) {}\r\n    getDevicePixelRatio() {\r\n      return 1\r\n    }\r\n    getMaximumSize(t, e, i, s) {\r\n      return e = Math.max(0, e || t.width), i = i || t.height, {\r\n        width: e,\r\n        height: Math.max(0, s ? Math.floor(e \/ s) : i)\r\n      }\r\n    }\r\n    isAttached(t) {\r\n      return !0\r\n    }\r\n    updateConfig(t) {}\r\n  }\r\n  class ls extends rs {\r\n    acquireContext(t) {\r\n      return t &amp;&amp; t.getContext &amp;&amp; t.getContext(&quot;2d&quot;) || null\r\n    }\r\n    updateConfig(t) {\r\n      t.options.animation = !1\r\n    }\r\n  }\r\n  const hs = &quot;$chartjs&quot;,\r\n    cs = {\r\n      touchstart: &quot;mousedown&quot;,\r\n      touchmove: &quot;mousemove&quot;,\r\n      touchend: &quot;mouseup&quot;,\r\n      pointerenter: &quot;mouseenter&quot;,\r\n      pointerdown: &quot;mousedown&quot;,\r\n      pointermove: &quot;mousemove&quot;,\r\n      pointerup: &quot;mouseup&quot;,\r\n      pointerleave: &quot;mouseout&quot;,\r\n      pointerout: &quot;mouseout&quot;\r\n    },\r\n    ds = t =&gt; null === t || &quot;&quot; === t;\r\n  const us = !!Se &amp;&amp; {\r\n    passive: !0\r\n  };\r\n\r\n  function fs(t, e, i) {\r\n    t &amp;&amp; t.canvas &amp;&amp; t.canvas.removeEventListener(e, i, us)\r\n  }\r\n\r\n  function gs(t, e) {\r\n    for (const i of t)\r\n      if (i === e || i.contains(e)) return !0\r\n  }\r\n\r\n  function ps(t, e, i) {\r\n    const s = t.canvas,\r\n      n = new MutationObserver((t =&gt; {\r\n        let e = !1;\r\n        for (const i of t) e = e || gs(i.addedNodes, s), e = e &amp;&amp; !gs(i.removedNodes, s);\r\n        e &amp;&amp; i()\r\n      }));\r\n    return n.observe(document, {\r\n      childList: !0,\r\n      subtree: !0\r\n    }), n\r\n  }\r\n\r\n  function ms(t, e, i) {\r\n    const s = t.canvas,\r\n      n = new MutationObserver((t =&gt; {\r\n        let e = !1;\r\n        for (const i of t) e = e || gs(i.removedNodes, s), e = e &amp;&amp; !gs(i.addedNodes, s);\r\n        e &amp;&amp; i()\r\n      }));\r\n    return n.observe(document, {\r\n      childList: !0,\r\n      subtree: !0\r\n    }), n\r\n  }\r\n  const xs = new Map;\r\n  let bs = 0;\r\n\r\n  function _s() {\r\n    const t = window.devicePixelRatio;\r\n    t !== bs &amp;&amp; (bs = t, xs.forEach(((e, i) =&gt; {\r\n      i.currentDevicePixelRatio !== t &amp;&amp; e()\r\n    })))\r\n  }\r\n\r\n  function ys(t, e, i) {\r\n    const s = t.canvas,\r\n      n = s &amp;&amp; ge(s);\r\n    if (!n) return;\r\n    const o = ct(((t, e) =&gt; {\r\n        const s = n.clientWidth;\r\n        i(t, e), s &lt; n.clientWidth &amp;&amp; i()\r\n      }), window),\r\n      a = new ResizeObserver((t =&gt; {\r\n        const e = t[0],\r\n          i = e.contentRect.width,\r\n          s = e.contentRect.height;\r\n        0 === i &amp;&amp; 0 === s || o(i, s)\r\n      }));\r\n    return a.observe(n),\r\n      function(t, e) {\r\n        xs.size || window.addEventListener(&quot;resize&quot;, _s), xs.set(t, e)\r\n      }(t, o), a\r\n  }\r\n\r\n  function vs(t, e, i) {\r\n    i &amp;&amp; i.disconnect(), &quot;resize&quot; === e &amp;&amp; function(t) {\r\n      xs.delete(t), xs.size || window.removeEventListener(&quot;resize&quot;, _s)\r\n    }(t)\r\n  }\r\n\r\n  function Ms(t, e, i) {\r\n    const s = t.canvas,\r\n      n = ct((e =&gt; {\r\n        null !== t.ctx &amp;&amp; i(function(t, e) {\r\n          const i = cs[t.type] || t.type,\r\n            {\r\n              x: s,\r\n              y: n\r\n            } = ve(t, e);\r\n          return {\r\n            type: i,\r\n            chart: e,\r\n            native: t,\r\n            x: void 0 !== s ? s : null,\r\n            y: void 0 !== n ? n : null\r\n          }\r\n        }(e, t))\r\n      }), t);\r\n    return function(t, e, i) {\r\n      t &amp;&amp; t.addEventListener(e, i, us)\r\n    }(s, e, n), n\r\n  }\r\n  class ws extends rs {\r\n    acquireContext(t, e) {\r\n      const i = t &amp;&amp; t.getContext &amp;&amp; t.getContext(&quot;2d&quot;);\r\n      return i &amp;&amp; i.canvas === t ? (function(t, e) {\r\n        const i = t.style,\r\n          s = t.getAttribute(&quot;height&quot;),\r\n          n = t.getAttribute(&quot;width&quot;);\r\n        if (t[hs] = {\r\n            initial: {\r\n              height: s,\r\n              width: n,\r\n              style: {\r\n                display: i.display,\r\n                height: i.height,\r\n                width: i.width\r\n              }\r\n            }\r\n          }, i.display = i.display || &quot;block&quot;, i.boxSizing = i.boxSizing || &quot;border-box&quot;, ds(n)) {\r\n          const e = Pe(t, &quot;width&quot;);\r\n          void 0 !== e &amp;&amp; (t.width = e)\r\n        }\r\n        if (ds(s))\r\n          if (&quot;&quot; === t.style.height) t.height = t.width \/ (e || 2);\r\n          else {\r\n            const e = Pe(t, &quot;height&quot;);\r\n            void 0 !== e &amp;&amp; (t.height = e)\r\n          }\r\n      }(t, e), i) : null\r\n    }\r\n    releaseContext(t) {\r\n      const e = t.canvas;\r\n      if (!e[hs]) return !1;\r\n      const i = e[hs].initial;\r\n      [&quot;height&quot;, &quot;width&quot;].forEach((t =&gt; {\r\n        const n = i[t];\r\n        s(n) ? e.removeAttribute(t) : e.setAttribute(t, n)\r\n      }));\r\n      const n = i.style || {};\r\n      return Object.keys(n).forEach((t =&gt; {\r\n        e.style[t] = n[t]\r\n      })), e.width = e.width, delete e[hs], !0\r\n    }\r\n    addEventListener(t, e, i) {\r\n      this.removeEventListener(t, e);\r\n      const s = t.$proxies || (t.$proxies = {}),\r\n        n = {\r\n          attach: ps,\r\n          detach: ms,\r\n          resize: ys\r\n        } [e] || Ms;\r\n      s[e] = n(t, e, i)\r\n    }\r\n    removeEventListener(t, e) {\r\n      const i = t.$proxies || (t.$proxies = {}),\r\n        s = i[e];\r\n      if (!s) return;\r\n      ({\r\n        attach: vs,\r\n        detach: vs,\r\n        resize: vs\r\n      } [e] || fs)(t, e, s), i[e] = void 0\r\n    }\r\n    getDevicePixelRatio() {\r\n      return window.devicePixelRatio\r\n    }\r\n    getMaximumSize(t, e, i, s) {\r\n      return we(t, e, i, s)\r\n    }\r\n    isAttached(t) {\r\n      const e = t &amp;&amp; ge(t);\r\n      return !(!e || !e.isConnected)\r\n    }\r\n  }\r\n\r\n  function ks(t) {\r\n    return !fe() || &quot;undefined&quot; != typeof OffscreenCanvas &amp;&amp; t instanceof OffscreenCanvas ? ls : ws\r\n  }\r\n  var Ss = Object.freeze({\r\n    __proto__: null,\r\n    BasePlatform: rs,\r\n    BasicPlatform: ls,\r\n    DomPlatform: ws,\r\n    _detectPlatform: ks\r\n  });\r\n  const Ps = &quot;transparent&quot;,\r\n    Ds = {\r\n      boolean: (t, e, i) =&gt; i &gt; .5 ? e : t,\r\n      color(t, e, i) {\r\n        const s = Qt(t || Ps),\r\n          n = s.valid &amp;&amp; Qt(e || Ps);\r\n        return n &amp;&amp; n.valid ? n.mix(s, i).hexString() : e\r\n      },\r\n      number: (t, e, i) =&gt; t + (e - t) * i\r\n    };\r\n  class Cs {\r\n    constructor(t, e, i, s) {\r\n      const n = e[i];\r\n      s = Pi([t.to, s, n, t.from]);\r\n      const o = Pi([t.from, n, s]);\r\n      this._active = !0, this._fn = t.fn || Ds[t.type || typeof o], this._easing = fi[t.easing] || fi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0\r\n    }\r\n    active() {\r\n      return this._active\r\n    }\r\n    update(t, e, i) {\r\n      if (this._active) {\r\n        this._notify(!1);\r\n        const s = this._target[this._prop],\r\n          n = i - this._start,\r\n          o = this._duration - n;\r\n        this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Pi([t.to, e, s, t.from]), this._from = Pi([t.from, s, e])\r\n      }\r\n    }\r\n    cancel() {\r\n      this._active &amp;&amp; (this.tick(Date.now()), this._active = !1, this._notify(!1))\r\n    }\r\n    tick(t) {\r\n      const e = t - this._start,\r\n        i = this._duration,\r\n        s = this._prop,\r\n        n = this._from,\r\n        o = this._loop,\r\n        a = this._to;\r\n      let r;\r\n      if (this._active = n !== a &amp;&amp; (o || e &lt; i), !this._active) return this._target[s] = a, void this._notify(!0);\r\n      e &lt; 0 ? this._target[s] = n : (r = e \/ i % 2, r = o &amp;&amp; r &gt; 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r))\r\n    }\r\n    wait() {\r\n      const t = this._promises || (this._promises = []);\r\n      return new Promise(((e, i) =&gt; {\r\n        t.push({\r\n          res: e,\r\n          rej: i\r\n        })\r\n      }))\r\n    }\r\n    _notify(t) {\r\n      const e = t ? &quot;res&quot; : &quot;rej&quot;,\r\n        i = this._promises || [];\r\n      for (let t = 0; t &lt; i.length; t++) i[t][e]()\r\n    }\r\n  }\r\n  class Os {\r\n    constructor(t, e) {\r\n      this._chart = t, this._properties = new Map, this.configure(e)\r\n    }\r\n    configure(t) {\r\n      if (!o(t)) return;\r\n      const e = Object.keys(ue.animation),\r\n        i = this._properties;\r\n      Object.getOwnPropertyNames(t).forEach((s =&gt; {\r\n        const a = t[s];\r\n        if (!o(a)) return;\r\n        const r = {};\r\n        for (const t of e) r[t] = a[t];\r\n        (n(a.properties) &amp;&amp; a.properties || [s]).forEach((t =&gt; {\r\n          t !== s &amp;&amp; i.has(t) || i.set(t, r)\r\n        }))\r\n      }))\r\n    }\r\n    _animateOptions(t, e) {\r\n      const i = e.options,\r\n        s = function(t, e) {\r\n          if (!e) return;\r\n          let i = t.options;\r\n          if (!i) return void(t.options = e);\r\n          i.$shared &amp;&amp; (t.options = i = Object.assign({}, i, {\r\n            $shared: !1,\r\n            $animations: {}\r\n          }));\r\n          return i\r\n        }(t, i);\r\n      if (!s) return [];\r\n      const n = this._createAnimations(s, i);\r\n      return i.$shared &amp;&amp; function(t, e) {\r\n        const i = [],\r\n          s = Object.keys(e);\r\n        for (let e = 0; e &lt; s.length; e++) {\r\n          const n = t[s[e]];\r\n          n &amp;&amp; n.active() &amp;&amp; i.push(n.wait())\r\n        }\r\n        return Promise.all(i)\r\n      }(t.options.$animations, i).then((() =&gt; {\r\n        t.options = i\r\n      }), (() =&gt; {})), n\r\n    }\r\n    _createAnimations(t, e) {\r\n      const i = this._properties,\r\n        s = [],\r\n        n = t.$animations || (t.$animations = {}),\r\n        o = Object.keys(e),\r\n        a = Date.now();\r\n      let r;\r\n      for (r = o.length - 1; r &gt;= 0; --r) {\r\n        const l = o[r];\r\n        if (&quot;$&quot; === l.charAt(0)) continue;\r\n        if (&quot;options&quot; === l) {\r\n          s.push(...this._animateOptions(t, e));\r\n          continue\r\n        }\r\n        const h = e[l];\r\n        let c = n[l];\r\n        const d = i.get(l);\r\n        if (c) {\r\n          if (d &amp;&amp; c.active()) {\r\n            c.update(d, h, a);\r\n            continue\r\n          }\r\n          c.cancel()\r\n        }\r\n        d &amp;&amp; d.duration ? (n[l] = c = new Cs(d, t, l, h), s.push(c)) : t[l] = h\r\n      }\r\n      return s\r\n    }\r\n    update(t, e) {\r\n      if (0 === this._properties.size) return void Object.assign(t, e);\r\n      const i = this._createAnimations(t, e);\r\n      return i.length ? (bt.add(this._chart, i), !0) : void 0\r\n    }\r\n  }\r\n\r\n  function As(t, e) {\r\n    const i = t &amp;&amp; t.options || {},\r\n      s = i.reverse,\r\n      n = void 0 === i.min ? e : 0,\r\n      o = void 0 === i.max ? e : 0;\r\n    return {\r\n      start: s ? o : n,\r\n      end: s ? n : o\r\n    }\r\n  }\r\n\r\n  function Ts(t, e) {\r\n    const i = [],\r\n      s = t._getSortedDatasetMetas(e);\r\n    let n, o;\r\n    for (n = 0, o = s.length; n &lt; o; ++n) i.push(s[n].index);\r\n    return i\r\n  }\r\n\r\n  function Ls(t, e, i, s = {}) {\r\n    const n = t.keys,\r\n      o = &quot;single&quot; === s.mode;\r\n    let r, l, h, c;\r\n    if (null !== e) {\r\n      for (r = 0, l = n.length; r &lt; l; ++r) {\r\n        if (h = +n[r], h === i) {\r\n          if (s.all) continue;\r\n          break\r\n        }\r\n        c = t.values[h], a(c) &amp;&amp; (o || 0 === e || F(e) === F(c)) &amp;&amp; (e += c)\r\n      }\r\n      return e\r\n    }\r\n  }\r\n\r\n  function Es(t, e) {\r\n    const i = t &amp;&amp; t.options.stacked;\r\n    return i || void 0 === i &amp;&amp; void 0 !== e.stack\r\n  }\r\n\r\n  function Rs(t, e, i) {\r\n    const s = t[e] || (t[e] = {});\r\n    return s[i] || (s[i] = {})\r\n  }\r\n\r\n  function Is(t, e, i, s) {\r\n    for (const n of e.getMatchingVisibleMetas(s).reverse()) {\r\n      const e = t[n.index];\r\n      if (i &amp;&amp; e &gt; 0 || !i &amp;&amp; e &lt; 0) return n.index\r\n    }\r\n    return null\r\n  }\r\n\r\n  function zs(t, e) {\r\n    const {\r\n      chart: i,\r\n      _cachedMeta: s\r\n    } = t, n = i._stacks || (i._stacks = {}), {\r\n      iScale: o,\r\n      vScale: a,\r\n      index: r\r\n    } = s, l = o.axis, h = a.axis, c = function(t, e, i) {\r\n      return `${t.id}.${e.id}.${i.stack||i.type}`\r\n    }(o, a, s), d = e.length;\r\n    let u;\r\n    for (let t = 0; t &lt; d; ++t) {\r\n      const i = e[t],\r\n        {\r\n          [l]: o,\r\n          [h]: d\r\n        } = i;\r\n      u = (i._stacks || (i._stacks = {}))[h] = Rs(n, c, o), u[r] = d, u._top = Is(u, a, !0, s.type), u._bottom = Is(u, a, !1, s.type);\r\n      (u._visualValues || (u._visualValues = {}))[r] = d\r\n    }\r\n  }\r\n\r\n  function Fs(t, e) {\r\n    const i = t.scales;\r\n    return Object.keys(i).filter((t =&gt; i[t].axis === e)).shift()\r\n  }\r\n\r\n  function Vs(t, e) {\r\n    const i = t.controller.index,\r\n      s = t.vScale &amp;&amp; t.vScale.axis;\r\n    if (s) {\r\n      e = e || t._parsed;\r\n      for (const t of e) {\r\n        const e = t._stacks;\r\n        if (!e || void 0 === e[s] || void 0 === e[s][i]) return;\r\n        delete e[s][i], void 0 !== e[s]._visualValues &amp;&amp; void 0 !== e[s]._visualValues[i] &amp;&amp; delete e[s]._visualValues[i]\r\n      }\r\n    }\r\n  }\r\n  const Bs = t =&gt; &quot;reset&quot; === t || &quot;none&quot; === t,\r\n    Ws = (t, e) =&gt; e ? t : Object.assign({}, t);\r\n  class Ns {\r\n    static defaults = {};\r\n    static datasetElementType = null;\r\n    static dataElementType = null;\r\n    constructor(t, e) {\r\n      this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize()\r\n    }\r\n    initialize() {\r\n      const t = this._cachedMeta;\r\n      this.configure(), this.linkScales(), t._stacked = Es(t.vScale, t), this.addElements(), this.options.fill &amp;&amp; !this.chart.isPluginEnabled(&quot;filler&quot;) &amp;&amp; console.warn(&quot;Tried to use the &#039;fill&#039; option without the &#039;Filler&#039; plugin enabled. Please import and register the &#039;Filler&#039; plugin and make sure it is not disabled in the options&quot;)\r\n    }\r\n    updateIndex(t) {\r\n      this.index !== t &amp;&amp; Vs(this._cachedMeta), this.index = t\r\n    }\r\n    linkScales() {\r\n      const t = this.chart,\r\n        e = this._cachedMeta,\r\n        i = this.getDataset(),\r\n        s = (t, e, i, s) =&gt; &quot;x&quot; === t ? e : &quot;r&quot; === t ? s : i,\r\n        n = e.xAxisID = l(i.xAxisID, Fs(t, &quot;x&quot;)),\r\n        o = e.yAxisID = l(i.yAxisID, Fs(t, &quot;y&quot;)),\r\n        a = e.rAxisID = l(i.rAxisID, Fs(t, &quot;r&quot;)),\r\n        r = e.indexAxis,\r\n        h = e.iAxisID = s(r, n, o, a),\r\n        c = e.vAxisID = s(r, o, n, a);\r\n      e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c)\r\n    }\r\n    getDataset() {\r\n      return this.chart.data.datasets[this.index]\r\n    }\r\n    getMeta() {\r\n      return this.chart.getDatasetMeta(this.index)\r\n    }\r\n    getScaleForId(t) {\r\n      return this.chart.scales[t]\r\n    }\r\n    _getOtherScale(t) {\r\n      const e = this._cachedMeta;\r\n      return t === e.iScale ? e.vScale : e.iScale\r\n    }\r\n    reset() {\r\n      this._update(&quot;reset&quot;)\r\n    }\r\n    _destroy() {\r\n      const t = this._cachedMeta;\r\n      this._data &amp;&amp; rt(this._data, this), t._stacked &amp;&amp; Vs(t)\r\n    }\r\n    _dataCheck() {\r\n      const t = this.getDataset(),\r\n        e = t.data || (t.data = []),\r\n        i = this._data;\r\n      if (o(e)) {\r\n        const t = this._cachedMeta;\r\n        this._data = function(t, e) {\r\n          const {\r\n            iScale: i,\r\n            vScale: s\r\n          } = e, n = &quot;x&quot; === i.axis ? &quot;x&quot; : &quot;y&quot;, o = &quot;x&quot; === s.axis ? &quot;x&quot; : &quot;y&quot;, a = Object.keys(t), r = new Array(a.length);\r\n          let l, h, c;\r\n          for (l = 0, h = a.length; l &lt; h; ++l) c = a[l], r[l] = {\r\n            [n]: c,\r\n            [o]: t[c]\r\n          };\r\n          return r\r\n        }(e, t)\r\n      } else if (i !== e) {\r\n        if (i) {\r\n          rt(i, this);\r\n          const t = this._cachedMeta;\r\n          Vs(t), t._parsed = []\r\n        }\r\n        e &amp;&amp; Object.isExtensible(e) &amp;&amp; at(e, this), this._syncList = [], this._data = e\r\n      }\r\n    }\r\n    addElements() {\r\n      const t = this._cachedMeta;\r\n      this._dataCheck(), this.datasetElementType &amp;&amp; (t.dataset = new this.datasetElementType)\r\n    }\r\n    buildOrUpdateElements(t) {\r\n      const e = this._cachedMeta,\r\n        i = this.getDataset();\r\n      let s = !1;\r\n      this._dataCheck();\r\n      const n = e._stacked;\r\n      e._stacked = Es(e.vScale, e), e.stack !== i.stack &amp;&amp; (s = !0, Vs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) &amp;&amp; zs(this, e._parsed)\r\n    }\r\n    configure() {\r\n      const t = this.chart.config,\r\n        e = t.datasetScopeKeys(this._type),\r\n        i = t.getOptionScopes(this.getDataset(), e, !0);\r\n      this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}\r\n    }\r\n    parse(t, e) {\r\n      const {\r\n        _cachedMeta: i,\r\n        _data: s\r\n      } = this, {\r\n        iScale: a,\r\n        _stacked: r\r\n      } = i, l = a.axis;\r\n      let h, c, d, u = 0 === t &amp;&amp; e === s.length || i._sorted,\r\n        f = t &gt; 0 &amp;&amp; i._parsed[t - 1];\r\n      if (!1 === this._parsing) i._parsed = s, i._sorted = !0, d = s;\r\n      else {\r\n        d = n(s[t]) ? this.parseArrayData(i, s, t, e) : o(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);\r\n        const a = () =&gt; null === c[l] || f &amp;&amp; c[l] &lt; f[l];\r\n        for (h = 0; h &lt; e; ++h) i._parsed[h + t] = c = d[h], u &amp;&amp; (a() &amp;&amp; (u = !1), f = c);\r\n        i._sorted = u\r\n      }\r\n      r &amp;&amp; zs(this, d)\r\n    }\r\n    parsePrimitiveData(t, e, i, s) {\r\n      const {\r\n        iScale: n,\r\n        vScale: o\r\n      } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);\r\n      let d, u, f;\r\n      for (d = 0, u = s; d &lt; u; ++d) f = d + i, c[d] = {\r\n        [a]: h || n.parse(l[f], f),\r\n        [r]: o.parse(e[f], f)\r\n      };\r\n      return c\r\n    }\r\n    parseArrayData(t, e, i, s) {\r\n      const {\r\n        xScale: n,\r\n        yScale: o\r\n      } = t, a = new Array(s);\r\n      let r, l, h, c;\r\n      for (r = 0, l = s; r &lt; l; ++r) h = r + i, c = e[h], a[r] = {\r\n        x: n.parse(c[0], h),\r\n        y: o.parse(c[1], h)\r\n      };\r\n      return a\r\n    }\r\n    parseObjectData(t, e, i, s) {\r\n      const {\r\n        xScale: n,\r\n        yScale: o\r\n      } = t, {\r\n        xAxisKey: a = &quot;x&quot;,\r\n        yAxisKey: r = &quot;y&quot;\r\n      } = this._parsing, l = new Array(s);\r\n      let h, c, d, u;\r\n      for (h = 0, c = s; h &lt; c; ++h) d = h + i, u = e[d], l[h] = {\r\n        x: n.parse(M(u, a), d),\r\n        y: o.parse(M(u, r), d)\r\n      };\r\n      return l\r\n    }\r\n    getParsed(t) {\r\n      return this._cachedMeta._parsed[t]\r\n    }\r\n    getDataElement(t) {\r\n      return this._cachedMeta.data[t]\r\n    }\r\n    applyStack(t, e, i) {\r\n      const s = this.chart,\r\n        n = this._cachedMeta,\r\n        o = e[t.axis];\r\n      return Ls({\r\n        keys: Ts(s, !0),\r\n        values: e._stacks[t.axis]._visualValues\r\n      }, o, n.index, {\r\n        mode: i\r\n      })\r\n    }\r\n    updateRangeFromParsed(t, e, i, s) {\r\n      const n = i[e.axis];\r\n      let o = null === n ? NaN : n;\r\n      const a = s &amp;&amp; i._stacks[e.axis];\r\n      s &amp;&amp; a &amp;&amp; (s.values = a, o = Ls(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)\r\n    }\r\n    getMinMax(t, e) {\r\n      const i = this._cachedMeta,\r\n        s = i._parsed,\r\n        n = i._sorted &amp;&amp; t === i.iScale,\r\n        o = s.length,\r\n        r = this._getOtherScale(t),\r\n        l = ((t, e, i) =&gt; t &amp;&amp; !e.hidden &amp;&amp; e._stacked &amp;&amp; {\r\n          keys: Ts(i, !0),\r\n          values: null\r\n        })(e, i, this.chart),\r\n        h = {\r\n          min: Number.POSITIVE_INFINITY,\r\n          max: Number.NEGATIVE_INFINITY\r\n        },\r\n        {\r\n          min: c,\r\n          max: d\r\n        } = function(t) {\r\n          const {\r\n            min: e,\r\n            max: i,\r\n            minDefined: s,\r\n            maxDefined: n\r\n          } = t.getUserBounds();\r\n          return {\r\n            min: s ? e : Number.NEGATIVE_INFINITY,\r\n            max: n ? i : Number.POSITIVE_INFINITY\r\n          }\r\n        }(r);\r\n      let u, f;\r\n\r\n      function g() {\r\n        f = s[u];\r\n        const e = f[r.axis];\r\n        return !a(f[t.axis]) || c &gt; e || d &lt; e\r\n      }\r\n      for (u = 0; u &lt; o &amp;&amp; (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);\r\n      if (n)\r\n        for (u = o - 1; u &gt;= 0; --u)\r\n          if (!g()) {\r\n            this.updateRangeFromParsed(h, t, f, l);\r\n            break\r\n          } return h\r\n    }\r\n    getAllParsedValues(t) {\r\n      const e = this._cachedMeta._parsed,\r\n        i = [];\r\n      let s, n, o;\r\n      for (s = 0, n = e.length; s &lt; n; ++s) o = e[s][t.axis], a(o) &amp;&amp; i.push(o);\r\n      return i\r\n    }\r\n    getMaxOverflow() {\r\n      return !1\r\n    }\r\n    getLabelAndValue(t) {\r\n      const e = this._cachedMeta,\r\n        i = e.iScale,\r\n        s = e.vScale,\r\n        n = this.getParsed(t);\r\n      return {\r\n        label: i ? &quot;&quot; + i.getLabelForValue(n[i.axis]) : &quot;&quot;,\r\n        value: s ? &quot;&quot; + s.getLabelForValue(n[s.axis]) : &quot;&quot;\r\n      }\r\n    }\r\n    _update(t) {\r\n      const e = this._cachedMeta;\r\n      this.update(t || &quot;default&quot;), e._clip = function(t) {\r\n        let e, i, s, n;\r\n        return o(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {\r\n          top: e,\r\n          right: i,\r\n          bottom: s,\r\n          left: n,\r\n          disabled: !1 === t\r\n        }\r\n      }(l(this.options.clip, function(t, e, i) {\r\n        if (!1 === i) return !1;\r\n        const s = As(t, i),\r\n          n = As(e, i);\r\n        return {\r\n          top: n.end,\r\n          right: s.end,\r\n          bottom: n.start,\r\n          left: s.start\r\n        }\r\n      }(e.xScale, e.yScale, this.getMaxOverflow())))\r\n    }\r\n    update(t) {}\r\n    draw() {\r\n      const t = this._ctx,\r\n        e = this.chart,\r\n        i = this._cachedMeta,\r\n        s = i.data || [],\r\n        n = e.chartArea,\r\n        o = [],\r\n        a = this._drawStart || 0,\r\n        r = this._drawCount || s.length - a,\r\n        l = this.options.drawActiveElementsOnTop;\r\n      let h;\r\n      for (i.dataset &amp;&amp; i.dataset.draw(t, n, a, r), h = a; h &lt; a + r; ++h) {\r\n        const e = s[h];\r\n        e.hidden || (e.active &amp;&amp; l ? o.push(e) : e.draw(t, n))\r\n      }\r\n      for (h = 0; h &lt; o.length; ++h) o[h].draw(t, n)\r\n    }\r\n    getStyle(t, e) {\r\n      const i = e ? &quot;active&quot; : &quot;default&quot;;\r\n      return void 0 === t &amp;&amp; this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)\r\n    }\r\n    getContext(t, e, i) {\r\n      const s = this.getDataset();\r\n      let n;\r\n      if (t &gt;= 0 &amp;&amp; t &lt; this._cachedMeta.data.length) {\r\n        const e = this._cachedMeta.data[t];\r\n        n = e.$context || (e.$context = function(t, e, i) {\r\n          return Ci(t, {\r\n            active: !1,\r\n            dataIndex: e,\r\n            parsed: void 0,\r\n            raw: void 0,\r\n            element: i,\r\n            index: e,\r\n            mode: &quot;default&quot;,\r\n            type: &quot;data&quot;\r\n          })\r\n        }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t\r\n      } else n = this.$context || (this.$context = function(t, e) {\r\n        return Ci(t, {\r\n          active: !1,\r\n          dataset: void 0,\r\n          datasetIndex: e,\r\n          index: e,\r\n          mode: &quot;default&quot;,\r\n          type: &quot;dataset&quot;\r\n        })\r\n      }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;\r\n      return n.active = !!e, n.mode = i, n\r\n    }\r\n    resolveDatasetElementOptions(t) {\r\n      return this._resolveElementOptions(this.datasetElementType.id, t)\r\n    }\r\n    resolveDataElementOptions(t, e) {\r\n      return this._resolveElementOptions(this.dataElementType.id, e, t)\r\n    }\r\n    _resolveElementOptions(t, e = &quot;default&quot;, i) {\r\n      const s = &quot;active&quot; === e,\r\n        n = this._cachedDataOpts,\r\n        o = t + &quot;-&quot; + e,\r\n        a = n[o],\r\n        r = this.enableOptionSharing &amp;&amp; k(i);\r\n      if (a) return Ws(a, r);\r\n      const l = this.chart.config,\r\n        h = l.datasetElementScopeKeys(this._type, t),\r\n        c = s ? [`${t}Hover`, &quot;hover&quot;, t, &quot;&quot;] : [t, &quot;&quot;],\r\n        d = l.getOptionScopes(this.getDataset(), h),\r\n        u = Object.keys(ue.elements[t]),\r\n        f = l.resolveNamedOptions(d, u, (() =&gt; this.getContext(i, s, e)), c);\r\n      return f.$shared &amp;&amp; (f.$shared = r, n[o] = Object.freeze(Ws(f, r))), f\r\n    }\r\n    _resolveAnimations(t, e, i) {\r\n      const s = this.chart,\r\n        n = this._cachedDataOpts,\r\n        o = `animation-${e}`,\r\n        a = n[o];\r\n      if (a) return a;\r\n      let r;\r\n      if (!1 !== s.options.animation) {\r\n        const s = this.chart.config,\r\n          n = s.datasetAnimationScopeKeys(this._type, e),\r\n          o = s.getOptionScopes(this.getDataset(), n);\r\n        r = s.createResolver(o, this.getContext(t, i, e))\r\n      }\r\n      const l = new Os(s, r &amp;&amp; r.animations);\r\n      return r &amp;&amp; r._cacheable &amp;&amp; (n[o] = Object.freeze(l)), l\r\n    }\r\n    getSharedOptions(t) {\r\n      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))\r\n    }\r\n    includeOptions(t, e) {\r\n      return !e || Bs(t) || this.chart._animationsDisabled\r\n    }\r\n    _getSharedOptions(t, e) {\r\n      const i = this.resolveDataElementOptions(t, e),\r\n        s = this._sharedOptions,\r\n        n = this.getSharedOptions(i),\r\n        o = this.includeOptions(e, n) || n !== s;\r\n      return this.updateSharedOptions(n, e, i), {\r\n        sharedOptions: n,\r\n        includeOptions: o\r\n      }\r\n    }\r\n    updateElement(t, e, i, s) {\r\n      Bs(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i)\r\n    }\r\n    updateSharedOptions(t, e, i) {\r\n      t &amp;&amp; !Bs(e) &amp;&amp; this._resolveAnimations(void 0, e).update(t, i)\r\n    }\r\n    _setStyle(t, e, i, s) {\r\n      t.active = s;\r\n      const n = this.getStyle(e, s);\r\n      this._resolveAnimations(e, i, s).update(t, {\r\n        options: !s &amp;&amp; this.getSharedOptions(n) || n\r\n      })\r\n    }\r\n    removeHoverStyle(t, e, i) {\r\n      this._setStyle(t, i, &quot;active&quot;, !1)\r\n    }\r\n    setHoverStyle(t, e, i) {\r\n      this._setStyle(t, i, &quot;active&quot;, !0)\r\n    }\r\n    _removeDatasetHoverStyle() {\r\n      const t = this._cachedMeta.dataset;\r\n      t &amp;&amp; this._setStyle(t, void 0, &quot;active&quot;, !1)\r\n    }\r\n    _setDatasetHoverStyle() {\r\n      const t = this._cachedMeta.dataset;\r\n      t &amp;&amp; this._setStyle(t, void 0, &quot;active&quot;, !0)\r\n    }\r\n    _resyncElements(t) {\r\n      const e = this._data,\r\n        i = this._cachedMeta.data;\r\n      for (const [t, e, i] of this._syncList) this[t](e, i);\r\n      this._syncList = [];\r\n      const s = i.length,\r\n        n = e.length,\r\n        o = Math.min(n, s);\r\n      o &amp;&amp; this.parse(0, o), n &gt; s ? this._insertElements(s, n - s, t) : n &lt; s &amp;&amp; this._removeElements(n, s - n)\r\n    }\r\n    _insertElements(t, e, i = !0) {\r\n      const s = this._cachedMeta,\r\n        n = s.data,\r\n        o = t + e;\r\n      let a;\r\n      const r = t =&gt; {\r\n        for (t.length += e, a = t.length - 1; a &gt;= o; a--) t[a] = t[a - e]\r\n      };\r\n      for (r(n), a = t; a &lt; o; ++a) n[a] = new this.dataElementType;\r\n      this._parsing &amp;&amp; r(s._parsed), this.parse(t, e), i &amp;&amp; this.updateElements(n, t, e, &quot;reset&quot;)\r\n    }\r\n    updateElements(t, e, i, s) {}\r\n    _removeElements(t, e) {\r\n      const i = this._cachedMeta;\r\n      if (this._parsing) {\r\n        const s = i._parsed.splice(t, e);\r\n        i._stacked &amp;&amp; Vs(i, s)\r\n      }\r\n      i.data.splice(t, e)\r\n    }\r\n    _sync(t) {\r\n      if (this._parsing) this._syncList.push(t);\r\n      else {\r\n        const [e, i, s] = t;\r\n        this[e](i, s)\r\n      }\r\n      this.chart._dataChanges.push([this.index, ...t])\r\n    }\r\n    _onDataPush() {\r\n      const t = arguments.length;\r\n      this._sync([&quot;_insertElements&quot;, this.getDataset().data.length - t, t])\r\n    }\r\n    _onDataPop() {\r\n      this._sync([&quot;_removeElements&quot;, this._cachedMeta.data.length - 1, 1])\r\n    }\r\n    _onDataShift() {\r\n      this._sync([&quot;_removeElements&quot;, 0, 1])\r\n    }\r\n    _onDataSplice(t, e) {\r\n      e &amp;&amp; this._sync([&quot;_removeElements&quot;, t, e]);\r\n      const i = arguments.length - 2;\r\n      i &amp;&amp; this._sync([&quot;_insertElements&quot;, t, i])\r\n    }\r\n    _onDataUnshift() {\r\n      this._sync([&quot;_insertElements&quot;, 0, arguments.length])\r\n    }\r\n  }\r\n  class Hs {\r\n    static defaults = {};\r\n    static defaultRoutes = void 0;\r\n    x;\r\n    y;\r\n    active = !1;\r\n    options;\r\n    $animations;\r\n    tooltipPosition(t) {\r\n      const {\r\n        x: e,\r\n        y: i\r\n      } = this.getProps([&quot;x&quot;, &quot;y&quot;], t);\r\n      return {\r\n        x: e,\r\n        y: i\r\n      }\r\n    }\r\n    hasValue() {\r\n      return N(this.x) &amp;&amp; N(this.y)\r\n    }\r\n    getProps(t, e) {\r\n      const i = this.$animations;\r\n      if (!e || !i) return this;\r\n      const s = {};\r\n      return t.forEach((t =&gt; {\r\n        s[t] = i[t] &amp;&amp; i[t].active() ? i[t]._to : this[t]\r\n      })), s\r\n    }\r\n  }\r\n\r\n  function js(t, e) {\r\n    const i = t.options.ticks,\r\n      n = function(t) {\r\n        const e = t.options.offset,\r\n          i = t._tickSize(),\r\n          s = t._length \/ i + (e ? 0 : 1),\r\n          n = t._maxLength \/ i;\r\n        return Math.floor(Math.min(s, n))\r\n      }(t),\r\n      o = Math.min(i.maxTicksLimit || n, n),\r\n      a = i.major.enabled ? function(t) {\r\n        const e = [];\r\n        let i, s;\r\n        for (i = 0, s = t.length; i &lt; s; i++) t[i].major &amp;&amp; e.push(i);\r\n        return e\r\n      }(e) : [],\r\n      r = a.length,\r\n      l = a[0],\r\n      h = a[r - 1],\r\n      c = [];\r\n    if (r &gt; o) return function(t, e, i, s) {\r\n      let n, o = 0,\r\n        a = i[0];\r\n      for (s = Math.ceil(s), n = 0; n &lt; t.length; n++) n === a &amp;&amp; (e.push(t[n]), o++, a = i[o * s])\r\n    }(e, c, a, r \/ o), c;\r\n    const d = function(t, e, i) {\r\n      const s = function(t) {\r\n          const e = t.length;\r\n          let i, s;\r\n          if (e &lt; 2) return !1;\r\n          for (s = t[0], i = 1; i &lt; e; ++i)\r\n            if (t[i] - t[i - 1] !== s) return !1;\r\n          return s\r\n        }(t),\r\n        n = e.length \/ i;\r\n      if (!s) return Math.max(n, 1);\r\n      const o = W(s);\r\n      for (let t = 0, e = o.length - 1; t &lt; e; t++) {\r\n        const e = o[t];\r\n        if (e &gt; n) return e\r\n      }\r\n      return Math.max(n, 1)\r\n    }(a, e, o);\r\n    if (r &gt; 0) {\r\n      let t, i;\r\n      const n = r &gt; 1 ? Math.round((h - l) \/ (r - 1)) : null;\r\n      for ($s(e, c, d, s(n) ? 0 : l - n, l), t = 0, i = r - 1; t &lt; i; t++) $s(e, c, d, a[t], a[t + 1]);\r\n      return $s(e, c, d, h, s(n) ? e.length : h + n), c\r\n    }\r\n    return $s(e, c, d), c\r\n  }\r\n\r\n  function $s(t, e, i, s, n) {\r\n    const o = l(s, 0),\r\n      a = Math.min(l(n, t.length), t.length);\r\n    let r, h, c, d = 0;\r\n    for (i = Math.ceil(i), n &amp;&amp; (r = n - s, i = r \/ Math.floor(r \/ i)), c = o; c &lt; 0;) d++, c = Math.round(o + d * i);\r\n    for (h = Math.max(o, 0); h &lt; a; h++) h === c &amp;&amp; (e.push(t[h]), d++, c = Math.round(o + d * i))\r\n  }\r\n  const Ys = (t, e, i) =&gt; &quot;top&quot; === e || &quot;left&quot; === e ? t[e] + i : t[e] - i,\r\n    Us = (t, e) =&gt; Math.min(e || t, t);\r\n\r\n  function Xs(t, e) {\r\n    const i = [],\r\n      s = t.length \/ e,\r\n      n = t.length;\r\n    let o = 0;\r\n    for (; o &lt; n; o += s) i.push(t[Math.floor(o)]);\r\n    return i\r\n  }\r\n\r\n  function qs(t, e, i) {\r\n    const s = t.ticks.length,\r\n      n = Math.min(e, s - 1),\r\n      o = t._startPixel,\r\n      a = t._endPixel,\r\n      r = 1e-6;\r\n    let l, h = t.getPixelForTick(n);\r\n    if (!(i &amp;&amp; (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) \/ 2 : (h - t.getPixelForTick(n - 1)) \/ 2, h += n &lt; e ? l : -l, h &lt; o - r || h &gt; a + r))) return h\r\n  }\r\n\r\n  function Ks(t) {\r\n    return t.drawTicks ? t.tickLength : 0\r\n  }\r\n\r\n  function Gs(t, e) {\r\n    if (!t.display) return 0;\r\n    const i = Si(t.font, e),\r\n      s = ki(t.padding);\r\n    return (n(t.text) ? t.text.length : 1) * i.lineHeight + s.height\r\n  }\r\n\r\n  function Zs(t, e, i) {\r\n    let s = ut(t);\r\n    return (i &amp;&amp; &quot;right&quot; !== e || !i &amp;&amp; &quot;right&quot; === e) &amp;&amp; (s = (t =&gt; &quot;left&quot; === t ? &quot;right&quot; : &quot;right&quot; === t ? &quot;left&quot; : t)(s)), s\r\n  }\r\n  class Js extends Hs {\r\n    constructor(t) {\r\n      super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\r\n        left: 0,\r\n        right: 0,\r\n        top: 0,\r\n        bottom: 0\r\n      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0\r\n    }\r\n    init(t) {\r\n      this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax)\r\n    }\r\n    parse(t, e) {\r\n      return t\r\n    }\r\n    getUserBounds() {\r\n      let {\r\n        _userMin: t,\r\n        _userMax: e,\r\n        _suggestedMin: i,\r\n        _suggestedMax: s\r\n      } = this;\r\n      return t = r(t, Number.POSITIVE_INFINITY), e = r(e, Number.NEGATIVE_INFINITY), i = r(i, Number.POSITIVE_INFINITY), s = r(s, Number.NEGATIVE_INFINITY), {\r\n        min: r(t, i),\r\n        max: r(e, s),\r\n        minDefined: a(t),\r\n        maxDefined: a(e)\r\n      }\r\n    }\r\n    getMinMax(t) {\r\n      let e, {\r\n        min: i,\r\n        max: s,\r\n        minDefined: n,\r\n        maxDefined: o\r\n      } = this.getUserBounds();\r\n      if (n &amp;&amp; o) return {\r\n        min: i,\r\n        max: s\r\n      };\r\n      const a = this.getMatchingVisibleMetas();\r\n      for (let r = 0, l = a.length; r &lt; l; ++r) e = a[r].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));\r\n      return i = o &amp;&amp; i &gt; s ? s : i, s = n &amp;&amp; i &gt; s ? i : s, {\r\n        min: r(i, r(s, i)),\r\n        max: r(s, r(i, s))\r\n      }\r\n    }\r\n    getPadding() {\r\n      return {\r\n        left: this.paddingLeft || 0,\r\n        top: this.paddingTop || 0,\r\n        right: this.paddingRight || 0,\r\n        bottom: this.paddingBottom || 0\r\n      }\r\n    }\r\n    getTicks() {\r\n      return this.ticks\r\n    }\r\n    getLabels() {\r\n      const t = this.chart.data;\r\n      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []\r\n    }\r\n    getLabelItems(t = this.chart.chartArea) {\r\n      return this._labelItems || (this._labelItems = this._computeLabelItems(t))\r\n    }\r\n    beforeLayout() {\r\n      this._cache = {}, this._dataLimitsCached = !1\r\n    }\r\n    beforeUpdate() {\r\n      d(this.options.beforeUpdate, [this])\r\n    }\r\n    update(t, e, i) {\r\n      const {\r\n        beginAtZero: s,\r\n        grace: n,\r\n        ticks: o\r\n      } = this.options, a = o.sampleSize;\r\n      this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({\r\n        left: 0,\r\n        right: 0,\r\n        top: 0,\r\n        bottom: 0\r\n      }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Di(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\r\n      const r = a &lt; this.ticks.length;\r\n      this._convertTicksToLabels(r ? Xs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display &amp;&amp; (o.autoSkip || &quot;auto&quot; === o.source) &amp;&amp; (this.ticks = js(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r &amp;&amp; this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()\r\n    }\r\n    configure() {\r\n      let t, e, i = this.options.reverse;\r\n      this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels\r\n    }\r\n    afterUpdate() {\r\n      d(this.options.afterUpdate, [this])\r\n    }\r\n    beforeSetDimensions() {\r\n      d(this.options.beforeSetDimensions, [this])\r\n    }\r\n    setDimensions() {\r\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0\r\n    }\r\n    afterSetDimensions() {\r\n      d(this.options.afterSetDimensions, [this])\r\n    }\r\n    _callHooks(t) {\r\n      this.chart.notifyPlugins(t, this.getContext()), d(this.options[t], [this])\r\n    }\r\n    beforeDataLimits() {\r\n      this._callHooks(&quot;beforeDataLimits&quot;)\r\n    }\r\n    determineDataLimits() {}\r\n    afterDataLimits() {\r\n      this._callHooks(&quot;afterDataLimits&quot;)\r\n    }\r\n    beforeBuildTicks() {\r\n      this._callHooks(&quot;beforeBuildTicks&quot;)\r\n    }\r\n    buildTicks() {\r\n      return []\r\n    }\r\n    afterBuildTicks() {\r\n      this._callHooks(&quot;afterBuildTicks&quot;)\r\n    }\r\n    beforeTickToLabelConversion() {\r\n      d(this.options.beforeTickToLabelConversion, [this])\r\n    }\r\n    generateTickLabels(t) {\r\n      const e = this.options.ticks;\r\n      let i, s, n;\r\n      for (i = 0, s = t.length; i &lt; s; i++) n = t[i], n.label = d(e.callback, [n.value, i, t], this)\r\n    }\r\n    afterTickToLabelConversion() {\r\n      d(this.options.afterTickToLabelConversion, [this])\r\n    }\r\n    beforeCalculateLabelRotation() {\r\n      d(this.options.beforeCalculateLabelRotation, [this])\r\n    }\r\n    calculateLabelRotation() {\r\n      const t = this.options,\r\n        e = t.ticks,\r\n        i = Us(this.ticks.length, t.ticks.maxTicksLimit),\r\n        s = e.minRotation || 0,\r\n        n = e.maxRotation;\r\n      let o, a, r, l = s;\r\n      if (!this._isVisible() || !e.display || s &gt;= n || i &lt;= 1 || !this.isHorizontal()) return void(this.labelRotation = s);\r\n      const h = this._getLabelSizes(),\r\n        c = h.widest.width,\r\n        d = h.highest.height,\r\n        u = J(this.chart.width - c, 0, this.maxWidth);\r\n      o = t.offset ? this.maxWidth \/ i : u \/ (i - 1), c + 6 &gt; o &amp;&amp; (o = u \/ (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ks(t.grid) - e.padding - Gs(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = Y(Math.min(Math.asin(J((h.highest.height + 6) \/ o, -1, 1)), Math.asin(J(a \/ r, -1, 1)) - Math.asin(J(d \/ r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l\r\n    }\r\n    afterCalculateLabelRotation() {\r\n      d(this.options.afterCalculateLabelRotation, [this])\r\n    }\r\n    afterAutoSkip() {}\r\n    beforeFit() {\r\n      d(this.options.beforeFit, [this])\r\n    }\r\n    fit() {\r\n      const t = {\r\n          width: 0,\r\n          height: 0\r\n        },\r\n        {\r\n          chart: e,\r\n          options: {\r\n            ticks: i,\r\n            title: s,\r\n            grid: n\r\n          }\r\n        } = this,\r\n        o = this._isVisible(),\r\n        a = this.isHorizontal();\r\n      if (o) {\r\n        const o = Gs(s, e.options.font);\r\n        if (a ? (t.width = this.maxWidth, t.height = Ks(n) + o) : (t.height = this.maxHeight, t.width = Ks(n) + o), i.display &amp;&amp; this.ticks.length) {\r\n          const {\r\n            first: e,\r\n            last: s,\r\n            widest: n,\r\n            highest: o\r\n          } = this._getLabelSizes(), r = 2 * i.padding, l = $(this.labelRotation), h = Math.cos(l), c = Math.sin(l);\r\n          if (a) {\r\n            const e = i.mirror ? 0 : c * n.width + h * o.height;\r\n            t.height = Math.min(this.maxHeight, t.height + e + r)\r\n          } else {\r\n            const e = i.mirror ? 0 : h * n.width + c * o.height;\r\n            t.width = Math.min(this.maxWidth, t.width + e + r)\r\n          }\r\n          this._calculatePadding(e, s, c, h)\r\n        }\r\n      }\r\n      this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom)\r\n    }\r\n    _calculatePadding(t, e, i, s) {\r\n      const {\r\n        ticks: {\r\n          align: n,\r\n          padding: o\r\n        },\r\n        position: a\r\n      } = this.options, r = 0 !== this.labelRotation, l = &quot;top&quot; !== a &amp;&amp; &quot;x&quot; === this.axis;\r\n      if (this.isHorizontal()) {\r\n        const a = this.getPixelForTick(0) - this.left,\r\n          h = this.right - this.getPixelForTick(this.ticks.length - 1);\r\n        let c = 0,\r\n          d = 0;\r\n        r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : &quot;start&quot; === n ? d = e.width : &quot;end&quot; === n ? c = t.width : &quot;inner&quot; !== n &amp;&amp; (c = t.width \/ 2, d = e.width \/ 2), this.paddingLeft = Math.max((c - a + o) * this.width \/ (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width \/ (this.width - h), 0)\r\n      } else {\r\n        let i = e.height \/ 2,\r\n          s = t.height \/ 2;\r\n        &quot;start&quot; === n ? (i = 0, s = t.height) : &quot;end&quot; === n &amp;&amp; (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o\r\n      }\r\n    }\r\n    _handleMargins() {\r\n      this._margins &amp;&amp; (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))\r\n    }\r\n    afterFit() {\r\n      d(this.options.afterFit, [this])\r\n    }\r\n    isHorizontal() {\r\n      const {\r\n        axis: t,\r\n        position: e\r\n      } = this.options;\r\n      return &quot;top&quot; === e || &quot;bottom&quot; === e || &quot;x&quot; === t\r\n    }\r\n    isFullSize() {\r\n      return this.options.fullSize\r\n    }\r\n    _convertTicksToLabels(t) {\r\n      let e, i;\r\n      for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e &lt; i; e++) s(t[e].label) &amp;&amp; (t.splice(e, 1), i--, e--);\r\n      this.afterTickToLabelConversion()\r\n    }\r\n    _getLabelSizes() {\r\n      let t = this._labelSizes;\r\n      if (!t) {\r\n        const e = this.options.ticks.sampleSize;\r\n        let i = this.ticks;\r\n        e &lt; i.length &amp;&amp; (i = Xs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit)\r\n      }\r\n      return t\r\n    }\r\n    _computeLabelSizes(t, e, i) {\r\n      const {\r\n        ctx: o,\r\n        _longestTextCache: a\r\n      } = this, r = [], l = [], h = Math.floor(e \/ Us(e, i));\r\n      let c, d, f, g, p, m, x, b, _, y, v, M = 0,\r\n        w = 0;\r\n      for (c = 0; c &lt; e; c += h) {\r\n        if (g = t[c].label, p = this._resolveTickFontOptions(c), o.font = m = p.string, x = a[m] = a[m] || {\r\n            data: {},\r\n            gc: []\r\n          }, b = p.lineHeight, _ = y = 0, s(g) || n(g)) {\r\n          if (n(g))\r\n            for (d = 0, f = g.length; d &lt; f; ++d) v = g[d], s(v) || n(v) || (_ = Ce(o, x.data, x.gc, _, v), y += b)\r\n        } else _ = Ce(o, x.data, x.gc, _, g), y = b;\r\n        r.push(_), l.push(y), M = Math.max(_, M), w = Math.max(y, w)\r\n      }! function(t, e) {\r\n        u(t, (t =&gt; {\r\n          const i = t.gc,\r\n            s = i.length \/ 2;\r\n          let n;\r\n          if (s &gt; e) {\r\n            for (n = 0; n &lt; s; ++n) delete t.data[i[n]];\r\n            i.splice(0, s)\r\n          }\r\n        }))\r\n      }(a, e);\r\n      const k = r.indexOf(M),\r\n        S = l.indexOf(w),\r\n        P = t =&gt; ({\r\n          width: r[t] || 0,\r\n          height: l[t] || 0\r\n        });\r\n      return {\r\n        first: P(0),\r\n        last: P(e - 1),\r\n        widest: P(k),\r\n        highest: P(S),\r\n        widths: r,\r\n        heights: l\r\n      }\r\n    }\r\n    getLabelForValue(t) {\r\n      return t\r\n    }\r\n    getPixelForValue(t, e) {\r\n      return NaN\r\n    }\r\n    getValueForPixel(t) {}\r\n    getPixelForTick(t) {\r\n      const e = this.ticks;\r\n      return t &lt; 0 || t &gt; e.length - 1 ? null : this.getPixelForValue(e[t].value)\r\n    }\r\n    getPixelForDecimal(t) {\r\n      this._reversePixels &amp;&amp; (t = 1 - t);\r\n      const e = this._startPixel + t * this._length;\r\n      return Q(this._alignToPixels ? Ae(this.chart, e, 0) : e)\r\n    }\r\n    getDecimalForPixel(t) {\r\n      const e = (t - this._startPixel) \/ this._length;\r\n      return this._reversePixels ? 1 - e : e\r\n    }\r\n    getBasePixel() {\r\n      return this.getPixelForValue(this.getBaseValue())\r\n    }\r\n    getBaseValue() {\r\n      const {\r\n        min: t,\r\n        max: e\r\n      } = this;\r\n      return t &lt; 0 &amp;&amp; e &lt; 0 ? e : t &gt; 0 &amp;&amp; e &gt; 0 ? t : 0\r\n    }\r\n    getContext(t) {\r\n      const e = this.ticks || [];\r\n      if (t &gt;= 0 &amp;&amp; t &lt; e.length) {\r\n        const i = e[t];\r\n        return i.$context || (i.$context = function(t, e, i) {\r\n          return Ci(t, {\r\n            tick: i,\r\n            index: e,\r\n            type: &quot;tick&quot;\r\n          })\r\n        }(this.getContext(), t, i))\r\n      }\r\n      return this.$context || (this.$context = Ci(this.chart.getContext(), {\r\n        scale: this,\r\n        type: &quot;scale&quot;\r\n      }))\r\n    }\r\n    _tickSize() {\r\n      const t = this.options.ticks,\r\n        e = $(this.labelRotation),\r\n        i = Math.abs(Math.cos(e)),\r\n        s = Math.abs(Math.sin(e)),\r\n        n = this._getLabelSizes(),\r\n        o = t.autoSkipPadding || 0,\r\n        a = n ? n.widest.width + o : 0,\r\n        r = n ? n.highest.height + o : 0;\r\n      return this.isHorizontal() ? r * i &gt; a * s ? a \/ i : r \/ s : r * s &lt; a * i ? r \/ i : a \/ s\r\n    }\r\n    _isVisible() {\r\n      const t = this.options.display;\r\n      return &quot;auto&quot; !== t ? !!t : this.getMatchingVisibleMetas().length &gt; 0\r\n    }\r\n    _computeGridLineItems(t) {\r\n      const e = this.axis,\r\n        i = this.chart,\r\n        s = this.options,\r\n        {\r\n          grid: n,\r\n          position: a,\r\n          border: r\r\n        } = s,\r\n        h = n.offset,\r\n        c = this.isHorizontal(),\r\n        d = this.ticks.length + (h ? 1 : 0),\r\n        u = Ks(n),\r\n        f = [],\r\n        g = r.setContext(this.getContext()),\r\n        p = g.display ? g.width : 0,\r\n        m = p \/ 2,\r\n        x = function(t) {\r\n          return Ae(i, t, p)\r\n        };\r\n      let b, _, y, v, M, w, k, S, P, D, C, O;\r\n      if (&quot;top&quot; === a) b = x(this.bottom), w = this.bottom - u, S = b - m, D = x(t.top) + m, O = t.bottom;\r\n      else if (&quot;bottom&quot; === a) b = x(this.top), D = t.top, O = x(t.bottom) - m, w = b + m, S = this.top + u;\r\n      else if (&quot;left&quot; === a) b = x(this.right), M = this.right - u, k = b - m, P = x(t.left) + m, C = t.right;\r\n      else if (&quot;right&quot; === a) b = x(this.left), P = t.left, C = x(t.right) - m, M = b + m, k = this.left + u;\r\n      else if (&quot;x&quot; === e) {\r\n        if (&quot;center&quot; === a) b = x((t.top + t.bottom) \/ 2 + .5);\r\n        else if (o(a)) {\r\n          const t = Object.keys(a)[0],\r\n            e = a[t];\r\n          b = x(this.chart.scales[t].getPixelForValue(e))\r\n        }\r\n        D = t.top, O = t.bottom, w = b + m, S = w + u\r\n      } else if (&quot;y&quot; === e) {\r\n        if (&quot;center&quot; === a) b = x((t.left + t.right) \/ 2);\r\n        else if (o(a)) {\r\n          const t = Object.keys(a)[0],\r\n            e = a[t];\r\n          b = x(this.chart.scales[t].getPixelForValue(e))\r\n        }\r\n        M = b - m, k = M - u, P = t.left, C = t.right\r\n      }\r\n      const A = l(s.ticks.maxTicksLimit, d),\r\n        T = Math.max(1, Math.ceil(d \/ A));\r\n      for (_ = 0; _ &lt; d; _ += T) {\r\n        const t = this.getContext(_),\r\n          e = n.setContext(t),\r\n          s = r.setContext(t),\r\n          o = e.lineWidth,\r\n          a = e.color,\r\n          l = s.dash || [],\r\n          d = s.dashOffset,\r\n          u = e.tickWidth,\r\n          g = e.tickColor,\r\n          p = e.tickBorderDash || [],\r\n          m = e.tickBorderDashOffset;\r\n        y = qs(this, _, h), void 0 !== y &amp;&amp; (v = Ae(i, y, o), c ? M = k = P = C = v : w = S = D = O = v, f.push({\r\n          tx1: M,\r\n          ty1: w,\r\n          tx2: k,\r\n          ty2: S,\r\n          x1: P,\r\n          y1: D,\r\n          x2: C,\r\n          y2: O,\r\n          width: o,\r\n          color: a,\r\n          borderDash: l,\r\n          borderDashOffset: d,\r\n          tickWidth: u,\r\n          tickColor: g,\r\n          tickBorderDash: p,\r\n          tickBorderDashOffset: m\r\n        }))\r\n      }\r\n      return this._ticksLength = d, this._borderValue = b, f\r\n    }\r\n    _computeLabelItems(t) {\r\n      const e = this.axis,\r\n        i = this.options,\r\n        {\r\n          position: s,\r\n          ticks: a\r\n        } = i,\r\n        r = this.isHorizontal(),\r\n        l = this.ticks,\r\n        {\r\n          align: h,\r\n          crossAlign: c,\r\n          padding: d,\r\n          mirror: u\r\n        } = a,\r\n        f = Ks(i.grid),\r\n        g = f + d,\r\n        p = u ? -d : g,\r\n        m = -$(this.labelRotation),\r\n        x = [];\r\n      let b, _, y, v, M, w, k, S, P, D, C, O, A = &quot;middle&quot;;\r\n      if (&quot;top&quot; === s) w = this.bottom - p, k = this._getXAxisLabelAlignment();\r\n      else if (&quot;bottom&quot; === s) w = this.top + p, k = this._getXAxisLabelAlignment();\r\n      else if (&quot;left&quot; === s) {\r\n        const t = this._getYAxisLabelAlignment(f);\r\n        k = t.textAlign, M = t.x\r\n      } else if (&quot;right&quot; === s) {\r\n        const t = this._getYAxisLabelAlignment(f);\r\n        k = t.textAlign, M = t.x\r\n      } else if (&quot;x&quot; === e) {\r\n        if (&quot;center&quot; === s) w = (t.top + t.bottom) \/ 2 + g;\r\n        else if (o(s)) {\r\n          const t = Object.keys(s)[0],\r\n            e = s[t];\r\n          w = this.chart.scales[t].getPixelForValue(e) + g\r\n        }\r\n        k = this._getXAxisLabelAlignment()\r\n      } else if (&quot;y&quot; === e) {\r\n        if (&quot;center&quot; === s) M = (t.left + t.right) \/ 2 - g;\r\n        else if (o(s)) {\r\n          const t = Object.keys(s)[0],\r\n            e = s[t];\r\n          M = this.chart.scales[t].getPixelForValue(e)\r\n        }\r\n        k = this._getYAxisLabelAlignment(f).textAlign\r\n      }\r\n      &quot;y&quot; === e &amp;&amp; (&quot;start&quot; === h ? A = &quot;top&quot; : &quot;end&quot; === h &amp;&amp; (A = &quot;bottom&quot;));\r\n      const T = this._getLabelSizes();\r\n      for (b = 0, _ = l.length; b &lt; _; ++b) {\r\n        y = l[b], v = y.label;\r\n        const t = a.setContext(this.getContext(b));\r\n        S = this.getPixelForTick(b) + a.labelOffset, P = this._resolveTickFontOptions(b), D = P.lineHeight, C = n(v) ? v.length : 1;\r\n        const e = C \/ 2,\r\n          i = t.color,\r\n          o = t.textStrokeColor,\r\n          h = t.textStrokeWidth;\r\n        let d, f = k;\r\n        if (r ? (M = S, &quot;inner&quot; === k &amp;&amp; (f = b === _ - 1 ? this.options.reverse ? &quot;left&quot; : &quot;right&quot; : 0 === b ? this.options.reverse ? &quot;right&quot; : &quot;left&quot; : &quot;center&quot;), O = &quot;top&quot; === s ? &quot;near&quot; === c || 0 !== m ? -C * D + D \/ 2 : &quot;center&quot; === c ? -T.highest.height \/ 2 - e * D + D : -T.highest.height + D \/ 2 : &quot;near&quot; === c || 0 !== m ? D \/ 2 : &quot;center&quot; === c ? T.highest.height \/ 2 - e * D : T.highest.height - C * D, u &amp;&amp; (O *= -1), 0 === m || t.showLabelBackdrop || (M += D \/ 2 * Math.sin(m))) : (w = S, O = (1 - C) * D \/ 2), t.showLabelBackdrop) {\r\n          const e = ki(t.backdropPadding),\r\n            i = T.heights[b],\r\n            s = T.widths[b];\r\n          let n = O - e.top,\r\n            o = 0 - e.left;\r\n          switch (A) {\r\n            case &quot;middle&quot;:\r\n              n -= i \/ 2;\r\n              break;\r\n            case &quot;bottom&quot;:\r\n              n -= i\r\n          }\r\n          switch (k) {\r\n            case &quot;center&quot;:\r\n              o -= s \/ 2;\r\n              break;\r\n            case &quot;right&quot;:\r\n              o -= s;\r\n              break;\r\n            case &quot;inner&quot;:\r\n              b === _ - 1 ? o -= s : b &gt; 0 &amp;&amp; (o -= s \/ 2)\r\n          }\r\n          d = {\r\n            left: o,\r\n            top: n,\r\n            width: s + e.width,\r\n            height: i + e.height,\r\n            color: t.backdropColor\r\n          }\r\n        }\r\n        x.push({\r\n          label: v,\r\n          font: P,\r\n          textOffset: O,\r\n          options: {\r\n            rotation: m,\r\n            color: i,\r\n            strokeColor: o,\r\n            strokeWidth: h,\r\n            textAlign: f,\r\n            textBaseline: A,\r\n            translation: [M, w],\r\n            backdrop: d\r\n          }\r\n        })\r\n      }\r\n      return x\r\n    }\r\n    _getXAxisLabelAlignment() {\r\n      const {\r\n        position: t,\r\n        ticks: e\r\n      } = this.options;\r\n      if (-$(this.labelRotation)) return &quot;top&quot; === t ? &quot;left&quot; : &quot;right&quot;;\r\n      let i = &quot;center&quot;;\r\n      return &quot;start&quot; === e.align ? i = &quot;left&quot; : &quot;end&quot; === e.align ? i = &quot;right&quot; : &quot;inner&quot; === e.align &amp;&amp; (i = &quot;inner&quot;), i\r\n    }\r\n    _getYAxisLabelAlignment(t) {\r\n      const {\r\n        position: e,\r\n        ticks: {\r\n          crossAlign: i,\r\n          mirror: s,\r\n          padding: n\r\n        }\r\n      } = this.options, o = t + n, a = this._getLabelSizes().widest.width;\r\n      let r, l;\r\n      return &quot;left&quot; === e ? s ? (l = this.right + n, &quot;near&quot; === i ? r = &quot;left&quot; : &quot;center&quot; === i ? (r = &quot;center&quot;, l += a \/ 2) : (r = &quot;right&quot;, l += a)) : (l = this.right - o, &quot;near&quot; === i ? r = &quot;right&quot; : &quot;center&quot; === i ? (r = &quot;center&quot;, l -= a \/ 2) : (r = &quot;left&quot;, l = this.left)) : &quot;right&quot; === e ? s ? (l = this.left + n, &quot;near&quot; === i ? r = &quot;right&quot; : &quot;center&quot; === i ? (r = &quot;center&quot;, l -= a \/ 2) : (r = &quot;left&quot;, l -= a)) : (l = this.left + o, &quot;near&quot; === i ? r = &quot;left&quot; : &quot;center&quot; === i ? (r = &quot;center&quot;, l += a \/ 2) : (r = &quot;right&quot;, l = this.right)) : r = &quot;right&quot;, {\r\n        textAlign: r,\r\n        x: l\r\n      }\r\n    }\r\n    _computeLabelArea() {\r\n      if (this.options.ticks.mirror) return;\r\n      const t = this.chart,\r\n        e = this.options.position;\r\n      return &quot;left&quot; === e || &quot;right&quot; === e ? {\r\n        top: 0,\r\n        left: this.left,\r\n        bottom: t.height,\r\n        right: this.right\r\n      } : &quot;top&quot; === e || &quot;bottom&quot; === e ? {\r\n        top: this.top,\r\n        left: 0,\r\n        bottom: this.bottom,\r\n        right: t.width\r\n      } : void 0\r\n    }\r\n    drawBackground() {\r\n      const {\r\n        ctx: t,\r\n        options: {\r\n          backgroundColor: e\r\n        },\r\n        left: i,\r\n        top: s,\r\n        width: n,\r\n        height: o\r\n      } = this;\r\n      e &amp;&amp; (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore())\r\n    }\r\n    getLineWidthForValue(t) {\r\n      const e = this.options.grid;\r\n      if (!this._isVisible() || !e.display) return 0;\r\n      const i = this.ticks.findIndex((e =&gt; e.value === t));\r\n      if (i &gt;= 0) {\r\n        return e.setContext(this.getContext(i)).lineWidth\r\n      }\r\n      return 0\r\n    }\r\n    drawGrid(t) {\r\n      const e = this.options.grid,\r\n        i = this.ctx,\r\n        s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\r\n      let n, o;\r\n      const a = (t, e, s) =&gt; {\r\n        s.width &amp;&amp; s.color &amp;&amp; (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore())\r\n      };\r\n      if (e.display)\r\n        for (n = 0, o = s.length; n &lt; o; ++n) {\r\n          const t = s[n];\r\n          e.drawOnChartArea &amp;&amp; a({\r\n            x: t.x1,\r\n            y: t.y1\r\n          }, {\r\n            x: t.x2,\r\n            y: t.y2\r\n          }, t), e.drawTicks &amp;&amp; a({\r\n            x: t.tx1,\r\n            y: t.ty1\r\n          }, {\r\n            x: t.tx2,\r\n            y: t.ty2\r\n          }, {\r\n            color: t.tickColor,\r\n            width: t.tickWidth,\r\n            borderDash: t.tickBorderDash,\r\n            borderDashOffset: t.tickBorderDashOffset\r\n          })\r\n        }\r\n    }\r\n    drawBorder() {\r\n      const {\r\n        chart: t,\r\n        ctx: e,\r\n        options: {\r\n          border: i,\r\n          grid: s\r\n        }\r\n      } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;\r\n      if (!o) return;\r\n      const a = s.setContext(this.getContext(0)).lineWidth,\r\n        r = this._borderValue;\r\n      let l, h, c, d;\r\n      this.isHorizontal() ? (l = Ae(t, this.left, o) - o \/ 2, h = Ae(t, this.right, a) + a \/ 2, c = d = r) : (c = Ae(t, this.top, o) - o \/ 2, d = Ae(t, this.bottom, a) + a \/ 2, l = h = r), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, d), e.stroke(), e.restore()\r\n    }\r\n    drawLabels(t) {\r\n      if (!this.options.ticks.display) return;\r\n      const e = this.ctx,\r\n        i = this._computeLabelArea();\r\n      i &amp;&amp; Ie(e, i);\r\n      const s = this.getLabelItems(t);\r\n      for (const t of s) {\r\n        const i = t.options,\r\n          s = t.font;\r\n        Ne(e, t.label, 0, t.textOffset, s, i)\r\n      }\r\n      i &amp;&amp; ze(e)\r\n    }\r\n    drawTitle() {\r\n      const {\r\n        ctx: t,\r\n        options: {\r\n          position: e,\r\n          title: i,\r\n          reverse: s\r\n        }\r\n      } = this;\r\n      if (!i.display) return;\r\n      const a = Si(i.font),\r\n        r = ki(i.padding),\r\n        l = i.align;\r\n      let h = a.lineHeight \/ 2;\r\n      &quot;bottom&quot; === e || &quot;center&quot; === e || o(e) ? (h += r.bottom, n(i.text) &amp;&amp; (h += a.lineHeight * (i.text.length - 1))) : h += r.top;\r\n      const {\r\n        titleX: c,\r\n        titleY: d,\r\n        maxWidth: u,\r\n        rotation: f\r\n      } = function(t, e, i, s) {\r\n        const {\r\n          top: n,\r\n          left: a,\r\n          bottom: r,\r\n          right: l,\r\n          chart: h\r\n        } = t, {\r\n          chartArea: c,\r\n          scales: d\r\n        } = h;\r\n        let u, f, g, p = 0;\r\n        const m = r - n,\r\n          x = l - a;\r\n        if (t.isHorizontal()) {\r\n          if (f = ft(s, a, l), o(i)) {\r\n            const t = Object.keys(i)[0],\r\n              s = i[t];\r\n            g = d[t].getPixelForValue(s) + m - e\r\n          } else g = &quot;center&quot; === i ? (c.bottom + c.top) \/ 2 + m - e : Ys(t, i, e);\r\n          u = l - a\r\n        } else {\r\n          if (o(i)) {\r\n            const t = Object.keys(i)[0],\r\n              s = i[t];\r\n            f = d[t].getPixelForValue(s) - x + e\r\n          } else f = &quot;center&quot; === i ? (c.left + c.right) \/ 2 - x + e : Ys(t, i, e);\r\n          g = ft(s, r, n), p = &quot;left&quot; === i ? -E : E\r\n        }\r\n        return {\r\n          titleX: f,\r\n          titleY: g,\r\n          maxWidth: u,\r\n          rotation: p\r\n        }\r\n      }(this, h, e, l);\r\n      Ne(t, i.text, 0, 0, a, {\r\n        color: i.color,\r\n        maxWidth: u,\r\n        rotation: f,\r\n        textAlign: Zs(l, e, s),\r\n        textBaseline: &quot;middle&quot;,\r\n        translation: [c, d]\r\n      })\r\n    }\r\n    draw(t) {\r\n      this._isVisible() &amp;&amp; (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))\r\n    }\r\n    _layers() {\r\n      const t = this.options,\r\n        e = t.ticks &amp;&amp; t.ticks.z || 0,\r\n        i = l(t.grid &amp;&amp; t.grid.z, -1),\r\n        s = l(t.border &amp;&amp; t.border.z, 0);\r\n      return this._isVisible() &amp;&amp; this.draw === Js.prototype.draw ? [{\r\n        z: i,\r\n        draw: t =&gt; {\r\n          this.drawBackground(), this.drawGrid(t), this.drawTitle()\r\n        }\r\n      }, {\r\n        z: s,\r\n        draw: () =&gt; {\r\n          this.drawBorder()\r\n        }\r\n      }, {\r\n        z: e,\r\n        draw: t =&gt; {\r\n          this.drawLabels(t)\r\n        }\r\n      }] : [{\r\n        z: e,\r\n        draw: t =&gt; {\r\n          this.draw(t)\r\n        }\r\n      }]\r\n    }\r\n    getMatchingVisibleMetas(t) {\r\n      const e = this.chart.getSortedVisibleDatasetMetas(),\r\n        i = this.axis + &quot;AxisID&quot;,\r\n        s = [];\r\n      let n, o;\r\n      for (n = 0, o = e.length; n &lt; o; ++n) {\r\n        const o = e[n];\r\n        o[i] !== this.id || t &amp;&amp; o.type !== t || s.push(o)\r\n      }\r\n      return s\r\n    }\r\n    _resolveTickFontOptions(t) {\r\n      return Si(this.options.ticks.setContext(this.getContext(t)).font)\r\n    }\r\n    _maxDigits() {\r\n      const t = this._resolveTickFontOptions(0).lineHeight;\r\n      return (this.isHorizontal() ? this.width : this.height) \/ t\r\n    }\r\n  }\r\n  class Qs {\r\n    constructor(t, e, i) {\r\n      this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)\r\n    }\r\n    isForType(t) {\r\n      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)\r\n    }\r\n    register(t) {\r\n      const e = Object.getPrototypeOf(t);\r\n      let i;\r\n      (function(t) {\r\n        return &quot;id&quot; in t &amp;&amp; &quot;defaults&quot; in t\r\n      })(e) &amp;&amp; (i = this.register(e));\r\n      const s = this.items,\r\n        n = t.id,\r\n        o = this.scope + &quot;.&quot; + n;\r\n      if (!n) throw new Error(&quot;class does not have id: &quot; + t);\r\n      return n in s || (s[n] = t, function(t, e, i) {\r\n        const s = x(Object.create(null), [i ? ue.get(i) : {}, ue.get(e), t.defaults]);\r\n        ue.set(e, s), t.defaultRoutes &amp;&amp; function(t, e) {\r\n          Object.keys(e).forEach((i =&gt; {\r\n            const s = i.split(&quot;.&quot;),\r\n              n = s.pop(),\r\n              o = [t].concat(s).join(&quot;.&quot;),\r\n              a = e[i].split(&quot;.&quot;),\r\n              r = a.pop(),\r\n              l = a.join(&quot;.&quot;);\r\n            ue.route(o, n, l, r)\r\n          }))\r\n        }(e, t.defaultRoutes);\r\n        t.descriptors &amp;&amp; ue.describe(e, t.descriptors)\r\n      }(t, o, i), this.override &amp;&amp; ue.override(t.id, t.overrides)), o\r\n    }\r\n    get(t) {\r\n      return this.items[t]\r\n    }\r\n    unregister(t) {\r\n      const e = this.items,\r\n        i = t.id,\r\n        s = this.scope;\r\n      i in e &amp;&amp; delete e[i], s &amp;&amp; i in ue[s] &amp;&amp; (delete ue[s][i], this.override &amp;&amp; delete re[i])\r\n    }\r\n  }\r\n  class tn {\r\n    constructor() {\r\n      this.controllers = new Qs(Ns, &quot;datasets&quot;, !0), this.elements = new Qs(Hs, &quot;elements&quot;), this.plugins = new Qs(Object, &quot;plugins&quot;), this.scales = new Qs(Js, &quot;scales&quot;), this._typedRegistries = [this.controllers, this.scales, this.elements]\r\n    }\r\n    add(...t) {\r\n      this._each(&quot;register&quot;, t)\r\n    }\r\n    remove(...t) {\r\n      this._each(&quot;unregister&quot;, t)\r\n    }\r\n    addControllers(...t) {\r\n      this._each(&quot;register&quot;, t, this.controllers)\r\n    }\r\n    addElements(...t) {\r\n      this._each(&quot;register&quot;, t, this.elements)\r\n    }\r\n    addPlugins(...t) {\r\n      this._each(&quot;register&quot;, t, this.plugins)\r\n    }\r\n    addScales(...t) {\r\n      this._each(&quot;register&quot;, t, this.scales)\r\n    }\r\n    getController(t) {\r\n      return this._get(t, this.controllers, &quot;controller&quot;)\r\n    }\r\n    getElement(t) {\r\n      return this._get(t, this.elements, &quot;element&quot;)\r\n    }\r\n    getPlugin(t) {\r\n      return this._get(t, this.plugins, &quot;plugin&quot;)\r\n    }\r\n    getScale(t) {\r\n      return this._get(t, this.scales, &quot;scale&quot;)\r\n    }\r\n    removeControllers(...t) {\r\n      this._each(&quot;unregister&quot;, t, this.controllers)\r\n    }\r\n    removeElements(...t) {\r\n      this._each(&quot;unregister&quot;, t, this.elements)\r\n    }\r\n    removePlugins(...t) {\r\n      this._each(&quot;unregister&quot;, t, this.plugins)\r\n    }\r\n    removeScales(...t) {\r\n      this._each(&quot;unregister&quot;, t, this.scales)\r\n    }\r\n    _each(t, e, i) {\r\n      [...e].forEach((e =&gt; {\r\n        const s = i || this._getRegistryForType(e);\r\n        i || s.isForType(e) || s === this.plugins &amp;&amp; e.id ? this._exec(t, s, e) : u(e, (e =&gt; {\r\n          const s = i || this._getRegistryForType(e);\r\n          this._exec(t, s, e)\r\n        }))\r\n      }))\r\n    }\r\n    _exec(t, e, i) {\r\n      const s = w(t);\r\n      d(i[&quot;before&quot; + s], [], i), e[t](i), d(i[&quot;after&quot; + s], [], i)\r\n    }\r\n    _getRegistryForType(t) {\r\n      for (let e = 0; e &lt; this._typedRegistries.length; e++) {\r\n        const i = this._typedRegistries[e];\r\n        if (i.isForType(t)) return i\r\n      }\r\n      return this.plugins\r\n    }\r\n    _get(t, e, i) {\r\n      const s = e.get(t);\r\n      if (void 0 === s) throw new Error(&#039;&quot;&#039; + t + &#039;&quot; is not a registered &#039; + i + &quot;.&quot;);\r\n      return s\r\n    }\r\n  }\r\n  var en = new tn;\r\n  class sn {\r\n    constructor() {\r\n      this._init = []\r\n    }\r\n    notify(t, e, i, s) {\r\n      &quot;beforeInit&quot; === e &amp;&amp; (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, &quot;install&quot;));\r\n      const n = s ? this._descriptors(t).filter(s) : this._descriptors(t),\r\n        o = this._notify(n, t, e, i);\r\n      return &quot;afterDestroy&quot; === e &amp;&amp; (this._notify(n, t, &quot;stop&quot;), this._notify(this._init, t, &quot;uninstall&quot;)), o\r\n    }\r\n    _notify(t, e, i, s) {\r\n      s = s || {};\r\n      for (const n of t) {\r\n        const t = n.plugin;\r\n        if (!1 === d(t[i], [e, s, n.options], t) &amp;&amp; s.cancelable) return !1\r\n      }\r\n      return !0\r\n    }\r\n    invalidate() {\r\n      s(this._cache) || (this._oldCache = this._cache, this._cache = void 0)\r\n    }\r\n    _descriptors(t) {\r\n      if (this._cache) return this._cache;\r\n      const e = this._cache = this._createDescriptors(t);\r\n      return this._notifyStateChanges(t), e\r\n    }\r\n    _createDescriptors(t, e) {\r\n      const i = t &amp;&amp; t.config,\r\n        s = l(i.options &amp;&amp; i.options.plugins, {}),\r\n        n = function(t) {\r\n          const e = {},\r\n            i = [],\r\n            s = Object.keys(en.plugins.items);\r\n          for (let t = 0; t &lt; s.length; t++) i.push(en.getPlugin(s[t]));\r\n          const n = t.plugins || [];\r\n          for (let t = 0; t &lt; n.length; t++) {\r\n            const s = n[t]; - 1 === i.indexOf(s) &amp;&amp; (i.push(s), e[s.id] = !0)\r\n          }\r\n          return {\r\n            plugins: i,\r\n            localIds: e\r\n          }\r\n        }(i);\r\n      return !1 !== s || e ? function(t, {\r\n        plugins: e,\r\n        localIds: i\r\n      }, s, n) {\r\n        const o = [],\r\n          a = t.getContext();\r\n        for (const r of e) {\r\n          const e = r.id,\r\n            l = nn(s[e], n);\r\n          null !== l &amp;&amp; o.push({\r\n            plugin: r,\r\n            options: on(t.config, {\r\n              plugin: r,\r\n              local: i[e]\r\n            }, l, a)\r\n          })\r\n        }\r\n        return o\r\n      }(t, n, s, e) : []\r\n    }\r\n    _notifyStateChanges(t) {\r\n      const e = this._oldCache || [],\r\n        i = this._cache,\r\n        s = (t, e) =&gt; t.filter((t =&gt; !e.some((e =&gt; t.plugin.id === e.plugin.id))));\r\n      this._notify(s(e, i), t, &quot;stop&quot;), this._notify(s(i, e), t, &quot;start&quot;)\r\n    }\r\n  }\r\n\r\n  function nn(t, e) {\r\n    return e || !1 !== t ? !0 === t ? {} : t : null\r\n  }\r\n\r\n  function on(t, {\r\n    plugin: e,\r\n    local: i\r\n  }, s, n) {\r\n    const o = t.pluginScopeKeys(e),\r\n      a = t.getOptionScopes(s, o);\r\n    return i &amp;&amp; e.defaults &amp;&amp; a.push(e.defaults), t.createResolver(a, n, [&quot;&quot;], {\r\n      scriptable: !1,\r\n      indexable: !1,\r\n      allKeys: !0\r\n    })\r\n  }\r\n\r\n  function an(t, e) {\r\n    const i = ue.datasets[t] || {};\r\n    return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || &quot;x&quot;\r\n  }\r\n\r\n  function rn(t) {\r\n    if (&quot;x&quot; === t || &quot;y&quot; === t || &quot;r&quot; === t) return t\r\n  }\r\n\r\n  function ln(t, ...e) {\r\n    if (rn(t)) return t;\r\n    for (const s of e) {\r\n      const e = s.axis || (&quot;top&quot; === (i = s.position) || &quot;bottom&quot; === i ? &quot;x&quot; : &quot;left&quot; === i || &quot;right&quot; === i ? &quot;y&quot; : void 0) || t.length &gt; 1 &amp;&amp; rn(t[0].toLowerCase());\r\n      if (e) return e\r\n    }\r\n    var i;\r\n    throw new Error(`Cannot determine type of &#039;${t}&#039; axis. Please provide &#039;axis&#039; or &#039;position&#039; option.`)\r\n  }\r\n\r\n  function hn(t, e, i) {\r\n    if (i[e + &quot;AxisID&quot;] === t) return {\r\n      axis: e\r\n    }\r\n  }\r\n\r\n  function cn(t, e) {\r\n    const i = re[t.type] || {\r\n        scales: {}\r\n      },\r\n      s = e.scales || {},\r\n      n = an(t.type, e),\r\n      a = Object.create(null);\r\n    return Object.keys(s).forEach((e =&gt; {\r\n      const r = s[e];\r\n      if (!o(r)) return console.error(`Invalid scale configuration for scale: ${e}`);\r\n      if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`);\r\n      const l = ln(e, r, function(t, e) {\r\n          if (e.data &amp;&amp; e.data.datasets) {\r\n            const i = e.data.datasets.filter((e =&gt; e.xAxisID === t || e.yAxisID === t));\r\n            if (i.length) return hn(t, &quot;x&quot;, i[0]) || hn(t, &quot;y&quot;, i[0])\r\n          }\r\n          return {}\r\n        }(e, t), ue.scales[r.type]),\r\n        h = function(t, e) {\r\n          return t === e ? &quot;_index_&quot; : &quot;_value_&quot;\r\n        }(l, n),\r\n        c = i.scales || {};\r\n      a[e] = b(Object.create(null), [{\r\n        axis: l\r\n      }, r, c[l], c[h]])\r\n    })), t.data.datasets.forEach((i =&gt; {\r\n      const n = i.type || t.type,\r\n        o = i.indexAxis || an(n, e),\r\n        r = (re[n] || {}).scales || {};\r\n      Object.keys(r).forEach((t =&gt; {\r\n        const e = function(t, e) {\r\n            let i = t;\r\n            return &quot;_index_&quot; === t ? i = e : &quot;_value_&quot; === t &amp;&amp; (i = &quot;x&quot; === e ? &quot;y&quot; : &quot;x&quot;), i\r\n          }(t, o),\r\n          n = i[e + &quot;AxisID&quot;] || e;\r\n        a[n] = a[n] || Object.create(null), b(a[n], [{\r\n          axis: e\r\n        }, s[n], r[t]])\r\n      }))\r\n    })), Object.keys(a).forEach((t =&gt; {\r\n      const e = a[t];\r\n      b(e, [ue.scales[e.type], ue.scale])\r\n    })), a\r\n  }\r\n\r\n  function dn(t) {\r\n    const e = t.options || (t.options = {});\r\n    e.plugins = l(e.plugins, {}), e.scales = cn(t, e)\r\n  }\r\n\r\n  function un(t) {\r\n    return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t\r\n  }\r\n  const fn = new Map,\r\n    gn = new Set;\r\n\r\n  function pn(t, e) {\r\n    let i = fn.get(t);\r\n    return i || (i = e(), fn.set(t, i), gn.add(i)), i\r\n  }\r\n  const mn = (t, e, i) =&gt; {\r\n    const s = M(e, i);\r\n    void 0 !== s &amp;&amp; t.add(s)\r\n  };\r\n  class xn {\r\n    constructor(t) {\r\n      this._config = function(t) {\r\n        return (t = t || {}).data = un(t.data), dn(t), t\r\n      }(t), this._scopeCache = new Map, this._resolverCache = new Map\r\n    }\r\n    get platform() {\r\n      return this._config.platform\r\n    }\r\n    get type() {\r\n      return this._config.type\r\n    }\r\n    set type(t) {\r\n      this._config.type = t\r\n    }\r\n    get data() {\r\n      return this._config.data\r\n    }\r\n    set data(t) {\r\n      this._config.data = un(t)\r\n    }\r\n    get options() {\r\n      return this._config.options\r\n    }\r\n    set options(t) {\r\n      this._config.options = t\r\n    }\r\n    get plugins() {\r\n      return this._config.plugins\r\n    }\r\n    update() {\r\n      const t = this._config;\r\n      this.clearCache(), dn(t)\r\n    }\r\n    clearCache() {\r\n      this._scopeCache.clear(), this._resolverCache.clear()\r\n    }\r\n    datasetScopeKeys(t) {\r\n      return pn(t, (() =&gt; [\r\n        [`datasets.${t}`, &quot;&quot;]\r\n      ]))\r\n    }\r\n    datasetAnimationScopeKeys(t, e) {\r\n      return pn(`${t}.transition.${e}`, (() =&gt; [\r\n        [`datasets.${t}.transitions.${e}`, `transitions.${e}`],\r\n        [`datasets.${t}`, &quot;&quot;]\r\n      ]))\r\n    }\r\n    datasetElementScopeKeys(t, e) {\r\n      return pn(`${t}-${e}`, (() =&gt; [\r\n        [`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, &quot;&quot;]\r\n      ]))\r\n    }\r\n    pluginScopeKeys(t) {\r\n      const e = t.id;\r\n      return pn(`${this.type}-plugin-${e}`, (() =&gt; [\r\n        [`plugins.${e}`, ...t.additionalOptionScopes || []]\r\n      ]))\r\n    }\r\n    _cachedScopes(t, e) {\r\n      const i = this._scopeCache;\r\n      let s = i.get(t);\r\n      return s &amp;&amp; !e || (s = new Map, i.set(t, s)), s\r\n    }\r\n    getOptionScopes(t, e, i) {\r\n      const {\r\n        options: s,\r\n        type: n\r\n      } = this, o = this._cachedScopes(t, i), a = o.get(e);\r\n      if (a) return a;\r\n      const r = new Set;\r\n      e.forEach((e =&gt; {\r\n        t &amp;&amp; (r.add(t), e.forEach((e =&gt; mn(r, t, e)))), e.forEach((t =&gt; mn(r, s, t))), e.forEach((t =&gt; mn(r, re[n] || {}, t))), e.forEach((t =&gt; mn(r, ue, t))), e.forEach((t =&gt; mn(r, le, t)))\r\n      }));\r\n      const l = Array.from(r);\r\n      return 0 === l.length &amp;&amp; l.push(Object.create(null)), gn.has(e) &amp;&amp; o.set(e, l), l\r\n    }\r\n    chartOptionScopes() {\r\n      const {\r\n        options: t,\r\n        type: e\r\n      } = this;\r\n      return [t, re[e] || {}, ue.datasets[e] || {}, {\r\n        type: e\r\n      }, ue, le]\r\n    }\r\n    resolveNamedOptions(t, e, i, s = [&quot;&quot;]) {\r\n      const o = {\r\n          $shared: !0\r\n        },\r\n        {\r\n          resolver: a,\r\n          subPrefixes: r\r\n        } = bn(this._resolverCache, t, s);\r\n      let l = a;\r\n      if (function(t, e) {\r\n          const {\r\n            isScriptable: i,\r\n            isIndexable: s\r\n          } = Ye(t);\r\n          for (const o of e) {\r\n            const e = i(o),\r\n              a = s(o),\r\n              r = (a || e) &amp;&amp; t[o];\r\n            if (e &amp;&amp; (S(r) || _n(r)) || a &amp;&amp; n(r)) return !0\r\n          }\r\n          return !1\r\n        }(a, e)) {\r\n        o.$shared = !1;\r\n        l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r))\r\n      }\r\n      for (const t of e) o[t] = l[t];\r\n      return o\r\n    }\r\n    createResolver(t, e, i = [&quot;&quot;], s) {\r\n      const {\r\n        resolver: n\r\n      } = bn(this._resolverCache, t, i);\r\n      return o(e) ? $e(n, e, void 0, s) : n\r\n    }\r\n  }\r\n\r\n  function bn(t, e, i) {\r\n    let s = t.get(e);\r\n    s || (s = new Map, t.set(e, s));\r\n    const n = i.join();\r\n    let o = s.get(n);\r\n    if (!o) {\r\n      o = {\r\n        resolver: je(e, i),\r\n        subPrefixes: i.filter((t =&gt; !t.toLowerCase().includes(&quot;hover&quot;)))\r\n      }, s.set(n, o)\r\n    }\r\n    return o\r\n  }\r\n  const _n = t =&gt; o(t) &amp;&amp; Object.getOwnPropertyNames(t).some((e =&gt; S(t[e])));\r\n  const yn = [&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;chartArea&quot;];\r\n\r\n  function vn(t, e) {\r\n    return &quot;top&quot; === t || &quot;bottom&quot; === t || -1 === yn.indexOf(t) &amp;&amp; &quot;x&quot; === e\r\n  }\r\n\r\n  function Mn(t, e) {\r\n    return function(i, s) {\r\n      return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t]\r\n    }\r\n  }\r\n\r\n  function wn(t) {\r\n    const e = t.chart,\r\n      i = e.options.animation;\r\n    e.notifyPlugins(&quot;afterRender&quot;), d(i &amp;&amp; i.onComplete, [t], e)\r\n  }\r\n\r\n  function kn(t) {\r\n    const e = t.chart,\r\n      i = e.options.animation;\r\n    d(i &amp;&amp; i.onProgress, [t], e)\r\n  }\r\n\r\n  function Sn(t) {\r\n    return fe() &amp;&amp; &quot;string&quot; == typeof t ? t = document.getElementById(t) : t &amp;&amp; t.length &amp;&amp; (t = t[0]), t &amp;&amp; t.canvas &amp;&amp; (t = t.canvas), t\r\n  }\r\n  const Pn = {},\r\n    Dn = t =&gt; {\r\n      const e = Sn(t);\r\n      return Object.values(Pn).filter((t =&gt; t.canvas === e)).pop()\r\n    };\r\n\r\n  function Cn(t, e, i) {\r\n    const s = Object.keys(t);\r\n    for (const n of s) {\r\n      const s = +n;\r\n      if (s &gt;= e) {\r\n        const o = t[n];\r\n        delete t[n], (i &gt; 0 || s &gt; e) &amp;&amp; (t[s + i] = o)\r\n      }\r\n    }\r\n  }\r\n\r\n  function On(t, e, i) {\r\n    return t.options.clip ? t[i] : e[i]\r\n  }\r\n  class An {\r\n    static defaults = ue;\r\n    static instances = Pn;\r\n    static overrides = re;\r\n    static registry = en;\r\n    static version = &quot;4.4.3&quot;;\r\n    static getChart = Dn;\r\n    static register(...t) {\r\n      en.add(...t), Tn()\r\n    }\r\n    static unregister(...t) {\r\n      en.remove(...t), Tn()\r\n    }\r\n    constructor(t, e) {\r\n      const s = this.config = new xn(e),\r\n        n = Sn(t),\r\n        o = Dn(n);\r\n      if (o) throw new Error(&quot;Canvas is already in use. Chart with ID &#039;&quot; + o.id + &quot;&#039; must be destroyed before the canvas with ID &#039;&quot; + o.canvas.id + &quot;&#039; can be reused.&quot;);\r\n      const a = s.createResolver(s.chartOptionScopes(), this.getContext());\r\n      this.platform = new(s.platform || ks(n)), this.platform.updateConfig(s);\r\n      const r = this.platform.acquireContext(n, a.aspectRatio),\r\n        l = r &amp;&amp; r.canvas,\r\n        h = l &amp;&amp; l.height,\r\n        c = l &amp;&amp; l.width;\r\n      this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t =&gt; this.update(t)), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r &amp;&amp; l ? (bt.listen(this, &quot;complete&quot;, wn), bt.listen(this, &quot;progress&quot;, kn), this._initialize(), this.attached &amp;&amp; this.update()) : console.error(&quot;Failed to create chart: can&#039;t acquire context from the given item&quot;)\r\n    }\r\n    get aspectRatio() {\r\n      const {\r\n        options: {\r\n          aspectRatio: t,\r\n          maintainAspectRatio: e\r\n        },\r\n        width: i,\r\n        height: n,\r\n        _aspectRatio: o\r\n      } = this;\r\n      return s(t) ? e &amp;&amp; o ? o : n ? i \/ n : null : t\r\n    }\r\n    get data() {\r\n      return this.config.data\r\n    }\r\n    set data(t) {\r\n      this.config.data = t\r\n    }\r\n    get options() {\r\n      return this._options\r\n    }\r\n    set options(t) {\r\n      this.config.options = t\r\n    }\r\n    get registry() {\r\n      return en\r\n    }\r\n    _initialize() {\r\n      return this.notifyPlugins(&quot;beforeInit&quot;), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(&quot;afterInit&quot;), this\r\n    }\r\n    clear() {\r\n      return Te(this.canvas, this.ctx), this\r\n    }\r\n    stop() {\r\n      return bt.stop(this), this\r\n    }\r\n    resize(t, e) {\r\n      bt.running(this) ? this._resizeBeforeDraw = {\r\n        width: t,\r\n        height: e\r\n      } : this._resize(t, e)\r\n    }\r\n    _resize(t, e) {\r\n      const i = this.options,\r\n        s = this.canvas,\r\n        n = i.maintainAspectRatio &amp;&amp; this.aspectRatio,\r\n        o = this.platform.getMaximumSize(s, t, e, n),\r\n        a = i.devicePixelRatio || this.platform.getDevicePixelRatio(),\r\n        r = this.width ? &quot;resize&quot; : &quot;attach&quot;;\r\n      this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ke(this, a, !0) &amp;&amp; (this.notifyPlugins(&quot;resize&quot;, {\r\n        size: o\r\n      }), d(i.onResize, [this, o], this), this.attached &amp;&amp; this._doResize(r) &amp;&amp; this.render())\r\n    }\r\n    ensureScalesHaveIDs() {\r\n      u(this.options.scales || {}, ((t, e) =&gt; {\r\n        t.id = e\r\n      }))\r\n    }\r\n    buildOrUpdateScales() {\r\n      const t = this.options,\r\n        e = t.scales,\r\n        i = this.scales,\r\n        s = Object.keys(i).reduce(((t, e) =&gt; (t[e] = !1, t)), {});\r\n      let n = [];\r\n      e &amp;&amp; (n = n.concat(Object.keys(e).map((t =&gt; {\r\n        const i = e[t],\r\n          s = ln(t, i),\r\n          n = &quot;r&quot; === s,\r\n          o = &quot;x&quot; === s;\r\n        return {\r\n          options: i,\r\n          dposition: n ? &quot;chartArea&quot; : o ? &quot;bottom&quot; : &quot;left&quot;,\r\n          dtype: n ? &quot;radialLinear&quot; : o ? &quot;category&quot; : &quot;linear&quot;\r\n        }\r\n      })))), u(n, (e =&gt; {\r\n        const n = e.options,\r\n          o = n.id,\r\n          a = ln(o, n),\r\n          r = l(n.type, e.dtype);\r\n        void 0 !== n.position &amp;&amp; vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0;\r\n        let h = null;\r\n        if (o in i &amp;&amp; i[o].type === r) h = i[o];\r\n        else {\r\n          h = new(en.getScale(r))({\r\n            id: o,\r\n            type: r,\r\n            ctx: this.ctx,\r\n            chart: this\r\n          }), i[h.id] = h\r\n        }\r\n        h.init(n, t)\r\n      })), u(s, ((t, e) =&gt; {\r\n        t || delete i[e]\r\n      })), u(i, (t =&gt; {\r\n        as.configure(this, t, t.options), as.addBox(this, t)\r\n      }))\r\n    }\r\n    _updateMetasets() {\r\n      const t = this._metasets,\r\n        e = this.data.datasets.length,\r\n        i = t.length;\r\n      if (t.sort(((t, e) =&gt; t.index - e.index)), i &gt; e) {\r\n        for (let t = e; t &lt; i; ++t) this._destroyDatasetMeta(t);\r\n        t.splice(e, i - e)\r\n      }\r\n      this._sortedMetasets = t.slice(0).sort(Mn(&quot;order&quot;, &quot;index&quot;))\r\n    }\r\n    _removeUnreferencedMetasets() {\r\n      const {\r\n        _metasets: t,\r\n        data: {\r\n          datasets: e\r\n        }\r\n      } = this;\r\n      t.length &gt; e.length &amp;&amp; delete this._stacks, t.forEach(((t, i) =&gt; {\r\n        0 === e.filter((e =&gt; e === t._dataset)).length &amp;&amp; this._destroyDatasetMeta(i)\r\n      }))\r\n    }\r\n    buildOrUpdateControllers() {\r\n      const t = [],\r\n        e = this.data.datasets;\r\n      let i, s;\r\n      for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i &lt; s; i++) {\r\n        const s = e[i];\r\n        let n = this.getDatasetMeta(i);\r\n        const o = s.type || this.config.type;\r\n        if (n.type &amp;&amp; n.type !== o &amp;&amp; (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = &quot;&quot; + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();\r\n        else {\r\n          const e = en.getController(o),\r\n            {\r\n              datasetElementType: s,\r\n              dataElementType: a\r\n            } = ue.datasets[o];\r\n          Object.assign(e, {\r\n            dataElementType: en.getElement(a),\r\n            datasetElementType: s &amp;&amp; en.getElement(s)\r\n          }), n.controller = new e(this, i), t.push(n.controller)\r\n        }\r\n      }\r\n      return this._updateMetasets(), t\r\n    }\r\n    _resetElements() {\r\n      u(this.data.datasets, ((t, e) =&gt; {\r\n        this.getDatasetMeta(e).controller.reset()\r\n      }), this)\r\n    }\r\n    reset() {\r\n      this._resetElements(), this.notifyPlugins(&quot;reset&quot;)\r\n    }\r\n    update(t) {\r\n      const e = this.config;\r\n      e.update();\r\n      const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),\r\n        s = this._animationsDisabled = !i.animation;\r\n      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins(&quot;beforeUpdate&quot;, {\r\n          mode: t,\r\n          cancelable: !0\r\n        })) return;\r\n      const n = this.buildOrUpdateControllers();\r\n      this.notifyPlugins(&quot;beforeElementsUpdate&quot;);\r\n      let o = 0;\r\n      for (let t = 0, e = this.data.datasets.length; t &lt; e; t++) {\r\n        const {\r\n          controller: e\r\n        } = this.getDatasetMeta(t), i = !s &amp;&amp; -1 === n.indexOf(e);\r\n        e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o)\r\n      }\r\n      o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t =&gt; {\r\n        t.reset()\r\n      })), this._updateDatasets(t), this.notifyPlugins(&quot;afterUpdate&quot;, {\r\n        mode: t\r\n      }), this._layers.sort(Mn(&quot;z&quot;, &quot;_idx&quot;));\r\n      const {\r\n        _active: a,\r\n        _lastEvent: r\r\n      } = this;\r\n      r ? this._eventHandler(r, !0) : a.length &amp;&amp; this._updateHoverStyles(a, a, !0), this.render()\r\n    }\r\n    _updateScales() {\r\n      u(this.scales, (t =&gt; {\r\n        as.removeBox(this, t)\r\n      })), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()\r\n    }\r\n    _checkEventBindings() {\r\n      const t = this.options,\r\n        e = new Set(Object.keys(this._listeners)),\r\n        i = new Set(t.events);\r\n      P(e, i) &amp;&amp; !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents())\r\n    }\r\n    _updateHiddenIndices() {\r\n      const {\r\n        _hiddenIndices: t\r\n      } = this, e = this._getUniformDataChanges() || [];\r\n      for (const {\r\n          method: i,\r\n          start: s,\r\n          count: n\r\n        }\r\n        of e) {\r\n        Cn(t, s, &quot;_removeElements&quot; === i ? -n : n)\r\n      }\r\n    }\r\n    _getUniformDataChanges() {\r\n      const t = this._dataChanges;\r\n      if (!t || !t.length) return;\r\n      this._dataChanges = [];\r\n      const e = this.data.datasets.length,\r\n        i = e =&gt; new Set(t.filter((t =&gt; t[0] === e)).map(((t, e) =&gt; e + &quot;,&quot; + t.splice(1).join(&quot;,&quot;)))),\r\n        s = i(0);\r\n      for (let t = 1; t &lt; e; t++)\r\n        if (!P(s, i(t))) return;\r\n      return Array.from(s).map((t =&gt; t.split(&quot;,&quot;))).map((t =&gt; ({\r\n        method: t[1],\r\n        start: +t[2],\r\n        count: +t[3]\r\n      })))\r\n    }\r\n    _updateLayout(t) {\r\n      if (!1 === this.notifyPlugins(&quot;beforeLayout&quot;, {\r\n          cancelable: !0\r\n        })) return;\r\n      as.update(this, this.width, this.height, t);\r\n      const e = this.chartArea,\r\n        i = e.width &lt;= 0 || e.height &lt;= 0;\r\n      this._layers = [], u(this.boxes, (t =&gt; {\r\n        i &amp;&amp; &quot;chartArea&quot; === t.position || (t.configure &amp;&amp; t.configure(), this._layers.push(...t._layers()))\r\n      }), this), this._layers.forEach(((t, e) =&gt; {\r\n        t._idx = e\r\n      })), this.notifyPlugins(&quot;afterLayout&quot;)\r\n    }\r\n    _updateDatasets(t) {\r\n      if (!1 !== this.notifyPlugins(&quot;beforeDatasetsUpdate&quot;, {\r\n          mode: t,\r\n          cancelable: !0\r\n        })) {\r\n        for (let t = 0, e = this.data.datasets.length; t &lt; e; ++t) this.getDatasetMeta(t).controller.configure();\r\n        for (let e = 0, i = this.data.datasets.length; e &lt; i; ++e) this._updateDataset(e, S(t) ? t({\r\n          datasetIndex: e\r\n        }) : t);\r\n        this.notifyPlugins(&quot;afterDatasetsUpdate&quot;, {\r\n          mode: t\r\n        })\r\n      }\r\n    }\r\n    _updateDataset(t, e) {\r\n      const i = this.getDatasetMeta(t),\r\n        s = {\r\n          meta: i,\r\n          index: t,\r\n          mode: e,\r\n          cancelable: !0\r\n        };\r\n      !1 !== this.notifyPlugins(&quot;beforeDatasetUpdate&quot;, s) &amp;&amp; (i.controller._update(e), s.cancelable = !1, this.notifyPlugins(&quot;afterDatasetUpdate&quot;, s))\r\n    }\r\n    render() {\r\n      !1 !== this.notifyPlugins(&quot;beforeRender&quot;, {\r\n        cancelable: !0\r\n      }) &amp;&amp; (bt.has(this) ? this.attached &amp;&amp; !bt.running(this) &amp;&amp; bt.start(this) : (this.draw(), wn({\r\n        chart: this\r\n      })))\r\n    }\r\n    draw() {\r\n      let t;\r\n      if (this._resizeBeforeDraw) {\r\n        const {\r\n          width: t,\r\n          height: e\r\n        } = this._resizeBeforeDraw;\r\n        this._resize(t, e), this._resizeBeforeDraw = null\r\n      }\r\n      if (this.clear(), this.width &lt;= 0 || this.height &lt;= 0) return;\r\n      if (!1 === this.notifyPlugins(&quot;beforeDraw&quot;, {\r\n          cancelable: !0\r\n        })) return;\r\n      const e = this._layers;\r\n      for (t = 0; t &lt; e.length &amp;&amp; e[t].z &lt;= 0; ++t) e[t].draw(this.chartArea);\r\n      for (this._drawDatasets(); t &lt; e.length; ++t) e[t].draw(this.chartArea);\r\n      this.notifyPlugins(&quot;afterDraw&quot;)\r\n    }\r\n    _getSortedDatasetMetas(t) {\r\n      const e = this._sortedMetasets,\r\n        i = [];\r\n      let s, n;\r\n      for (s = 0, n = e.length; s &lt; n; ++s) {\r\n        const n = e[s];\r\n        t &amp;&amp; !n.visible || i.push(n)\r\n      }\r\n      return i\r\n    }\r\n    getSortedVisibleDatasetMetas() {\r\n      return this._getSortedDatasetMetas(!0)\r\n    }\r\n    _drawDatasets() {\r\n      if (!1 === this.notifyPlugins(&quot;beforeDatasetsDraw&quot;, {\r\n          cancelable: !0\r\n        })) return;\r\n      const t = this.getSortedVisibleDatasetMetas();\r\n      for (let e = t.length - 1; e &gt;= 0; --e) this._drawDataset(t[e]);\r\n      this.notifyPlugins(&quot;afterDatasetsDraw&quot;)\r\n    }\r\n    _drawDataset(t) {\r\n      const e = this.ctx,\r\n        i = t._clip,\r\n        s = !i.disabled,\r\n        n = function(t, e) {\r\n          const {\r\n            xScale: i,\r\n            yScale: s\r\n          } = t;\r\n          return i &amp;&amp; s ? {\r\n            left: On(i, e, &quot;left&quot;),\r\n            right: On(i, e, &quot;right&quot;),\r\n            top: On(s, e, &quot;top&quot;),\r\n            bottom: On(s, e, &quot;bottom&quot;)\r\n          } : e\r\n        }(t, this.chartArea),\r\n        o = {\r\n          meta: t,\r\n          index: t.index,\r\n          cancelable: !0\r\n        };\r\n      !1 !== this.notifyPlugins(&quot;beforeDatasetDraw&quot;, o) &amp;&amp; (s &amp;&amp; Ie(e, {\r\n        left: !1 === i.left ? 0 : n.left - i.left,\r\n        right: !1 === i.right ? this.width : n.right + i.right,\r\n        top: !1 === i.top ? 0 : n.top - i.top,\r\n        bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom\r\n      }), t.controller.draw(), s &amp;&amp; ze(e), o.cancelable = !1, this.notifyPlugins(&quot;afterDatasetDraw&quot;, o))\r\n    }\r\n    isPointInArea(t) {\r\n      return Re(t, this.chartArea, this._minPadding)\r\n    }\r\n    getElementsAtEventForMode(t, e, i, s) {\r\n      const n = Xi.modes[e];\r\n      return &quot;function&quot; == typeof n ? n(this, t, i, s) : []\r\n    }\r\n    getDatasetMeta(t) {\r\n      const e = this.data.datasets[t],\r\n        i = this._metasets;\r\n      let s = i.filter((t =&gt; t &amp;&amp; t._dataset === e)).pop();\r\n      return s || (s = {\r\n        type: null,\r\n        data: [],\r\n        dataset: null,\r\n        controller: null,\r\n        hidden: null,\r\n        xAxisID: null,\r\n        yAxisID: null,\r\n        order: e &amp;&amp; e.order || 0,\r\n        index: t,\r\n        _dataset: e,\r\n        _parsed: [],\r\n        _sorted: !1\r\n      }, i.push(s)), s\r\n    }\r\n    getContext() {\r\n      return this.$context || (this.$context = Ci(null, {\r\n        chart: this,\r\n        type: &quot;chart&quot;\r\n      }))\r\n    }\r\n    getVisibleDatasetCount() {\r\n      return this.getSortedVisibleDatasetMetas().length\r\n    }\r\n    isDatasetVisible(t) {\r\n      const e = this.data.datasets[t];\r\n      if (!e) return !1;\r\n      const i = this.getDatasetMeta(t);\r\n      return &quot;boolean&quot; == typeof i.hidden ? !i.hidden : !e.hidden\r\n    }\r\n    setDatasetVisibility(t, e) {\r\n      this.getDatasetMeta(t).hidden = !e\r\n    }\r\n    toggleDataVisibility(t) {\r\n      this._hiddenIndices[t] = !this._hiddenIndices[t]\r\n    }\r\n    getDataVisibility(t) {\r\n      return !this._hiddenIndices[t]\r\n    }\r\n    _updateVisibility(t, e, i) {\r\n      const s = i ? &quot;show&quot; : &quot;hide&quot;,\r\n        n = this.getDatasetMeta(t),\r\n        o = n.controller._resolveAnimations(void 0, s);\r\n      k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {\r\n        visible: i\r\n      }), this.update((e =&gt; e.datasetIndex === t ? s : void 0)))\r\n    }\r\n    hide(t, e) {\r\n      this._updateVisibility(t, e, !1)\r\n    }\r\n    show(t, e) {\r\n      this._updateVisibility(t, e, !0)\r\n    }\r\n    _destroyDatasetMeta(t) {\r\n      const e = this._metasets[t];\r\n      e &amp;&amp; e.controller &amp;&amp; e.controller._destroy(), delete this._metasets[t]\r\n    }\r\n    _stop() {\r\n      let t, e;\r\n      for (this.stop(), bt.remove(this), t = 0, e = this.data.datasets.length; t &lt; e; ++t) this._destroyDatasetMeta(t)\r\n    }\r\n    destroy() {\r\n      this.notifyPlugins(&quot;beforeDestroy&quot;);\r\n      const {\r\n        canvas: t,\r\n        ctx: e\r\n      } = this;\r\n      this._stop(), this.config.clearCache(), t &amp;&amp; (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins(&quot;afterDestroy&quot;)\r\n    }\r\n    toBase64Image(...t) {\r\n      return this.canvas.toDataURL(...t)\r\n    }\r\n    bindEvents() {\r\n      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0\r\n    }\r\n    bindUserEvents() {\r\n      const t = this._listeners,\r\n        e = this.platform,\r\n        i = (i, s) =&gt; {\r\n          e.addEventListener(this, i, s), t[i] = s\r\n        },\r\n        s = (t, e, i) =&gt; {\r\n          t.offsetX = e, t.offsetY = i, this._eventHandler(t)\r\n        };\r\n      u(this.options.events, (t =&gt; i(t, s)))\r\n    }\r\n    bindResponsiveEvents() {\r\n      this._responsiveListeners || (this._responsiveListeners = {});\r\n      const t = this._responsiveListeners,\r\n        e = this.platform,\r\n        i = (i, s) =&gt; {\r\n          e.addEventListener(this, i, s), t[i] = s\r\n        },\r\n        s = (i, s) =&gt; {\r\n          t[i] &amp;&amp; (e.removeEventListener(this, i, s), delete t[i])\r\n        },\r\n        n = (t, e) =&gt; {\r\n          this.canvas &amp;&amp; this.resize(t, e)\r\n        };\r\n      let o;\r\n      const a = () =&gt; {\r\n        s(&quot;attach&quot;, a), this.attached = !0, this.resize(), i(&quot;resize&quot;, n), i(&quot;detach&quot;, o)\r\n      };\r\n      o = () =&gt; {\r\n        this.attached = !1, s(&quot;resize&quot;, n), this._stop(), this._resize(0, 0), i(&quot;attach&quot;, a)\r\n      }, e.isAttached(this.canvas) ? a() : o()\r\n    }\r\n    unbindEvents() {\r\n      u(this._listeners, ((t, e) =&gt; {\r\n        this.platform.removeEventListener(this, e, t)\r\n      })), this._listeners = {}, u(this._responsiveListeners, ((t, e) =&gt; {\r\n        this.platform.removeEventListener(this, e, t)\r\n      })), this._responsiveListeners = void 0\r\n    }\r\n    updateHoverStyle(t, e, i) {\r\n      const s = i ? &quot;set&quot; : &quot;remove&quot;;\r\n      let n, o, a, r;\r\n      for (&quot;dataset&quot; === e &amp;&amp; (n = this.getDatasetMeta(t[0].datasetIndex), n.controller[&quot;_&quot; + s + &quot;DatasetHoverStyle&quot;]()), a = 0, r = t.length; a &lt; r; ++a) {\r\n        o = t[a];\r\n        const e = o &amp;&amp; this.getDatasetMeta(o.datasetIndex).controller;\r\n        e &amp;&amp; e[s + &quot;HoverStyle&quot;](o.element, o.datasetIndex, o.index)\r\n      }\r\n    }\r\n    getActiveElements() {\r\n      return this._active || []\r\n    }\r\n    setActiveElements(t) {\r\n      const e = this._active || [],\r\n        i = t.map((({\r\n          datasetIndex: t,\r\n          index: e\r\n        }) =&gt; {\r\n          const i = this.getDatasetMeta(t);\r\n          if (!i) throw new Error(&quot;No dataset found at index &quot; + t);\r\n          return {\r\n            datasetIndex: t,\r\n            element: i.data[e],\r\n            index: e\r\n          }\r\n        }));\r\n      !f(i, e) &amp;&amp; (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e))\r\n    }\r\n    notifyPlugins(t, e, i) {\r\n      return this._plugins.notify(this, t, e, i)\r\n    }\r\n    isPluginEnabled(t) {\r\n      return 1 === this._plugins._cache.filter((e =&gt; e.plugin.id === t)).length\r\n    }\r\n    _updateHoverStyles(t, e, i) {\r\n      const s = this.options.hover,\r\n        n = (t, e) =&gt; t.filter((t =&gt; !e.some((e =&gt; t.datasetIndex === e.datasetIndex &amp;&amp; t.index === e.index)))),\r\n        o = n(e, t),\r\n        a = i ? t : n(t, e);\r\n      o.length &amp;&amp; this.updateHoverStyle(o, s.mode, !1), a.length &amp;&amp; s.mode &amp;&amp; this.updateHoverStyle(a, s.mode, !0)\r\n    }\r\n    _eventHandler(t, e) {\r\n      const i = {\r\n          event: t,\r\n          replay: e,\r\n          cancelable: !0,\r\n          inChartArea: this.isPointInArea(t)\r\n        },\r\n        s = e =&gt; (e.options.events || this.options.events).includes(t.native.type);\r\n      if (!1 === this.notifyPlugins(&quot;beforeEvent&quot;, i, s)) return;\r\n      const n = this._handleEvent(t, e, i.inChartArea);\r\n      return i.cancelable = !1, this.notifyPlugins(&quot;afterEvent&quot;, i, s), (n || i.changed) &amp;&amp; this.render(), this\r\n    }\r\n    _handleEvent(t, e, i) {\r\n      const {\r\n        _active: s = [],\r\n        options: n\r\n      } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function(t, e, i, s) {\r\n        return i &amp;&amp; &quot;mouseout&quot; !== t.type ? s ? e : t : null\r\n      }(t, this._lastEvent, i, r);\r\n      i &amp;&amp; (this._lastEvent = null, d(n.onHover, [t, a, this], this), r &amp;&amp; d(n.onClick, [t, a, this], this));\r\n      const h = !f(a, s);\r\n      return (h || e) &amp;&amp; (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h\r\n    }\r\n    _getActiveElements(t, e, i, s) {\r\n      if (&quot;mouseout&quot; === t.type) return [];\r\n      if (!i) return e;\r\n      const n = this.options.hover;\r\n      return this.getElementsAtEventForMode(t, n.mode, n, s)\r\n    }\r\n  }\r\n\r\n  function Tn() {\r\n    return u(An.instances, (t =&gt; t._plugins.invalidate()))\r\n  }\r\n\r\n  function Ln() {\r\n    throw new Error(&quot;This method is not implemented: Check that a complete date adapter is provided.&quot;)\r\n  }\r\n  class En {\r\n    static override(t) {\r\n      Object.assign(En.prototype, t)\r\n    }\r\n    options;\r\n    constructor(t) {\r\n      this.options = t || {}\r\n    }\r\n    init() {}\r\n    formats() {\r\n      return Ln()\r\n    }\r\n    parse() {\r\n      return Ln()\r\n    }\r\n    format() {\r\n      return Ln()\r\n    }\r\n    add() {\r\n      return Ln()\r\n    }\r\n    diff() {\r\n      return Ln()\r\n    }\r\n    startOf() {\r\n      return Ln()\r\n    }\r\n    endOf() {\r\n      return Ln()\r\n    }\r\n  }\r\n  var Rn = {\r\n    _date: En\r\n  };\r\n\r\n  function In(t) {\r\n    const e = t.iScale,\r\n      i = function(t, e) {\r\n        if (!t._cache.$bar) {\r\n          const i = t.getMatchingVisibleMetas(e);\r\n          let s = [];\r\n          for (let e = 0, n = i.length; e &lt; n; e++) s = s.concat(i[e].controller.getAllParsedValues(t));\r\n          t._cache.$bar = lt(s.sort(((t, e) =&gt; t - e)))\r\n        }\r\n        return t._cache.$bar\r\n      }(e, t.type);\r\n    let s, n, o, a, r = e._length;\r\n    const l = () =&gt; {\r\n      32767 !== o &amp;&amp; -32768 !== o &amp;&amp; (k(a) &amp;&amp; (r = Math.min(r, Math.abs(o - a) || r)), a = o)\r\n    };\r\n    for (s = 0, n = i.length; s &lt; n; ++s) o = e.getPixelForValue(i[s]), l();\r\n    for (a = void 0, s = 0, n = e.ticks.length; s &lt; n; ++s) o = e.getPixelForTick(s), l();\r\n    return r\r\n  }\r\n\r\n  function zn(t, e, i, s) {\r\n    return n(t) ? function(t, e, i, s) {\r\n      const n = i.parse(t[0], s),\r\n        o = i.parse(t[1], s),\r\n        a = Math.min(n, o),\r\n        r = Math.max(n, o);\r\n      let l = a,\r\n        h = r;\r\n      Math.abs(a) &gt; Math.abs(r) &amp;&amp; (l = r, h = a), e[i.axis] = h, e._custom = {\r\n        barStart: l,\r\n        barEnd: h,\r\n        start: n,\r\n        end: o,\r\n        min: a,\r\n        max: r\r\n      }\r\n    }(t, e, i, s) : e[i.axis] = i.parse(t, s), e\r\n  }\r\n\r\n  function Fn(t, e, i, s) {\r\n    const n = t.iScale,\r\n      o = t.vScale,\r\n      a = n.getLabels(),\r\n      r = n === o,\r\n      l = [];\r\n    let h, c, d, u;\r\n    for (h = i, c = i + s; h &lt; c; ++h) u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(zn(u, d, o, h));\r\n    return l\r\n  }\r\n\r\n  function Vn(t) {\r\n    return t &amp;&amp; void 0 !== t.barStart &amp;&amp; void 0 !== t.barEnd\r\n  }\r\n\r\n  function Bn(t, e, i, s) {\r\n    let n = e.borderSkipped;\r\n    const o = {};\r\n    if (!n) return void(t.borderSkipped = o);\r\n    if (!0 === n) return void(t.borderSkipped = {\r\n      top: !0,\r\n      right: !0,\r\n      bottom: !0,\r\n      left: !0\r\n    });\r\n    const {\r\n      start: a,\r\n      end: r,\r\n      reverse: l,\r\n      top: h,\r\n      bottom: c\r\n    } = function(t) {\r\n      let e, i, s, n, o;\r\n      return t.horizontal ? (e = t.base &gt; t.x, i = &quot;left&quot;, s = &quot;right&quot;) : (e = t.base &lt; t.y, i = &quot;bottom&quot;, s = &quot;top&quot;), e ? (n = &quot;end&quot;, o = &quot;start&quot;) : (n = &quot;start&quot;, o = &quot;end&quot;), {\r\n        start: i,\r\n        end: s,\r\n        reverse: e,\r\n        top: n,\r\n        bottom: o\r\n      }\r\n    }(t);\r\n    &quot;middle&quot; === n &amp;&amp; i &amp;&amp; (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Wn(c, a, r, l)] = !0, n = h)), o[Wn(n, a, r, l)] = !0, t.borderSkipped = o\r\n  }\r\n\r\n  function Wn(t, e, i, s) {\r\n    var n, o, a;\r\n    return s ? (a = i, t = Nn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Nn(t, e, i), t\r\n  }\r\n\r\n  function Nn(t, e, i) {\r\n    return &quot;start&quot; === t ? e : &quot;end&quot; === t ? i : t\r\n  }\r\n\r\n  function Hn(t, {\r\n    inflateAmount: e\r\n  }, i) {\r\n    t.inflateAmount = &quot;auto&quot; === e ? 1 === i ? .33 : 0 : e\r\n  }\r\n  class jn extends Ns {\r\n    static id = &quot;doughnut&quot;;\r\n    static defaults = {\r\n      datasetElementType: !1,\r\n      dataElementType: &quot;arc&quot;,\r\n      animation: {\r\n        animateRotate: !0,\r\n        animateScale: !1\r\n      },\r\n      animations: {\r\n        numbers: {\r\n          type: &quot;number&quot;,\r\n          properties: [&quot;circumference&quot;, &quot;endAngle&quot;, &quot;innerRadius&quot;, &quot;outerRadius&quot;, &quot;startAngle&quot;, &quot;x&quot;, &quot;y&quot;, &quot;offset&quot;, &quot;borderWidth&quot;, &quot;spacing&quot;]\r\n        }\r\n      },\r\n      cutout: &quot;50%&quot;,\r\n      rotation: 0,\r\n      circumference: 360,\r\n      radius: &quot;100%&quot;,\r\n      spacing: 0,\r\n      indexAxis: &quot;r&quot;\r\n    };\r\n    static descriptors = {\r\n      _scriptable: t =&gt; &quot;spacing&quot; !== t,\r\n      _indexable: t =&gt; &quot;spacing&quot; !== t &amp;&amp; !t.startsWith(&quot;borderDash&quot;) &amp;&amp; !t.startsWith(&quot;hoverBorderDash&quot;)\r\n    };\r\n    static overrides = {\r\n      aspectRatio: 1,\r\n      plugins: {\r\n        legend: {\r\n          labels: {\r\n            generateLabels(t) {\r\n              const e = t.data;\r\n              if (e.labels.length &amp;&amp; e.datasets.length) {\r\n                const {\r\n                  labels: {\r\n                    pointStyle: i,\r\n                    color: s\r\n                  }\r\n                } = t.legend.options;\r\n                return e.labels.map(((e, n) =&gt; {\r\n                  const o = t.getDatasetMeta(0).controller.getStyle(n);\r\n                  return {\r\n                    text: e,\r\n                    fillStyle: o.backgroundColor,\r\n                    strokeStyle: o.borderColor,\r\n                    fontColor: s,\r\n                    lineWidth: o.borderWidth,\r\n                    pointStyle: i,\r\n                    hidden: !t.getDataVisibility(n),\r\n                    index: n\r\n                  }\r\n                }))\r\n              }\r\n              return []\r\n            }\r\n          },\r\n          onClick(t, e, i) {\r\n            i.chart.toggleDataVisibility(e.index), i.chart.update()\r\n          }\r\n        }\r\n      }\r\n    };\r\n    constructor(t, e) {\r\n      super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0\r\n    }\r\n    linkScales() {}\r\n    parse(t, e) {\r\n      const i = this.getDataset().data,\r\n        s = this._cachedMeta;\r\n      if (!1 === this._parsing) s._parsed = i;\r\n      else {\r\n        let n, a, r = t =&gt; +i[t];\r\n        if (o(i[t])) {\r\n          const {\r\n            key: t = &quot;value&quot;\r\n          } = this._parsing;\r\n          r = e =&gt; +M(i[e], t)\r\n        }\r\n        for (n = t, a = t + e; n &lt; a; ++n) s._parsed[n] = r(n)\r\n      }\r\n    }\r\n    _getRotation() {\r\n      return $(this.options.rotation - 90)\r\n    }\r\n    _getCircumference() {\r\n      return $(this.options.circumference)\r\n    }\r\n    _getRotationExtents() {\r\n      let t = O,\r\n        e = -O;\r\n      for (let i = 0; i &lt; this.chart.data.datasets.length; ++i)\r\n        if (this.chart.isDatasetVisible(i) &amp;&amp; this.chart.getDatasetMeta(i).type === this._type) {\r\n          const s = this.chart.getDatasetMeta(i).controller,\r\n            n = s._getRotation(),\r\n            o = s._getCircumference();\r\n          t = Math.min(t, n), e = Math.max(e, n + o)\r\n        } return {\r\n        rotation: t,\r\n        circumference: e - t\r\n      }\r\n    }\r\n    update(t) {\r\n      const e = this.chart,\r\n        {\r\n          chartArea: i\r\n        } = e,\r\n        s = this._cachedMeta,\r\n        n = s.data,\r\n        o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing,\r\n        a = Math.max((Math.min(i.width, i.height) - o) \/ 2, 0),\r\n        r = Math.min(h(this.options.cutout, a), 1),\r\n        l = this._getRingWeight(this.index),\r\n        {\r\n          circumference: d,\r\n          rotation: u\r\n        } = this._getRotationExtents(),\r\n        {\r\n          ratioX: f,\r\n          ratioY: g,\r\n          offsetX: p,\r\n          offsetY: m\r\n        } = function(t, e, i) {\r\n          let s = 1,\r\n            n = 1,\r\n            o = 0,\r\n            a = 0;\r\n          if (e &lt; O) {\r\n            const r = t,\r\n              l = r + e,\r\n              h = Math.cos(r),\r\n              c = Math.sin(r),\r\n              d = Math.cos(l),\r\n              u = Math.sin(l),\r\n              f = (t, e, s) =&gt; Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i),\r\n              g = (t, e, s) =&gt; Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i),\r\n              p = f(0, h, d),\r\n              m = f(E, c, u),\r\n              x = g(C, h, d),\r\n              b = g(C + E, c, u);\r\n            s = (p - x) \/ 2, n = (m - b) \/ 2, o = -(p + x) \/ 2, a = -(m + b) \/ 2\r\n          }\r\n          return {\r\n            ratioX: s,\r\n            ratioY: n,\r\n            offsetX: o,\r\n            offsetY: a\r\n          }\r\n        }(u, d, r),\r\n        x = (i.width - o) \/ f,\r\n        b = (i.height - o) \/ g,\r\n        _ = Math.max(Math.min(x, b) \/ 2, 0),\r\n        y = c(this.options.radius, _),\r\n        v = (y - Math.max(y * r, 0)) \/ this._getVisibleDatasetWeightTotal();\r\n      this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t)\r\n    }\r\n    _circumference(t, e) {\r\n      const i = this.options,\r\n        s = this._cachedMeta,\r\n        n = this._getCircumference();\r\n      return e &amp;&amp; i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n \/ O)\r\n    }\r\n    updateElements(t, e, i, s) {\r\n      const n = &quot;reset&quot; === s,\r\n        o = this.chart,\r\n        a = o.chartArea,\r\n        r = o.options.animation,\r\n        l = (a.left + a.right) \/ 2,\r\n        h = (a.top + a.bottom) \/ 2,\r\n        c = n &amp;&amp; r.animateScale,\r\n        d = c ? 0 : this.innerRadius,\r\n        u = c ? 0 : this.outerRadius,\r\n        {\r\n          sharedOptions: f,\r\n          includeOptions: g\r\n        } = this._getSharedOptions(e, s);\r\n      let p, m = this._getRotation();\r\n      for (p = 0; p &lt; e; ++p) m += this._circumference(p, n);\r\n      for (p = e; p &lt; e + i; ++p) {\r\n        const e = this._circumference(p, n),\r\n          i = t[p],\r\n          o = {\r\n            x: l + this.offsetX,\r\n            y: h + this.offsetY,\r\n            startAngle: m,\r\n            endAngle: m + e,\r\n            circumference: e,\r\n            outerRadius: u,\r\n            innerRadius: d\r\n          };\r\n        g &amp;&amp; (o.options = f || this.resolveDataElementOptions(p, i.active ? &quot;active&quot; : s)), m += e, this.updateElement(i, p, o, s)\r\n      }\r\n    }\r\n    calculateTotal() {\r\n      const t = this._cachedMeta,\r\n        e = t.data;\r\n      let i, s = 0;\r\n      for (i = 0; i &lt; e.length; i++) {\r\n        const n = t._parsed[i];\r\n        null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n))\r\n      }\r\n      return s\r\n    }\r\n    calculateCircumference(t) {\r\n      const e = this._cachedMeta.total;\r\n      return e &gt; 0 &amp;&amp; !isNaN(t) ? O * (Math.abs(t) \/ e) : 0\r\n    }\r\n    getLabelAndValue(t) {\r\n      const e = this._cachedMeta,\r\n        i = this.chart,\r\n        s = i.data.labels || [],\r\n        n = ne(e._parsed[t], i.options.locale);\r\n      return {\r\n        label: s[t] || &quot;&quot;,\r\n        value: n\r\n      }\r\n    }\r\n    getMaxBorderWidth(t) {\r\n      let e = 0;\r\n      const i = this.chart;\r\n      let s, n, o, a, r;\r\n      if (!t)\r\n        for (s = 0, n = i.data.datasets.length; s &lt; n; ++s)\r\n          if (i.isDatasetVisible(s)) {\r\n            o = i.getDatasetMeta(s), t = o.data, a = o.controller;\r\n            break\r\n          } if (!t) return 0;\r\n      for (s = 0, n = t.length; s &lt; n; ++s) r = a.resolveDataElementOptions(s), &quot;inner&quot; !== r.borderAlign &amp;&amp; (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));\r\n      return e\r\n    }\r\n    getMaxOffset(t) {\r\n      let e = 0;\r\n      for (let i = 0, s = t.length; i &lt; s; ++i) {\r\n        const t = this.resolveDataElementOptions(i);\r\n        e = Math.max(e, t.offset || 0, t.hoverOffset || 0)\r\n      }\r\n      return e\r\n    }\r\n    _getRingWeightOffset(t) {\r\n      let e = 0;\r\n      for (let i = 0; i &lt; t; ++i) this.chart.isDatasetVisible(i) &amp;&amp; (e += this._getRingWeight(i));\r\n      return e\r\n    }\r\n    _getRingWeight(t) {\r\n      return Math.max(l(this.chart.data.datasets[t].weight, 1), 0)\r\n    }\r\n    _getVisibleDatasetWeightTotal() {\r\n      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1\r\n    }\r\n  }\r\n  class $n extends Ns {\r\n    static id = &quot;polarArea&quot;;\r\n    static defaults = {\r\n      dataElementType: &quot;arc&quot;,\r\n      animation: {\r\n        animateRotate: !0,\r\n        animateScale: !0\r\n      },\r\n      animations: {\r\n        numbers: {\r\n          type: &quot;number&quot;,\r\n          properties: [&quot;x&quot;, &quot;y&quot;, &quot;startAngle&quot;, &quot;endAngle&quot;, &quot;innerRadius&quot;, &quot;outerRadius&quot;]\r\n        }\r\n      },\r\n      indexAxis: &quot;r&quot;,\r\n      startAngle: 0\r\n    };\r\n    static overrides = {\r\n      aspectRatio: 1,\r\n      plugins: {\r\n        legend: {\r\n          labels: {\r\n            generateLabels(t) {\r\n              const e = t.data;\r\n              if (e.labels.length &amp;&amp; e.datasets.length) {\r\n                const {\r\n                  labels: {\r\n                    pointStyle: i,\r\n                    color: s\r\n                  }\r\n                } = t.legend.options;\r\n                return e.labels.map(((e, n) =&gt; {\r\n                  const o = t.getDatasetMeta(0).controller.getStyle(n);\r\n                  return {\r\n                    text: e,\r\n                    fillStyle: o.backgroundColor,\r\n                    strokeStyle: o.borderColor,\r\n                    fontColor: s,\r\n                    lineWidth: o.borderWidth,\r\n                    pointStyle: i,\r\n                    hidden: !t.getDataVisibility(n),\r\n                    index: n\r\n                  }\r\n                }))\r\n              }\r\n              return []\r\n            }\r\n          },\r\n          onClick(t, e, i) {\r\n            i.chart.toggleDataVisibility(e.index), i.chart.update()\r\n          }\r\n        }\r\n      },\r\n      scales: {\r\n        r: {\r\n          type: &quot;radialLinear&quot;,\r\n          angleLines: {\r\n            display: !1\r\n          },\r\n          beginAtZero: !0,\r\n          grid: {\r\n            circular: !0\r\n          },\r\n          pointLabels: {\r\n            display: !1\r\n          },\r\n          startAngle: 0\r\n        }\r\n      }\r\n    };\r\n    constructor(t, e) {\r\n      super(t, e), this.innerRadius = void 0, this.outerRadius = void 0\r\n    }\r\n    getLabelAndValue(t) {\r\n      const e = this._cachedMeta,\r\n        i = this.chart,\r\n        s = i.data.labels || [],\r\n        n = ne(e._parsed[t].r, i.options.locale);\r\n      return {\r\n        label: s[t] || &quot;&quot;,\r\n        value: n\r\n      }\r\n    }\r\n    parseObjectData(t, e, i, s) {\r\n      return ii.bind(this)(t, e, i, s)\r\n    }\r\n    update(t) {\r\n      const e = this._cachedMeta.data;\r\n      this._updateRadius(), this.updateElements(e, 0, e.length, t)\r\n    }\r\n    getMinMax() {\r\n      const t = this._cachedMeta,\r\n        e = {\r\n          min: Number.POSITIVE_INFINITY,\r\n          max: Number.NEGATIVE_INFINITY\r\n        };\r\n      return t.data.forEach(((t, i) =&gt; {\r\n        const s = this.getParsed(i).r;\r\n        !isNaN(s) &amp;&amp; this.chart.getDataVisibility(i) &amp;&amp; (s &lt; e.min &amp;&amp; (e.min = s), s &gt; e.max &amp;&amp; (e.max = s))\r\n      })), e\r\n    }\r\n    _updateRadius() {\r\n      const t = this.chart,\r\n        e = t.chartArea,\r\n        i = t.options,\r\n        s = Math.min(e.right - e.left, e.bottom - e.top),\r\n        n = Math.max(s \/ 2, 0),\r\n        o = (n - Math.max(i.cutoutPercentage ? n \/ 100 * i.cutoutPercentage : 1, 0)) \/ t.getVisibleDatasetCount();\r\n      this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o\r\n    }\r\n    updateElements(t, e, i, s) {\r\n      const n = &quot;reset&quot; === s,\r\n        o = this.chart,\r\n        a = o.options.animation,\r\n        r = this._cachedMeta.rScale,\r\n        l = r.xCenter,\r\n        h = r.yCenter,\r\n        c = r.getIndexAngle(0) - .5 * C;\r\n      let d, u = c;\r\n      const f = 360 \/ this.countVisibleElements();\r\n      for (d = 0; d &lt; e; ++d) u += this._computeAngle(d, s, f);\r\n      for (d = e; d &lt; e + i; d++) {\r\n        const e = t[d];\r\n        let i = u,\r\n          g = u + this._computeAngle(d, s, f),\r\n          p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;\r\n        u = g, n &amp;&amp; (a.animateScale &amp;&amp; (p = 0), a.animateRotate &amp;&amp; (i = g = c));\r\n        const m = {\r\n          x: l,\r\n          y: h,\r\n          innerRadius: 0,\r\n          outerRadius: p,\r\n          startAngle: i,\r\n          endAngle: g,\r\n          options: this.resolveDataElementOptions(d, e.active ? &quot;active&quot; : s)\r\n        };\r\n        this.updateElement(e, d, m, s)\r\n      }\r\n    }\r\n    countVisibleElements() {\r\n      const t = this._cachedMeta;\r\n      let e = 0;\r\n      return t.data.forEach(((t, i) =&gt; {\r\n        !isNaN(this.getParsed(i).r) &amp;&amp; this.chart.getDataVisibility(i) &amp;&amp; e++\r\n      })), e\r\n    }\r\n    _computeAngle(t, e, i) {\r\n      return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0\r\n    }\r\n  }\r\n  var Yn = Object.freeze({\r\n    __proto__: null,\r\n    BarController: class extends Ns {\r\n      static id = &quot;bar&quot;;\r\n      static defaults = {\r\n        datasetElementType: !1,\r\n        dataElementType: &quot;bar&quot;,\r\n        categoryPercentage: .8,\r\n        barPercentage: .9,\r\n        grouped: !0,\r\n        animations: {\r\n          numbers: {\r\n            type: &quot;number&quot;,\r\n            properties: [&quot;x&quot;, &quot;y&quot;, &quot;base&quot;, &quot;width&quot;, &quot;height&quot;]\r\n          }\r\n        }\r\n      };\r\n      static overrides = {\r\n        scales: {\r\n          _index_: {\r\n            type: &quot;category&quot;,\r\n            offset: !0,\r\n            grid: {\r\n              offset: !0\r\n            }\r\n          },\r\n          _value_: {\r\n            type: &quot;linear&quot;,\r\n            beginAtZero: !0\r\n          }\r\n        }\r\n      };\r\n      parsePrimitiveData(t, e, i, s) {\r\n        return Fn(t, e, i, s)\r\n      }\r\n      parseArrayData(t, e, i, s) {\r\n        return Fn(t, e, i, s)\r\n      }\r\n      parseObjectData(t, e, i, s) {\r\n        const {\r\n          iScale: n,\r\n          vScale: o\r\n        } = t, {\r\n          xAxisKey: a = &quot;x&quot;,\r\n          yAxisKey: r = &quot;y&quot;\r\n        } = this._parsing, l = &quot;x&quot; === n.axis ? a : r, h = &quot;x&quot; === o.axis ? a : r, c = [];\r\n        let d, u, f, g;\r\n        for (d = i, u = i + s; d &lt; u; ++d) g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(zn(M(g, h), f, o, d));\r\n        return c\r\n      }\r\n      updateRangeFromParsed(t, e, i, s) {\r\n        super.updateRangeFromParsed(t, e, i, s);\r\n        const n = i._custom;\r\n        n &amp;&amp; e === this._cachedMeta.vScale &amp;&amp; (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max))\r\n      }\r\n      getMaxOverflow() {\r\n        return 0\r\n      }\r\n      getLabelAndValue(t) {\r\n        const e = this._cachedMeta,\r\n          {\r\n            iScale: i,\r\n            vScale: s\r\n          } = e,\r\n          n = this.getParsed(t),\r\n          o = n._custom,\r\n          a = Vn(o) ? &quot;[&quot; + o.start + &quot;, &quot; + o.end + &quot;]&quot; : &quot;&quot; + s.getLabelForValue(n[s.axis]);\r\n        return {\r\n          label: &quot;&quot; + i.getLabelForValue(n[i.axis]),\r\n          value: a\r\n        }\r\n      }\r\n      initialize() {\r\n        this.enableOptionSharing = !0, super.initialize();\r\n        this._cachedMeta.stack = this.getDataset().stack\r\n      }\r\n      update(t) {\r\n        const e = this._cachedMeta;\r\n        this.updateElements(e.data, 0, e.data.length, t)\r\n      }\r\n      updateElements(t, e, i, n) {\r\n        const o = &quot;reset&quot; === n,\r\n          {\r\n            index: a,\r\n            _cachedMeta: {\r\n              vScale: r\r\n            }\r\n          } = this,\r\n          l = r.getBasePixel(),\r\n          h = r.isHorizontal(),\r\n          c = this._getRuler(),\r\n          {\r\n            sharedOptions: d,\r\n            includeOptions: u\r\n          } = this._getSharedOptions(e, n);\r\n        for (let f = e; f &lt; e + i; f++) {\r\n          const e = this.getParsed(f),\r\n            i = o || s(e[r.axis]) ? {\r\n              base: l,\r\n              head: l\r\n            } : this._calculateBarValuePixels(f),\r\n            g = this._calculateBarIndexPixels(f, c),\r\n            p = (e._stacks || {})[r.axis],\r\n            m = {\r\n              horizontal: h,\r\n              base: i.base,\r\n              enableBorderRadius: !p || Vn(e._custom) || a === p._top || a === p._bottom,\r\n              x: h ? i.head : g.center,\r\n              y: h ? g.center : i.head,\r\n              height: h ? g.size : Math.abs(i.size),\r\n              width: h ? Math.abs(i.size) : g.size\r\n            };\r\n          u &amp;&amp; (m.options = d || this.resolveDataElementOptions(f, t[f].active ? &quot;active&quot; : n));\r\n          const x = m.options || t[f].options;\r\n          Bn(m, x, p, a), Hn(m, x, c.ratio), this.updateElement(t[f], f, m, n)\r\n        }\r\n      }\r\n      _getStacks(t, e) {\r\n        const {\r\n          iScale: i\r\n        } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t =&gt; t.controller.options.grouped)), o = i.options.stacked, a = [], r = t =&gt; {\r\n          const i = t.controller.getParsed(e),\r\n            n = i &amp;&amp; i[t.vScale.axis];\r\n          if (s(n) || isNaN(n)) return !0\r\n        };\r\n        for (const i of n)\r\n          if ((void 0 === e || !r(i)) &amp;&amp; ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o &amp;&amp; void 0 === i.stack) &amp;&amp; a.push(i.stack), i.index === t)) break;\r\n        return a.length || a.push(void 0), a\r\n      }\r\n      _getStackCount(t) {\r\n        return this._getStacks(void 0, t).length\r\n      }\r\n      _getStackIndex(t, e, i) {\r\n        const s = this._getStacks(t, i),\r\n          n = void 0 !== e ? s.indexOf(e) : -1;\r\n        return -1 === n ? s.length - 1 : n\r\n      }\r\n      _getRuler() {\r\n        const t = this.options,\r\n          e = this._cachedMeta,\r\n          i = e.iScale,\r\n          s = [];\r\n        let n, o;\r\n        for (n = 0, o = e.data.length; n &lt; o; ++n) s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));\r\n        const a = t.barThickness;\r\n        return {\r\n          min: a || In(e),\r\n          pixels: s,\r\n          start: i._startPixel,\r\n          end: i._endPixel,\r\n          stackCount: this._getStackCount(),\r\n          scale: i,\r\n          grouped: t.grouped,\r\n          ratio: a ? 1 : t.categoryPercentage * t.barPercentage\r\n        }\r\n      }\r\n      _calculateBarValuePixels(t) {\r\n        const {\r\n          _cachedMeta: {\r\n            vScale: e,\r\n            _stacked: i,\r\n            index: n\r\n          },\r\n          options: {\r\n            base: o,\r\n            minBarLength: a\r\n          }\r\n        } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Vn(h);\r\n        let d, u, f = l[e.axis],\r\n          g = 0,\r\n          p = i ? this.applyStack(e, l, i) : f;\r\n        p !== f &amp;&amp; (g = p - f, p = f), c &amp;&amp; (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f &amp;&amp; F(f) !== F(h.barEnd) &amp;&amp; (g = 0), g += f);\r\n        const m = s(o) || c ? g : o;\r\n        let x = e.getPixelForValue(m);\r\n        if (d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : x, u = d - x, Math.abs(u) &lt; a) {\r\n          u = function(t, e, i) {\r\n            return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min &gt;= i ? 1 : -1)\r\n          }(u, e, r) * a, f === r &amp;&amp; (x -= u \/ 2);\r\n          const t = e.getPixelForDecimal(0),\r\n            s = e.getPixelForDecimal(1),\r\n            o = Math.min(t, s),\r\n            h = Math.max(t, s);\r\n          x = Math.max(Math.min(x, h), o), d = x + u, i &amp;&amp; !c &amp;&amp; (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(x))\r\n        }\r\n        if (x === e.getPixelForValue(r)) {\r\n          const t = F(u) * e.getLineWidthForValue(r) \/ 2;\r\n          x += t, u -= t\r\n        }\r\n        return {\r\n          size: u,\r\n          base: x,\r\n          head: d,\r\n          center: d + u \/ 2\r\n        }\r\n      }\r\n      _calculateBarIndexPixels(t, e) {\r\n        const i = e.scale,\r\n          n = this.options,\r\n          o = n.skipNull,\r\n          a = l(n.maxBarThickness, 1 \/ 0);\r\n        let r, h;\r\n        if (e.grouped) {\r\n          const i = o ? this._getStackCount(t) : e.stackCount,\r\n            l = &quot;flex&quot; === n.barThickness ? function(t, e, i, s) {\r\n              const n = e.pixels,\r\n                o = n[t];\r\n              let a = t &gt; 0 ? n[t - 1] : null,\r\n                r = t &lt; n.length - 1 ? n[t + 1] : null;\r\n              const l = i.categoryPercentage;\r\n              null === a &amp;&amp; (a = o - (null === r ? e.end - e.start : r - o)), null === r &amp;&amp; (r = o + o - a);\r\n              const h = o - (o - Math.min(a, r)) \/ 2 * l;\r\n              return {\r\n                chunk: Math.abs(r - a) \/ 2 * l \/ s,\r\n                ratio: i.barPercentage,\r\n                start: h\r\n              }\r\n            }(t, e, n, i) : function(t, e, i, n) {\r\n              const o = i.barThickness;\r\n              let a, r;\r\n              return s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), {\r\n                chunk: a \/ n,\r\n                ratio: r,\r\n                start: e.pixels[t] - a \/ 2\r\n              }\r\n            }(t, e, n, i),\r\n            c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\r\n          r = l.start + l.chunk * c + l.chunk \/ 2, h = Math.min(a, l.chunk * l.ratio)\r\n        } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio);\r\n        return {\r\n          base: r - h \/ 2,\r\n          head: r + h \/ 2,\r\n          center: r,\r\n          size: h\r\n        }\r\n      }\r\n      draw() {\r\n        const t = this._cachedMeta,\r\n          e = t.vScale,\r\n          i = t.data,\r\n          s = i.length;\r\n        let n = 0;\r\n        for (; n &lt; s; ++n) null === this.getParsed(n)[e.axis] || i[n].hidden || i[n].draw(this._ctx)\r\n      }\r\n    },\r\n    BubbleController: class extends Ns {\r\n      static id = &quot;bubble&quot;;\r\n      static defaults = {\r\n        datasetElementType: !1,\r\n        dataElementType: &quot;point&quot;,\r\n        animations: {\r\n          numbers: {\r\n            type: &quot;number&quot;,\r\n            properties: [&quot;x&quot;, &quot;y&quot;, &quot;borderWidth&quot;, &quot;radius&quot;]\r\n          }\r\n        }\r\n      };\r\n      static overrides = {\r\n        scales: {\r\n          x: {\r\n            type: &quot;linear&quot;\r\n          },\r\n          y: {\r\n            type: &quot;linear&quot;\r\n          }\r\n        }\r\n      };\r\n      initialize() {\r\n        this.enableOptionSharing = !0, super.initialize()\r\n      }\r\n      parsePrimitiveData(t, e, i, s) {\r\n        const n = super.parsePrimitiveData(t, e, i, s);\r\n        for (let t = 0; t &lt; n.length; t++) n[t]._custom = this.resolveDataElementOptions(t + i).radius;\r\n        return n\r\n      }\r\n      parseArrayData(t, e, i, s) {\r\n        const n = super.parseArrayData(t, e, i, s);\r\n        for (let t = 0; t &lt; n.length; t++) {\r\n          const s = e[i + t];\r\n          n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius)\r\n        }\r\n        return n\r\n      }\r\n      parseObjectData(t, e, i, s) {\r\n        const n = super.parseObjectData(t, e, i, s);\r\n        for (let t = 0; t &lt; n.length; t++) {\r\n          const s = e[i + t];\r\n          n[t]._custom = l(s &amp;&amp; s.r &amp;&amp; +s.r, this.resolveDataElementOptions(t + i).radius)\r\n        }\r\n        return n\r\n      }\r\n      getMaxOverflow() {\r\n        const t = this._cachedMeta.data;\r\n        let e = 0;\r\n        for (let i = t.length - 1; i &gt;= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) \/ 2);\r\n        return e &gt; 0 &amp;&amp; e\r\n      }\r\n      getLabelAndValue(t) {\r\n        const e = this._cachedMeta,\r\n          i = this.chart.data.labels || [],\r\n          {\r\n            xScale: s,\r\n            yScale: n\r\n          } = e,\r\n          o = this.getParsed(t),\r\n          a = s.getLabelForValue(o.x),\r\n          r = n.getLabelForValue(o.y),\r\n          l = o._custom;\r\n        return {\r\n          label: i[t] || &quot;&quot;,\r\n          value: &quot;(&quot; + a + &quot;, &quot; + r + (l ? &quot;, &quot; + l : &quot;&quot;) + &quot;)&quot;\r\n        }\r\n      }\r\n      update(t) {\r\n        const e = this._cachedMeta.data;\r\n        this.updateElements(e, 0, e.length, t)\r\n      }\r\n      updateElements(t, e, i, s) {\r\n        const n = &quot;reset&quot; === s,\r\n          {\r\n            iScale: o,\r\n            vScale: a\r\n          } = this._cachedMeta,\r\n          {\r\n            sharedOptions: r,\r\n            includeOptions: l\r\n          } = this._getSharedOptions(e, s),\r\n          h = o.axis,\r\n          c = a.axis;\r\n        for (let d = e; d &lt; e + i; d++) {\r\n          const e = t[d],\r\n            i = !n &amp;&amp; this.getParsed(d),\r\n            u = {},\r\n            f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]),\r\n            g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);\r\n          u.skip = isNaN(f) || isNaN(g), l &amp;&amp; (u.options = r || this.resolveDataElementOptions(d, e.active ? &quot;active&quot; : s), n &amp;&amp; (u.options.radius = 0)), this.updateElement(e, d, u, s)\r\n        }\r\n      }\r\n      resolveDataElementOptions(t, e) {\r\n        const i = this.getParsed(t);\r\n        let s = super.resolveDataElementOptions(t, e);\r\n        s.$shared &amp;&amp; (s = Object.assign({}, s, {\r\n          $shared: !1\r\n        }));\r\n        const n = s.radius;\r\n        return &quot;active&quot; !== e &amp;&amp; (s.radius = 0), s.radius += l(i &amp;&amp; i._custom, n), s\r\n      }\r\n    },\r\n    DoughnutController: jn,\r\n    LineController: class extends Ns {\r\n      static id = &quot;line&quot;;\r\n      static defaults = {\r\n        datasetElementType: &quot;line&quot;,\r\n        dataElementType: &quot;point&quot;,\r\n        showLine: !0,\r\n        spanGaps: !1\r\n      };\r\n      static overrides = {\r\n        scales: {\r\n          _index_: {\r\n            type: &quot;category&quot;\r\n          },\r\n          _value_: {\r\n            type: &quot;linear&quot;\r\n          }\r\n        }\r\n      };\r\n      initialize() {\r\n        this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()\r\n      }\r\n      update(t) {\r\n        const e = this._cachedMeta,\r\n          {\r\n            dataset: i,\r\n            data: s = [],\r\n            _dataset: n\r\n          } = e,\r\n          o = this.chart._animationsDisabled;\r\n        let {\r\n          start: a,\r\n          count: r\r\n        } = pt(e, s, o);\r\n        this._drawStart = a, this._drawCount = r, mt(e) &amp;&amp; (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;\r\n        const l = this.resolveDatasetElementOptions(t);\r\n        this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {\r\n          animated: !o,\r\n          options: l\r\n        }, t), this.updateElements(s, a, r, t)\r\n      }\r\n      updateElements(t, e, i, n) {\r\n        const o = &quot;reset&quot; === n,\r\n          {\r\n            iScale: a,\r\n            vScale: r,\r\n            _stacked: l,\r\n            _dataset: h\r\n          } = this._cachedMeta,\r\n          {\r\n            sharedOptions: c,\r\n            includeOptions: d\r\n          } = this._getSharedOptions(e, n),\r\n          u = a.axis,\r\n          f = r.axis,\r\n          {\r\n            spanGaps: g,\r\n            segment: p\r\n          } = this.options,\r\n          m = N(g) ? g : Number.POSITIVE_INFINITY,\r\n          x = this.chart._animationsDisabled || o || &quot;none&quot; === n,\r\n          b = e + i,\r\n          _ = t.length;\r\n        let y = e &gt; 0 &amp;&amp; this.getParsed(e - 1);\r\n        for (let i = 0; i &lt; _; ++i) {\r\n          const g = t[i],\r\n            _ = x ? g : {};\r\n          if (i &lt; e || i &gt;= b) {\r\n            _.skip = !0;\r\n            continue\r\n          }\r\n          const v = this.getParsed(i),\r\n            M = s(v[f]),\r\n            w = _[u] = a.getPixelForValue(v[u], i),\r\n            k = _[f] = o || M ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, v, l) : v[f], i);\r\n          _.skip = isNaN(w) || isNaN(k) || M, _.stop = i &gt; 0 &amp;&amp; Math.abs(v[u] - y[u]) &gt; m, p &amp;&amp; (_.parsed = v, _.raw = h.data[i]), d &amp;&amp; (_.options = c || this.resolveDataElementOptions(i, g.active ? &quot;active&quot; : n)), x || this.updateElement(g, i, _, n), y = v\r\n        }\r\n      }\r\n      getMaxOverflow() {\r\n        const t = this._cachedMeta,\r\n          e = t.dataset,\r\n          i = e.options &amp;&amp; e.options.borderWidth || 0,\r\n          s = t.data || [];\r\n        if (!s.length) return i;\r\n        const n = s[0].size(this.resolveDataElementOptions(0)),\r\n          o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));\r\n        return Math.max(i, n, o) \/ 2\r\n      }\r\n      draw() {\r\n        const t = this._cachedMeta;\r\n        t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()\r\n      }\r\n    },\r\n    PieController: class extends jn {\r\n      static id = &quot;pie&quot;;\r\n      static defaults = {\r\n        cutout: 0,\r\n        rotation: 0,\r\n        circumference: 360,\r\n        radius: &quot;100%&quot;\r\n      }\r\n    },\r\n    PolarAreaController: $n,\r\n    RadarController: class extends Ns {\r\n      static id = &quot;radar&quot;;\r\n      static defaults = {\r\n        datasetElementType: &quot;line&quot;,\r\n        dataElementType: &quot;point&quot;,\r\n        indexAxis: &quot;r&quot;,\r\n        showLine: !0,\r\n        elements: {\r\n          line: {\r\n            fill: &quot;start&quot;\r\n          }\r\n        }\r\n      };\r\n      static overrides = {\r\n        aspectRatio: 1,\r\n        scales: {\r\n          r: {\r\n            type: &quot;radialLinear&quot;\r\n          }\r\n        }\r\n      };\r\n      getLabelAndValue(t) {\r\n        const e = this._cachedMeta.vScale,\r\n          i = this.getParsed(t);\r\n        return {\r\n          label: e.getLabels()[t],\r\n          value: &quot;&quot; + e.getLabelForValue(i[e.axis])\r\n        }\r\n      }\r\n      parseObjectData(t, e, i, s) {\r\n        return ii.bind(this)(t, e, i, s)\r\n      }\r\n      update(t) {\r\n        const e = this._cachedMeta,\r\n          i = e.dataset,\r\n          s = e.data || [],\r\n          n = e.iScale.getLabels();\r\n        if (i.points = s, &quot;resize&quot; !== t) {\r\n          const e = this.resolveDatasetElementOptions(t);\r\n          this.options.showLine || (e.borderWidth = 0);\r\n          const o = {\r\n            _loop: !0,\r\n            _fullLoop: n.length === s.length,\r\n            options: e\r\n          };\r\n          this.updateElement(i, void 0, o, t)\r\n        }\r\n        this.updateElements(s, 0, s.length, t)\r\n      }\r\n      updateElements(t, e, i, s) {\r\n        const n = this._cachedMeta.rScale,\r\n          o = &quot;reset&quot; === s;\r\n        for (let a = e; a &lt; e + i; a++) {\r\n          const e = t[a],\r\n            i = this.resolveDataElementOptions(a, e.active ? &quot;active&quot; : s),\r\n            r = n.getPointPositionForValue(a, this.getParsed(a).r),\r\n            l = o ? n.xCenter : r.x,\r\n            h = o ? n.yCenter : r.y,\r\n            c = {\r\n              x: l,\r\n              y: h,\r\n              angle: r.angle,\r\n              skip: isNaN(l) || isNaN(h),\r\n              options: i\r\n            };\r\n          this.updateElement(e, a, c, s)\r\n        }\r\n      }\r\n    },\r\n    ScatterController: class extends Ns {\r\n      static id = &quot;scatter&quot;;\r\n      static defaults = {\r\n        datasetElementType: !1,\r\n        dataElementType: &quot;point&quot;,\r\n        showLine: !1,\r\n        fill: !1\r\n      };\r\n      static overrides = {\r\n        interaction: {\r\n          mode: &quot;point&quot;\r\n        },\r\n        scales: {\r\n          x: {\r\n            type: &quot;linear&quot;\r\n          },\r\n          y: {\r\n            type: &quot;linear&quot;\r\n          }\r\n        }\r\n      };\r\n      getLabelAndValue(t) {\r\n        const e = this._cachedMeta,\r\n          i = this.chart.data.labels || [],\r\n          {\r\n            xScale: s,\r\n            yScale: n\r\n          } = e,\r\n          o = this.getParsed(t),\r\n          a = s.getLabelForValue(o.x),\r\n          r = n.getLabelForValue(o.y);\r\n        return {\r\n          label: i[t] || &quot;&quot;,\r\n          value: &quot;(&quot; + a + &quot;, &quot; + r + &quot;)&quot;\r\n        }\r\n      }\r\n      update(t) {\r\n        const e = this._cachedMeta,\r\n          {\r\n            data: i = []\r\n          } = e,\r\n          s = this.chart._animationsDisabled;\r\n        let {\r\n          start: n,\r\n          count: o\r\n        } = pt(e, i, s);\r\n        if (this._drawStart = n, this._drawCount = o, mt(e) &amp;&amp; (n = 0, o = i.length), this.options.showLine) {\r\n          this.datasetElementType || this.addElements();\r\n          const {\r\n            dataset: n,\r\n            _dataset: o\r\n          } = e;\r\n          n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;\r\n          const a = this.resolveDatasetElementOptions(t);\r\n          a.segment = this.options.segment, this.updateElement(n, void 0, {\r\n            animated: !s,\r\n            options: a\r\n          }, t)\r\n        } else this.datasetElementType &amp;&amp; (delete e.dataset, this.datasetElementType = !1);\r\n        this.updateElements(i, n, o, t)\r\n      }\r\n      addElements() {\r\n        const {\r\n          showLine: t\r\n        } = this.options;\r\n        !this.datasetElementType &amp;&amp; t &amp;&amp; (this.datasetElementType = this.chart.registry.getElement(&quot;line&quot;)), super.addElements()\r\n      }\r\n      updateElements(t, e, i, n) {\r\n        const o = &quot;reset&quot; === n,\r\n          {\r\n            iScale: a,\r\n            vScale: r,\r\n            _stacked: l,\r\n            _dataset: h\r\n          } = this._cachedMeta,\r\n          c = this.resolveDataElementOptions(e, n),\r\n          d = this.getSharedOptions(c),\r\n          u = this.includeOptions(n, d),\r\n          f = a.axis,\r\n          g = r.axis,\r\n          {\r\n            spanGaps: p,\r\n            segment: m\r\n          } = this.options,\r\n          x = N(p) ? p : Number.POSITIVE_INFINITY,\r\n          b = this.chart._animationsDisabled || o || &quot;none&quot; === n;\r\n        let _ = e &gt; 0 &amp;&amp; this.getParsed(e - 1);\r\n        for (let c = e; c &lt; e + i; ++c) {\r\n          const e = t[c],\r\n            i = this.getParsed(c),\r\n            p = b ? e : {},\r\n            y = s(i[g]),\r\n            v = p[f] = a.getPixelForValue(i[f], c),\r\n            M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c);\r\n          p.skip = isNaN(v) || isNaN(M) || y, p.stop = c &gt; 0 &amp;&amp; Math.abs(i[f] - _[f]) &gt; x, m &amp;&amp; (p.parsed = i, p.raw = h.data[c]), u &amp;&amp; (p.options = d || this.resolveDataElementOptions(c, e.active ? &quot;active&quot; : n)), b || this.updateElement(e, c, p, n), _ = i\r\n        }\r\n        this.updateSharedOptions(d, n, c)\r\n      }\r\n      getMaxOverflow() {\r\n        const t = this._cachedMeta,\r\n          e = t.data || [];\r\n        if (!this.options.showLine) {\r\n          let t = 0;\r\n          for (let i = e.length - 1; i &gt;= 0; --i) t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) \/ 2);\r\n          return t &gt; 0 &amp;&amp; t\r\n        }\r\n        const i = t.dataset,\r\n          s = i.options &amp;&amp; i.options.borderWidth || 0;\r\n        if (!e.length) return s;\r\n        const n = e[0].size(this.resolveDataElementOptions(0)),\r\n          o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\r\n        return Math.max(s, n, o) \/ 2\r\n      }\r\n    }\r\n  });\r\n\r\n  function Un(t, e, i, s) {\r\n    const n = vi(t.options.borderRadius, [&quot;outerStart&quot;, &quot;outerEnd&quot;, &quot;innerStart&quot;, &quot;innerEnd&quot;]);\r\n    const o = (i - e) \/ 2,\r\n      a = Math.min(o, s * e \/ 2),\r\n      r = t =&gt; {\r\n        const e = (i - Math.min(o, t)) * s \/ 2;\r\n        return J(t, 0, Math.min(o, e))\r\n      };\r\n    return {\r\n      outerStart: r(n.outerStart),\r\n      outerEnd: r(n.outerEnd),\r\n      innerStart: J(n.innerStart, 0, a),\r\n      innerEnd: J(n.innerEnd, 0, a)\r\n    }\r\n  }\r\n\r\n  function Xn(t, e, i, s) {\r\n    return {\r\n      x: i + t * Math.cos(e),\r\n      y: s + t * Math.sin(e)\r\n    }\r\n  }\r\n\r\n  function qn(t, e, i, s, n, o) {\r\n    const {\r\n      x: a,\r\n      y: r,\r\n      startAngle: l,\r\n      pixelMargin: h,\r\n      innerRadius: c\r\n    } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c &gt; 0 ? c + s + i + h : 0;\r\n    let f = 0;\r\n    const g = n - l;\r\n    if (s) {\r\n      const t = ((c &gt; 0 ? c - s : 0) + (d &gt; 0 ? d - s : 0)) \/ 2;\r\n      f = (g - (0 !== t ? g * t \/ (t + s) : g)) \/ 2\r\n    }\r\n    const p = (g - Math.max(.001, g * d - i \/ C) \/ d) \/ 2,\r\n      m = l + p + f,\r\n      x = n - p - f,\r\n      {\r\n        outerStart: b,\r\n        outerEnd: _,\r\n        innerStart: y,\r\n        innerEnd: v\r\n      } = Un(e, u, d, x - m),\r\n      M = d - b,\r\n      w = d - _,\r\n      k = m + b \/ M,\r\n      S = x - _ \/ w,\r\n      P = u + y,\r\n      D = u + v,\r\n      O = m + y \/ P,\r\n      A = x - v \/ D;\r\n    if (t.beginPath(), o) {\r\n      const e = (k + S) \/ 2;\r\n      if (t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ &gt; 0) {\r\n        const e = Xn(w, S, a, r);\r\n        t.arc(e.x, e.y, _, S, x + E)\r\n      }\r\n      const i = Xn(D, x, a, r);\r\n      if (t.lineTo(i.x, i.y), v &gt; 0) {\r\n        const e = Xn(D, A, a, r);\r\n        t.arc(e.x, e.y, v, x + E, A + Math.PI)\r\n      }\r\n      const s = (x - v \/ u + (m + y \/ u)) \/ 2;\r\n      if (t.arc(a, r, u, x - v \/ u, s, !0), t.arc(a, r, u, s, m + y \/ u, !0), y &gt; 0) {\r\n        const e = Xn(P, O, a, r);\r\n        t.arc(e.x, e.y, y, O + Math.PI, m - E)\r\n      }\r\n      const n = Xn(M, m, a, r);\r\n      if (t.lineTo(n.x, n.y), b &gt; 0) {\r\n        const e = Xn(M, k, a, r);\r\n        t.arc(e.x, e.y, b, m - E, k)\r\n      }\r\n    } else {\r\n      t.moveTo(a, r);\r\n      const e = Math.cos(k) * d + a,\r\n        i = Math.sin(k) * d + r;\r\n      t.lineTo(e, i);\r\n      const s = Math.cos(S) * d + a,\r\n        n = Math.sin(S) * d + r;\r\n      t.lineTo(s, n)\r\n    }\r\n    t.closePath()\r\n  }\r\n\r\n  function Kn(t, e, i, s, n) {\r\n    const {\r\n      fullCircles: o,\r\n      startAngle: a,\r\n      circumference: r,\r\n      options: l\r\n    } = e, {\r\n      borderWidth: h,\r\n      borderJoinStyle: c,\r\n      borderDash: d,\r\n      borderDashOffset: u\r\n    } = l, f = &quot;inner&quot; === l.borderAlign;\r\n    if (!h) return;\r\n    t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || &quot;round&quot;) : (t.lineWidth = h, t.lineJoin = c || &quot;bevel&quot;);\r\n    let g = e.endAngle;\r\n    if (o) {\r\n      qn(t, e, i, s, g, n);\r\n      for (let e = 0; e &lt; o; ++e) t.stroke();\r\n      isNaN(r) || (g = a + (r % O || O))\r\n    }\r\n    f &amp;&amp; function(t, e, i) {\r\n      const {\r\n        startAngle: s,\r\n        pixelMargin: n,\r\n        x: o,\r\n        y: a,\r\n        outerRadius: r,\r\n        innerRadius: l\r\n      } = e;\r\n      let h = n \/ r;\r\n      t.beginPath(), t.arc(o, a, r, s - h, i + h), l &gt; n ? (h = n \/ l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + E, s - E), t.closePath(), t.clip()\r\n    }(t, e, g), o || (qn(t, e, i, s, g, n), t.stroke())\r\n  }\r\n\r\n  function Gn(t, e, i = e) {\r\n    t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor)\r\n  }\r\n\r\n  function Zn(t, e, i) {\r\n    t.lineTo(i.x, i.y)\r\n  }\r\n\r\n  function Jn(t, e, i = {}) {\r\n    const s = t.length,\r\n      {\r\n        start: n = 0,\r\n        end: o = s - 1\r\n      } = i,\r\n      {\r\n        start: a,\r\n        end: r\r\n      } = e,\r\n      l = Math.max(n, a),\r\n      h = Math.min(o, r),\r\n      c = n &lt; a &amp;&amp; o &lt; a || n &gt; r &amp;&amp; o &gt; r;\r\n    return {\r\n      count: s,\r\n      start: l,\r\n      loop: e.loop,\r\n      ilen: h &lt; l &amp;&amp; !c ? s + h - l : h - l\r\n    }\r\n  }\r\n\r\n  function Qn(t, e, i, s) {\r\n    const {\r\n      points: n,\r\n      options: o\r\n    } = e, {\r\n      count: a,\r\n      start: r,\r\n      loop: l,\r\n      ilen: h\r\n    } = Jn(n, i, s), c = function(t) {\r\n      return t.stepped ? Fe : t.tension || &quot;monotone&quot; === t.cubicInterpolationMode ? Ve : Zn\r\n    }(o);\r\n    let d, u, f, {\r\n      move: g = !0,\r\n      reverse: p\r\n    } = s || {};\r\n    for (d = 0; d &lt;= h; ++d) u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);\r\n    return l &amp;&amp; (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l\r\n  }\r\n\r\n  function to(t, e, i, s) {\r\n    const n = e.points,\r\n      {\r\n        count: o,\r\n        start: a,\r\n        ilen: r\r\n      } = Jn(n, i, s),\r\n      {\r\n        move: l = !0,\r\n        reverse: h\r\n      } = s || {};\r\n    let c, d, u, f, g, p, m = 0,\r\n      x = 0;\r\n    const b = t =&gt; (a + (h ? r - t : t)) % o,\r\n      _ = () =&gt; {\r\n        f !== g &amp;&amp; (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p))\r\n      };\r\n    for (l &amp;&amp; (d = n[b(0)], t.moveTo(d.x, d.y)), c = 0; c &lt;= r; ++c) {\r\n      if (d = n[b(c)], d.skip) continue;\r\n      const e = d.x,\r\n        i = d.y,\r\n        s = 0 | e;\r\n      s === u ? (i &lt; f ? f = i : i &gt; g &amp;&amp; (g = i), m = (x * m + e) \/ ++x) : (_(), t.lineTo(e, i), u = s, x = 0, f = g = i), p = i\r\n    }\r\n    _()\r\n  }\r\n\r\n  function eo(t) {\r\n    const e = t.options,\r\n      i = e.borderDash &amp;&amp; e.borderDash.length;\r\n    return !(t._decimated || t._loop || e.tension || &quot;monotone&quot; === e.cubicInterpolationMode || e.stepped || i) ? to : Qn\r\n  }\r\n  const io = &quot;function&quot; == typeof Path2D;\r\n\r\n  function so(t, e, i, s) {\r\n    io &amp;&amp; !e.options.segment ? function(t, e, i, s) {\r\n      let n = e._path;\r\n      n || (n = e._path = new Path2D, e.path(n, i, s) &amp;&amp; n.closePath()), Gn(t, e.options), t.stroke(n)\r\n    }(t, e, i, s) : function(t, e, i, s) {\r\n      const {\r\n        segments: n,\r\n        options: o\r\n      } = e, a = eo(e);\r\n      for (const r of n) Gn(t, o, r.style), t.beginPath(), a(t, e, r, {\r\n        start: i,\r\n        end: i + s - 1\r\n      }) &amp;&amp; t.closePath(), t.stroke()\r\n    }(t, e, i, s)\r\n  }\r\n  class no extends Hs {\r\n    static id = &quot;line&quot;;\r\n    static defaults = {\r\n      borderCapStyle: &quot;butt&quot;,\r\n      borderDash: [],\r\n      borderDashOffset: 0,\r\n      borderJoinStyle: &quot;miter&quot;,\r\n      borderWidth: 3,\r\n      capBezierPoints: !0,\r\n      cubicInterpolationMode: &quot;default&quot;,\r\n      fill: !1,\r\n      spanGaps: !1,\r\n      stepped: !1,\r\n      tension: 0\r\n    };\r\n    static defaultRoutes = {\r\n      backgroundColor: &quot;backgroundColor&quot;,\r\n      borderColor: &quot;borderColor&quot;\r\n    };\r\n    static descriptors = {\r\n      _scriptable: !0,\r\n      _indexable: t =&gt; &quot;borderDash&quot; !== t &amp;&amp; &quot;fill&quot; !== t\r\n    };\r\n    constructor(t) {\r\n      super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t &amp;&amp; Object.assign(this, t)\r\n    }\r\n    updateControlPoints(t, e) {\r\n      const i = this.options;\r\n      if ((i.tension || &quot;monotone&quot; === i.cubicInterpolationMode) &amp;&amp; !i.stepped &amp;&amp; !this._pointsUpdated) {\r\n        const s = i.spanGaps ? this._loop : this._fullLoop;\r\n        hi(this._points, i, t, s, e), this._pointsUpdated = !0\r\n      }\r\n    }\r\n    set points(t) {\r\n      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1\r\n    }\r\n    get points() {\r\n      return this._points\r\n    }\r\n    get segments() {\r\n      return this._segments || (this._segments = zi(this, this.options.segment))\r\n    }\r\n    first() {\r\n      const t = this.segments,\r\n        e = this.points;\r\n      return t.length &amp;&amp; e[t[0].start]\r\n    }\r\n    last() {\r\n      const t = this.segments,\r\n        e = this.points,\r\n        i = t.length;\r\n      return i &amp;&amp; e[t[i - 1].end]\r\n    }\r\n    interpolate(t, e) {\r\n      const i = this.options,\r\n        s = t[e],\r\n        n = this.points,\r\n        o = Ii(this, {\r\n          property: e,\r\n          start: s,\r\n          end: s\r\n        });\r\n      if (!o.length) return;\r\n      const a = [],\r\n        r = function(t) {\r\n          return t.stepped ? pi : t.tension || &quot;monotone&quot; === t.cubicInterpolationMode ? mi : gi\r\n        }(i);\r\n      let l, h;\r\n      for (l = 0, h = o.length; l &lt; h; ++l) {\r\n        const {\r\n          start: h,\r\n          end: c\r\n        } = o[l], d = n[h], u = n[c];\r\n        if (d === u) {\r\n          a.push(d);\r\n          continue\r\n        }\r\n        const f = r(d, u, Math.abs((s - d[e]) \/ (u[e] - d[e])), i.stepped);\r\n        f[e] = t[e], a.push(f)\r\n      }\r\n      return 1 === a.length ? a[0] : a\r\n    }\r\n    pathSegment(t, e, i) {\r\n      return eo(this)(t, this, e, i)\r\n    }\r\n    path(t, e, i) {\r\n      const s = this.segments,\r\n        n = eo(this);\r\n      let o = this._loop;\r\n      e = e || 0, i = i || this.points.length - e;\r\n      for (const a of s) o &amp;= n(t, this, a, {\r\n        start: e,\r\n        end: e + i - 1\r\n      });\r\n      return !!o\r\n    }\r\n    draw(t, e, i, s) {\r\n      const n = this.options || {};\r\n      (this.points || []).length &amp;&amp; n.borderWidth &amp;&amp; (t.save(), so(t, this, i, s), t.restore()), this.animated &amp;&amp; (this._pointsUpdated = !1, this._path = void 0)\r\n    }\r\n  }\r\n\r\n  function oo(t, e, i, s) {\r\n    const n = t.options,\r\n      {\r\n        [i]: o\r\n      } = t.getProps([i], s);\r\n    return Math.abs(e - o) &lt; n.radius + n.hitRadius\r\n  }\r\n\r\n  function ao(t, e) {\r\n    const {\r\n      x: i,\r\n      y: s,\r\n      base: n,\r\n      width: o,\r\n      height: a\r\n    } = t.getProps([&quot;x&quot;, &quot;y&quot;, &quot;base&quot;, &quot;width&quot;, &quot;height&quot;], e);\r\n    let r, l, h, c, d;\r\n    return t.horizontal ? (d = a \/ 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o \/ 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {\r\n      left: r,\r\n      top: h,\r\n      right: l,\r\n      bottom: c\r\n    }\r\n  }\r\n\r\n  function ro(t, e, i, s) {\r\n    return t ? 0 : J(e, i, s)\r\n  }\r\n\r\n  function lo(t) {\r\n    const e = ao(t),\r\n      i = e.right - e.left,\r\n      s = e.bottom - e.top,\r\n      n = function(t, e, i) {\r\n        const s = t.options.borderWidth,\r\n          n = t.borderSkipped,\r\n          o = Mi(s);\r\n        return {\r\n          t: ro(n.top, o.top, 0, i),\r\n          r: ro(n.right, o.right, 0, e),\r\n          b: ro(n.bottom, o.bottom, 0, i),\r\n          l: ro(n.left, o.left, 0, e)\r\n        }\r\n      }(t, i \/ 2, s \/ 2),\r\n      a = function(t, e, i) {\r\n        const {\r\n          enableBorderRadius: s\r\n        } = t.getProps([&quot;enableBorderRadius&quot;]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);\r\n        return {\r\n          topLeft: ro(!h || l.top || l.left, a.topLeft, 0, r),\r\n          topRight: ro(!h || l.top || l.right, a.topRight, 0, r),\r\n          bottomLeft: ro(!h || l.bottom || l.left, a.bottomLeft, 0, r),\r\n          bottomRight: ro(!h || l.bottom || l.right, a.bottomRight, 0, r)\r\n        }\r\n      }(t, i \/ 2, s \/ 2);\r\n    return {\r\n      outer: {\r\n        x: e.left,\r\n        y: e.top,\r\n        w: i,\r\n        h: s,\r\n        radius: a\r\n      },\r\n      inner: {\r\n        x: e.left + n.l,\r\n        y: e.top + n.t,\r\n        w: i - n.l - n.r,\r\n        h: s - n.t - n.b,\r\n        radius: {\r\n          topLeft: Math.max(0, a.topLeft - Math.max(n.t, n.l)),\r\n          topRight: Math.max(0, a.topRight - Math.max(n.t, n.r)),\r\n          bottomLeft: Math.max(0, a.bottomLeft - Math.max(n.b, n.l)),\r\n          bottomRight: Math.max(0, a.bottomRight - Math.max(n.b, n.r))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function ho(t, e, i, s) {\r\n    const n = null === e,\r\n      o = null === i,\r\n      a = t &amp;&amp; !(n &amp;&amp; o) &amp;&amp; ao(t, s);\r\n    return a &amp;&amp; (n || tt(e, a.left, a.right)) &amp;&amp; (o || tt(i, a.top, a.bottom))\r\n  }\r\n\r\n  function co(t, e) {\r\n    t.rect(e.x, e.y, e.w, e.h)\r\n  }\r\n\r\n  function uo(t, e, i = {}) {\r\n    const s = t.x !== i.x ? -e : 0,\r\n      n = t.y !== i.y ? -e : 0,\r\n      o = (t.x + t.w !== i.x + i.w ? e : 0) - s,\r\n      a = (t.y + t.h !== i.y + i.h ? e : 0) - n;\r\n    return {\r\n      x: t.x + s,\r\n      y: t.y + n,\r\n      w: t.w + o,\r\n      h: t.h + a,\r\n      radius: t.radius\r\n    }\r\n  }\r\n  var fo = Object.freeze({\r\n    __proto__: null,\r\n    ArcElement: class extends Hs {\r\n      static id = &quot;arc&quot;;\r\n      static defaults = {\r\n        borderAlign: &quot;center&quot;,\r\n        borderColor: &quot;#fff&quot;,\r\n        borderDash: [],\r\n        borderDashOffset: 0,\r\n        borderJoinStyle: void 0,\r\n        borderRadius: 0,\r\n        borderWidth: 2,\r\n        offset: 0,\r\n        spacing: 0,\r\n        angle: void 0,\r\n        circular: !0\r\n      };\r\n      static defaultRoutes = {\r\n        backgroundColor: &quot;backgroundColor&quot;\r\n      };\r\n      static descriptors = {\r\n        _scriptable: !0,\r\n        _indexable: t =&gt; &quot;borderDash&quot; !== t\r\n      };\r\n      circumference;\r\n      endAngle;\r\n      fullCircles;\r\n      innerRadius;\r\n      outerRadius;\r\n      pixelMargin;\r\n      startAngle;\r\n      constructor(t) {\r\n        super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t &amp;&amp; Object.assign(this, t)\r\n      }\r\n      inRange(t, e, i) {\r\n        const s = this.getProps([&quot;x&quot;, &quot;y&quot;], i),\r\n          {\r\n            angle: n,\r\n            distance: o\r\n          } = X(s, {\r\n            x: t,\r\n            y: e\r\n          }),\r\n          {\r\n            startAngle: a,\r\n            endAngle: r,\r\n            innerRadius: h,\r\n            outerRadius: c,\r\n            circumference: d\r\n          } = this.getProps([&quot;startAngle&quot;, &quot;endAngle&quot;, &quot;innerRadius&quot;, &quot;outerRadius&quot;, &quot;circumference&quot;], i),\r\n          u = (this.options.spacing + this.options.borderWidth) \/ 2,\r\n          f = l(d, r - a) &gt;= O || Z(n, a, r),\r\n          g = tt(o, h + u, c + u);\r\n        return f &amp;&amp; g\r\n      }\r\n      getCenterPoint(t) {\r\n        const {\r\n          x: e,\r\n          y: i,\r\n          startAngle: s,\r\n          endAngle: n,\r\n          innerRadius: o,\r\n          outerRadius: a\r\n        } = this.getProps([&quot;x&quot;, &quot;y&quot;, &quot;startAngle&quot;, &quot;endAngle&quot;, &quot;innerRadius&quot;, &quot;outerRadius&quot;], t), {\r\n          offset: r,\r\n          spacing: l\r\n        } = this.options, h = (s + n) \/ 2, c = (o + a + l + r) \/ 2;\r\n        return {\r\n          x: e + Math.cos(h) * c,\r\n          y: i + Math.sin(h) * c\r\n        }\r\n      }\r\n      tooltipPosition(t) {\r\n        return this.getCenterPoint(t)\r\n      }\r\n      draw(t) {\r\n        const {\r\n          options: e,\r\n          circumference: i\r\n        } = this, s = (e.offset || 0) \/ 4, n = (e.spacing || 0) \/ 2, o = e.circular;\r\n        if (this.pixelMargin = &quot;inner&quot; === e.borderAlign ? .33 : 0, this.fullCircles = i &gt; O ? Math.floor(i \/ O) : 0, 0 === i || this.innerRadius &lt; 0 || this.outerRadius &lt; 0) return;\r\n        t.save();\r\n        const a = (this.startAngle + this.endAngle) \/ 2;\r\n        t.translate(Math.cos(a) * s, Math.sin(a) * s);\r\n        const r = s * (1 - Math.sin(Math.min(C, i || 0)));\r\n        t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor,\r\n          function(t, e, i, s, n) {\r\n            const {\r\n              fullCircles: o,\r\n              startAngle: a,\r\n              circumference: r\r\n            } = e;\r\n            let l = e.endAngle;\r\n            if (o) {\r\n              qn(t, e, i, s, l, n);\r\n              for (let e = 0; e &lt; o; ++e) t.fill();\r\n              isNaN(r) || (l = a + (r % O || O))\r\n            }\r\n            qn(t, e, i, s, l, n), t.fill()\r\n          }(t, this, r, n, o), Kn(t, this, r, n, o), t.restore()\r\n      }\r\n    },\r\n    BarElement: class extends Hs {\r\n      static id = &quot;bar&quot;;\r\n      static defaults = {\r\n        borderSkipped: &quot;start&quot;,\r\n        borderWidth: 0,\r\n        borderRadius: 0,\r\n        inflateAmount: &quot;auto&quot;,\r\n        pointStyle: void 0\r\n      };\r\n      static defaultRoutes = {\r\n        backgroundColor: &quot;backgroundColor&quot;,\r\n        borderColor: &quot;borderColor&quot;\r\n      };\r\n      constructor(t) {\r\n        super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t &amp;&amp; Object.assign(this, t)\r\n      }\r\n      draw(t) {\r\n        const {\r\n          inflateAmount: e,\r\n          options: {\r\n            borderColor: i,\r\n            backgroundColor: s\r\n          }\r\n        } = this, {\r\n          inner: n,\r\n          outer: o\r\n        } = lo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : co;\r\n        var r;\r\n        t.save(), o.w === n.w &amp;&amp; o.h === n.h || (t.beginPath(), a(t, uo(o, e, n)), t.clip(), a(t, uo(n, -e, o)), t.fillStyle = i, t.fill(&quot;evenodd&quot;)), t.beginPath(), a(t, uo(n, e)), t.fillStyle = s, t.fill(), t.restore()\r\n      }\r\n      inRange(t, e, i) {\r\n        return ho(this, t, e, i)\r\n      }\r\n      inXRange(t, e) {\r\n        return ho(this, t, null, e)\r\n      }\r\n      inYRange(t, e) {\r\n        return ho(this, null, t, e)\r\n      }\r\n      getCenterPoint(t) {\r\n        const {\r\n          x: e,\r\n          y: i,\r\n          base: s,\r\n          horizontal: n\r\n        } = this.getProps([&quot;x&quot;, &quot;y&quot;, &quot;base&quot;, &quot;horizontal&quot;], t);\r\n        return {\r\n          x: n ? (e + s) \/ 2 : e,\r\n          y: n ? i : (i + s) \/ 2\r\n        }\r\n      }\r\n      getRange(t) {\r\n        return &quot;x&quot; === t ? this.width \/ 2 : this.height \/ 2\r\n      }\r\n    },\r\n    LineElement: no,\r\n    PointElement: class extends Hs {\r\n      static id = &quot;point&quot;;\r\n      parsed;\r\n      skip;\r\n      stop;\r\n      static defaults = {\r\n        borderWidth: 1,\r\n        hitRadius: 1,\r\n        hoverBorderWidth: 1,\r\n        hoverRadius: 4,\r\n        pointStyle: &quot;circle&quot;,\r\n        radius: 3,\r\n        rotation: 0\r\n      };\r\n      static defaultRoutes = {\r\n        backgroundColor: &quot;backgroundColor&quot;,\r\n        borderColor: &quot;borderColor&quot;\r\n      };\r\n      constructor(t) {\r\n        super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t &amp;&amp; Object.assign(this, t)\r\n      }\r\n      inRange(t, e, i) {\r\n        const s = this.options,\r\n          {\r\n            x: n,\r\n            y: o\r\n          } = this.getProps([&quot;x&quot;, &quot;y&quot;], i);\r\n        return Math.pow(t - n, 2) + Math.pow(e - o, 2) &lt; Math.pow(s.hitRadius + s.radius, 2)\r\n      }\r\n      inXRange(t, e) {\r\n        return oo(this, t, &quot;x&quot;, e)\r\n      }\r\n      inYRange(t, e) {\r\n        return oo(this, t, &quot;y&quot;, e)\r\n      }\r\n      getCenterPoint(t) {\r\n        const {\r\n          x: e,\r\n          y: i\r\n        } = this.getProps([&quot;x&quot;, &quot;y&quot;], t);\r\n        return {\r\n          x: e,\r\n          y: i\r\n        }\r\n      }\r\n      size(t) {\r\n        let e = (t = t || this.options || {}).radius || 0;\r\n        e = Math.max(e, e &amp;&amp; t.hoverRadius || 0);\r\n        return 2 * (e + (e &amp;&amp; t.borderWidth || 0))\r\n      }\r\n      draw(t, e) {\r\n        const i = this.options;\r\n        this.skip || i.radius &lt; .1 || !Re(this, e, this.size(i) \/ 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, this.x, this.y))\r\n      }\r\n      getRange() {\r\n        const t = this.options || {};\r\n        return t.radius + t.hitRadius\r\n      }\r\n    }\r\n  });\r\n\r\n  function go(t, e, i, s) {\r\n    const n = t.indexOf(e);\r\n    if (-1 === n) return ((t, e, i, s) =&gt; (&quot;string&quot; == typeof e ? (i = t.push(e) - 1, s.unshift({\r\n      index: i,\r\n      label: e\r\n    })) : isNaN(e) &amp;&amp; (i = null), i))(t, e, i, s);\r\n    return n !== t.lastIndexOf(e) ? i : n\r\n  }\r\n\r\n  function po(t) {\r\n    const e = this.getLabels();\r\n    return t &gt;= 0 &amp;&amp; t &lt; e.length ? e[t] : t\r\n  }\r\n\r\n  function mo(t, e, {\r\n    horizontal: i,\r\n    minRotation: s\r\n  }) {\r\n    const n = $(s),\r\n      o = (i ? Math.sin(n) : Math.cos(n)) || .001,\r\n      a = .75 * e * (&quot;&quot; + t).length;\r\n    return Math.min(e \/ o, a)\r\n  }\r\n  class xo extends Js {\r\n    constructor(t) {\r\n      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0\r\n    }\r\n    parse(t, e) {\r\n      return s(t) || (&quot;number&quot; == typeof t || t instanceof Number) &amp;&amp; !isFinite(+t) ? null : +t\r\n    }\r\n    handleTickRangeOptions() {\r\n      const {\r\n        beginAtZero: t\r\n      } = this.options, {\r\n        minDefined: e,\r\n        maxDefined: i\r\n      } = this.getUserBounds();\r\n      let {\r\n        min: s,\r\n        max: n\r\n      } = this;\r\n      const o = t =&gt; s = e ? s : t,\r\n        a = t =&gt; n = i ? n : t;\r\n      if (t) {\r\n        const t = F(s),\r\n          e = F(n);\r\n        t &lt; 0 &amp;&amp; e &lt; 0 ? a(0) : t &gt; 0 &amp;&amp; e &gt; 0 &amp;&amp; o(0)\r\n      }\r\n      if (s === n) {\r\n        let e = 0 === n ? 1 : Math.abs(.05 * n);\r\n        a(n + e), t || o(s - e)\r\n      }\r\n      this.min = s, this.max = n\r\n    }\r\n    getTickLimit() {\r\n      const t = this.options.ticks;\r\n      let e, {\r\n        maxTicksLimit: i,\r\n        stepSize: s\r\n      } = t;\r\n      return s ? (e = Math.ceil(this.max \/ s) - Math.floor(this.min \/ s) + 1, e &gt; 1e3 &amp;&amp; (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i &amp;&amp; (e = Math.min(i, e)), e\r\n    }\r\n    computeTickLimit() {\r\n      return Number.POSITIVE_INFINITY\r\n    }\r\n    buildTicks() {\r\n      const t = this.options,\r\n        e = t.ticks;\r\n      let i = this.getTickLimit();\r\n      i = Math.max(2, i);\r\n      const n = function(t, e) {\r\n        const i = [],\r\n          {\r\n            bounds: n,\r\n            step: o,\r\n            min: a,\r\n            max: r,\r\n            precision: l,\r\n            count: h,\r\n            maxTicks: c,\r\n            maxDigits: d,\r\n            includeBounds: u\r\n          } = t,\r\n          f = o || 1,\r\n          g = c - 1,\r\n          {\r\n            min: p,\r\n            max: m\r\n          } = e,\r\n          x = !s(a),\r\n          b = !s(r),\r\n          _ = !s(h),\r\n          y = (m - p) \/ (d + 1);\r\n        let v, M, w, k, S = B((m - p) \/ g \/ f) * f;\r\n        if (S &lt; 1e-14 &amp;&amp; !x &amp;&amp; !b) return [{\r\n          value: p\r\n        }, {\r\n          value: m\r\n        }];\r\n        k = Math.ceil(m \/ S) - Math.floor(p \/ S), k &gt; g &amp;&amp; (S = B(k * S \/ g \/ f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) \/ v), &quot;ticks&quot; === n ? (M = Math.floor(p \/ S) * S, w = Math.ceil(m \/ S) * S) : (M = p, w = m), x &amp;&amp; b &amp;&amp; o &amp;&amp; H((r - a) \/ o, S \/ 1e3) ? (k = Math.round(Math.min((r - a) \/ S, c)), S = (r - a) \/ k, M = a, w = r) : _ ? (M = x ? a : M, w = b ? r : w, k = h - 1, S = (w - M) \/ k) : (k = (w - M) \/ S, k = V(k, Math.round(k), S \/ 1e3) ? Math.round(k) : Math.ceil(k));\r\n        const P = Math.max(U(S), U(M));\r\n        v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) \/ v, w = Math.round(w * v) \/ v;\r\n        let D = 0;\r\n        for (x &amp;&amp; (u &amp;&amp; M !== a ? (i.push({\r\n            value: a\r\n          }), M &lt; a &amp;&amp; D++, V(Math.round((M + D * S) * v) \/ v, a, mo(a, y, t)) &amp;&amp; D++) : M &lt; a &amp;&amp; D++); D &lt; k; ++D) {\r\n          const t = Math.round((M + D * S) * v) \/ v;\r\n          if (b &amp;&amp; t &gt; r) break;\r\n          i.push({\r\n            value: t\r\n          })\r\n        }\r\n        return b &amp;&amp; u &amp;&amp; w !== r ? i.length &amp;&amp; V(i[i.length - 1].value, r, mo(r, y, t)) ? i[i.length - 1].value = r : i.push({\r\n          value: r\r\n        }) : b &amp;&amp; w !== r || i.push({\r\n          value: w\r\n        }), i\r\n      }({\r\n        maxTicks: i,\r\n        bounds: t.bounds,\r\n        min: t.min,\r\n        max: t.max,\r\n        precision: e.precision,\r\n        step: e.stepSize,\r\n        count: e.count,\r\n        maxDigits: this._maxDigits(),\r\n        horizontal: this.isHorizontal(),\r\n        minRotation: e.minRotation || 0,\r\n        includeBounds: !1 !== e.includeBounds\r\n      }, this._range || this);\r\n      return &quot;ticks&quot; === t.bounds &amp;&amp; j(n, this, &quot;value&quot;), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n\r\n    }\r\n    configure() {\r\n      const t = this.ticks;\r\n      let e = this.min,\r\n        i = this.max;\r\n      if (super.configure(), this.options.offset &amp;&amp; t.length) {\r\n        const s = (i - e) \/ Math.max(t.length - 1, 1) \/ 2;\r\n        e -= s, i += s\r\n      }\r\n      this._startValue = e, this._endValue = i, this._valueRange = i - e\r\n    }\r\n    getLabelForValue(t) {\r\n      return ne(t, this.chart.options.locale, this.options.ticks.format)\r\n    }\r\n  }\r\n  class bo extends xo {\r\n    static id = &quot;linear&quot;;\r\n    static defaults = {\r\n      ticks: {\r\n        callback: ae.formatters.numeric\r\n      }\r\n    };\r\n    determineDataLimits() {\r\n      const {\r\n        min: t,\r\n        max: e\r\n      } = this.getMinMax(!0);\r\n      this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions()\r\n    }\r\n    computeTickLimit() {\r\n      const t = this.isHorizontal(),\r\n        e = t ? this.width : this.height,\r\n        i = $(this.options.ticks.minRotation),\r\n        s = (t ? Math.sin(i) : Math.cos(i)) || .001,\r\n        n = this._resolveTickFontOptions(0);\r\n      return Math.ceil(e \/ Math.min(40, n.lineHeight \/ s))\r\n    }\r\n    getPixelForValue(t) {\r\n      return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) \/ this._valueRange)\r\n    }\r\n    getValueForPixel(t) {\r\n      return this._startValue + this.getDecimalForPixel(t) * this._valueRange\r\n    }\r\n  }\r\n  const _o = t =&gt; Math.floor(z(t)),\r\n    yo = (t, e) =&gt; Math.pow(10, _o(t) + e);\r\n\r\n  function vo(t) {\r\n    return 1 === t \/ Math.pow(10, _o(t))\r\n  }\r\n\r\n  function Mo(t, e, i) {\r\n    const s = Math.pow(10, i),\r\n      n = Math.floor(t \/ s);\r\n    return Math.ceil(e \/ s) - n\r\n  }\r\n\r\n  function wo(t, {\r\n    min: e,\r\n    max: i\r\n  }) {\r\n    e = r(t.min, e);\r\n    const s = [],\r\n      n = _o(e);\r\n    let o = function(t, e) {\r\n        let i = _o(e - t);\r\n        for (; Mo(t, e, i) &gt; 10;) i++;\r\n        for (; Mo(t, e, i) &lt; 10;) i--;\r\n        return Math.min(i, _o(t))\r\n      }(e, i),\r\n      a = o &lt; 0 ? Math.pow(10, Math.abs(o)) : 1;\r\n    const l = Math.pow(10, o),\r\n      h = n &gt; o ? Math.pow(10, n) : 0,\r\n      c = Math.round((e - h) * a) \/ a,\r\n      d = Math.floor((e - h) \/ l \/ 10) * l * 10;\r\n    let u = Math.floor((c - d) \/ Math.pow(10, o)),\r\n      f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) \/ a);\r\n    for (; f &lt; i;) s.push({\r\n      value: f,\r\n      major: vo(f),\r\n      significand: u\r\n    }), u &gt;= 10 ? u = u &lt; 15 ? 15 : 20 : u++, u &gt;= 20 &amp;&amp; (o++, u = 2, a = o &gt;= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) \/ a;\r\n    const g = r(t.max, f);\r\n    return s.push({\r\n      value: g,\r\n      major: vo(g),\r\n      significand: u\r\n    }), s\r\n  }\r\n  class ko extends Js {\r\n    static id = &quot;logarithmic&quot;;\r\n    static defaults = {\r\n      ticks: {\r\n        callback: ae.formatters.logarithmic,\r\n        major: {\r\n          enabled: !0\r\n        }\r\n      }\r\n    };\r\n    constructor(t) {\r\n      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0\r\n    }\r\n    parse(t, e) {\r\n      const i = xo.prototype.parse.apply(this, [t, e]);\r\n      if (0 !== i) return a(i) &amp;&amp; i &gt; 0 ? i : null;\r\n      this._zero = !0\r\n    }\r\n    determineDataLimits() {\r\n      const {\r\n        min: t,\r\n        max: e\r\n      } = this.getMinMax(!0);\r\n      this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero &amp;&amp; (this._zero = !0), this._zero &amp;&amp; this.min !== this._suggestedMin &amp;&amp; !a(this._userMin) &amp;&amp; (this.min = t === yo(this.min, 0) ? yo(this.min, -1) : yo(this.min, 0)), this.handleTickRangeOptions()\r\n    }\r\n    handleTickRangeOptions() {\r\n      const {\r\n        minDefined: t,\r\n        maxDefined: e\r\n      } = this.getUserBounds();\r\n      let i = this.min,\r\n        s = this.max;\r\n      const n = e =&gt; i = t ? i : e,\r\n        o = t =&gt; s = e ? s : t;\r\n      i === s &amp;&amp; (i &lt;= 0 ? (n(1), o(10)) : (n(yo(i, -1)), o(yo(s, 1)))), i &lt;= 0 &amp;&amp; n(yo(s, -1)), s &lt;= 0 &amp;&amp; o(yo(i, 1)), this.min = i, this.max = s\r\n    }\r\n    buildTicks() {\r\n      const t = this.options,\r\n        e = wo({\r\n          min: this._userMin,\r\n          max: this._userMax\r\n        }, this);\r\n      return &quot;ticks&quot; === t.bounds &amp;&amp; j(e, this, &quot;value&quot;), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e\r\n    }\r\n    getLabelForValue(t) {\r\n      return void 0 === t ? &quot;0&quot; : ne(t, this.chart.options.locale, this.options.ticks.format)\r\n    }\r\n    configure() {\r\n      const t = this.min;\r\n      super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t)\r\n    }\r\n    getPixelForValue(t) {\r\n      return void 0 !== t &amp;&amp; 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) \/ this._valueRange)\r\n    }\r\n    getValueForPixel(t) {\r\n      const e = this.getDecimalForPixel(t);\r\n      return Math.pow(10, this._startValue + e * this._valueRange)\r\n    }\r\n  }\r\n\r\n  function So(t) {\r\n    const e = t.ticks;\r\n    if (e.display &amp;&amp; t.display) {\r\n      const t = ki(e.backdropPadding);\r\n      return l(e.font &amp;&amp; e.font.size, ue.font.size) + t.height\r\n    }\r\n    return 0\r\n  }\r\n\r\n  function Po(t, e, i, s, n) {\r\n    return t === s || t === n ? {\r\n      start: e - i \/ 2,\r\n      end: e + i \/ 2\r\n    } : t &lt; s || t &gt; n ? {\r\n      start: e - i,\r\n      end: e\r\n    } : {\r\n      start: e,\r\n      end: e + i\r\n    }\r\n  }\r\n\r\n  function Do(t) {\r\n    const e = {\r\n        l: t.left + t._padding.left,\r\n        r: t.right - t._padding.right,\r\n        t: t.top + t._padding.top,\r\n        b: t.bottom - t._padding.bottom\r\n      },\r\n      i = Object.assign({}, e),\r\n      s = [],\r\n      o = [],\r\n      a = t._pointLabels.length,\r\n      r = t.options.pointLabels,\r\n      l = r.centerPointLabels ? C \/ a : 0;\r\n    for (let u = 0; u &lt; a; u++) {\r\n      const a = r.setContext(t.getPointLabelContext(u));\r\n      o[u] = a.padding;\r\n      const f = t.getPointPosition(u, t.drawingArea + o[u], l),\r\n        g = Si(a.font),\r\n        p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [d], {\r\n          w: Oe(h, c.string, d),\r\n          h: d.length * c.lineHeight\r\n        });\r\n      s[u] = p;\r\n      const m = G(t.getIndexAngle(u) + l),\r\n        x = Math.round(Y(m));\r\n      Co(i, e, m, Po(x, f.x, p.w, 0, 180), Po(x, f.y, p.h, 90, 270))\r\n    }\r\n    var h, c, d;\r\n    t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function(t, e, i) {\r\n      const s = [],\r\n        n = t._pointLabels.length,\r\n        o = t.options,\r\n        {\r\n          centerPointLabels: a,\r\n          display: r\r\n        } = o.pointLabels,\r\n        l = {\r\n          extra: So(o) \/ 2,\r\n          additionalAngle: a ? C \/ n : 0\r\n        };\r\n      let h;\r\n      for (let o = 0; o &lt; n; o++) {\r\n        l.padding = i[o], l.size = e[o];\r\n        const n = Oo(t, o, l);\r\n        s.push(n), &quot;auto&quot; === r &amp;&amp; (n.visible = Ao(n, h), n.visible &amp;&amp; (h = n))\r\n      }\r\n      return s\r\n    }(t, s, o)\r\n  }\r\n\r\n  function Co(t, e, i, s, n) {\r\n    const o = Math.abs(Math.sin(i)),\r\n      a = Math.abs(Math.cos(i));\r\n    let r = 0,\r\n      l = 0;\r\n    s.start &lt; e.l ? (r = (e.l - s.start) \/ o, t.l = Math.min(t.l, e.l - r)) : s.end &gt; e.r &amp;&amp; (r = (s.end - e.r) \/ o, t.r = Math.max(t.r, e.r + r)), n.start &lt; e.t ? (l = (e.t - n.start) \/ a, t.t = Math.min(t.t, e.t - l)) : n.end &gt; e.b &amp;&amp; (l = (n.end - e.b) \/ a, t.b = Math.max(t.b, e.b + l))\r\n  }\r\n\r\n  function Oo(t, e, i) {\r\n    const s = t.drawingArea,\r\n      {\r\n        extra: n,\r\n        additionalAngle: o,\r\n        padding: a,\r\n        size: r\r\n      } = i,\r\n      l = t.getPointPosition(e, s + n + a, o),\r\n      h = Math.round(Y(G(l.angle + E))),\r\n      c = function(t, e, i) {\r\n        90 === i || 270 === i ? t -= e \/ 2 : (i &gt; 270 || i &lt; 90) &amp;&amp; (t -= e);\r\n        return t\r\n      }(l.y, r.h, h),\r\n      d = function(t) {\r\n        if (0 === t || 180 === t) return &quot;center&quot;;\r\n        if (t &lt; 180) return &quot;left&quot;;\r\n        return &quot;right&quot;\r\n      }(h),\r\n      u = function(t, e, i) {\r\n        &quot;right&quot; === i ? t -= e : &quot;center&quot; === i &amp;&amp; (t -= e \/ 2);\r\n        return t\r\n      }(l.x, r.w, d);\r\n    return {\r\n      visible: !0,\r\n      x: l.x,\r\n      y: c,\r\n      textAlign: d,\r\n      left: u,\r\n      top: c,\r\n      right: u + r.w,\r\n      bottom: c + r.h\r\n    }\r\n  }\r\n\r\n  function Ao(t, e) {\r\n    if (!e) return !0;\r\n    const {\r\n      left: i,\r\n      top: s,\r\n      right: n,\r\n      bottom: o\r\n    } = t;\r\n    return !(Re({\r\n      x: i,\r\n      y: s\r\n    }, e) || Re({\r\n      x: i,\r\n      y: o\r\n    }, e) || Re({\r\n      x: n,\r\n      y: s\r\n    }, e) || Re({\r\n      x: n,\r\n      y: o\r\n    }, e))\r\n  }\r\n\r\n  function To(t, e, i) {\r\n    const {\r\n      left: n,\r\n      top: o,\r\n      right: a,\r\n      bottom: r\r\n    } = i, {\r\n      backdropColor: l\r\n    } = e;\r\n    if (!s(l)) {\r\n      const i = wi(e.borderRadius),\r\n        s = ki(e.backdropPadding);\r\n      t.fillStyle = l;\r\n      const h = n - s.left,\r\n        c = o - s.top,\r\n        d = a - n + s.width,\r\n        u = r - o + s.height;\r\n      Object.values(i).some((t =&gt; 0 !== t)) ? (t.beginPath(), He(t, {\r\n        x: h,\r\n        y: c,\r\n        w: d,\r\n        h: u,\r\n        radius: i\r\n      }), t.fill()) : t.fillRect(h, c, d, u)\r\n    }\r\n  }\r\n\r\n  function Lo(t, e, i, s) {\r\n    const {\r\n      ctx: n\r\n    } = t;\r\n    if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);\r\n    else {\r\n      let i = t.getPointPosition(0, e);\r\n      n.moveTo(i.x, i.y);\r\n      for (let o = 1; o &lt; s; o++) i = t.getPointPosition(o, e), n.lineTo(i.x, i.y)\r\n    }\r\n  }\r\n  class Eo extends xo {\r\n    static id = &quot;radialLinear&quot;;\r\n    static defaults = {\r\n      display: !0,\r\n      animate: !0,\r\n      position: &quot;chartArea&quot;,\r\n      angleLines: {\r\n        display: !0,\r\n        lineWidth: 1,\r\n        borderDash: [],\r\n        borderDashOffset: 0\r\n      },\r\n      grid: {\r\n        circular: !1\r\n      },\r\n      startAngle: 0,\r\n      ticks: {\r\n        showLabelBackdrop: !0,\r\n        callback: ae.formatters.numeric\r\n      },\r\n      pointLabels: {\r\n        backdropColor: void 0,\r\n        backdropPadding: 2,\r\n        display: !0,\r\n        font: {\r\n          size: 10\r\n        },\r\n        callback: t =&gt; t,\r\n        padding: 5,\r\n        centerPointLabels: !1\r\n      }\r\n    };\r\n    static defaultRoutes = {\r\n      &quot;angleLines.color&quot;: &quot;borderColor&quot;,\r\n      &quot;pointLabels.color&quot;: &quot;color&quot;,\r\n      &quot;ticks.color&quot;: &quot;color&quot;\r\n    };\r\n    static descriptors = {\r\n      angleLines: {\r\n        _fallback: &quot;grid&quot;\r\n      }\r\n    };\r\n    constructor(t) {\r\n      super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []\r\n    }\r\n    setDimensions() {\r\n      const t = this._padding = ki(So(this.options) \/ 2),\r\n        e = this.width = this.maxWidth - t.width,\r\n        i = this.height = this.maxHeight - t.height;\r\n      this.xCenter = Math.floor(this.left + e \/ 2 + t.left), this.yCenter = Math.floor(this.top + i \/ 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) \/ 2)\r\n    }\r\n    determineDataLimits() {\r\n      const {\r\n        min: t,\r\n        max: e\r\n      } = this.getMinMax(!1);\r\n      this.min = a(t) &amp;&amp; !isNaN(t) ? t : 0, this.max = a(e) &amp;&amp; !isNaN(e) ? e : 0, this.handleTickRangeOptions()\r\n    }\r\n    computeTickLimit() {\r\n      return Math.ceil(this.drawingArea \/ So(this.options))\r\n    }\r\n    generateTickLabels(t) {\r\n      xo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map(((t, e) =&gt; {\r\n        const i = d(this.options.pointLabels.callback, [t, e], this);\r\n        return i || 0 === i ? i : &quot;&quot;\r\n      })).filter(((t, e) =&gt; this.chart.getDataVisibility(e)))\r\n    }\r\n    fit() {\r\n      const t = this.options;\r\n      t.display &amp;&amp; t.pointLabels.display ? Do(this) : this.setCenterPoint(0, 0, 0, 0)\r\n    }\r\n    setCenterPoint(t, e, i, s) {\r\n      this.xCenter += Math.floor((t - e) \/ 2), this.yCenter += Math.floor((i - s) \/ 2), this.drawingArea -= Math.min(this.drawingArea \/ 2, Math.max(t, e, i, s))\r\n    }\r\n    getIndexAngle(t) {\r\n      return G(t * (O \/ (this._pointLabels.length || 1)) + $(this.options.startAngle || 0))\r\n    }\r\n    getDistanceFromCenterForValue(t) {\r\n      if (s(t)) return NaN;\r\n      const e = this.drawingArea \/ (this.max - this.min);\r\n      return this.options.reverse ? (this.max - t) * e : (t - this.min) * e\r\n    }\r\n    getValueForDistanceFromCenter(t) {\r\n      if (s(t)) return NaN;\r\n      const e = t \/ (this.drawingArea \/ (this.max - this.min));\r\n      return this.options.reverse ? this.max - e : this.min + e\r\n    }\r\n    getPointLabelContext(t) {\r\n      const e = this._pointLabels || [];\r\n      if (t &gt;= 0 &amp;&amp; t &lt; e.length) {\r\n        const i = e[t];\r\n        return function(t, e, i) {\r\n          return Ci(t, {\r\n            label: i,\r\n            index: e,\r\n            type: &quot;pointLabel&quot;\r\n          })\r\n        }(this.getContext(), t, i)\r\n      }\r\n    }\r\n    getPointPosition(t, e, i = 0) {\r\n      const s = this.getIndexAngle(t) - E + i;\r\n      return {\r\n        x: Math.cos(s) * e + this.xCenter,\r\n        y: Math.sin(s) * e + this.yCenter,\r\n        angle: s\r\n      }\r\n    }\r\n    getPointPositionForValue(t, e) {\r\n      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))\r\n    }\r\n    getBasePosition(t) {\r\n      return this.getPointPositionForValue(t || 0, this.getBaseValue())\r\n    }\r\n    getPointLabelPosition(t) {\r\n      const {\r\n        left: e,\r\n        top: i,\r\n        right: s,\r\n        bottom: n\r\n      } = this._pointLabelItems[t];\r\n      return {\r\n        left: e,\r\n        top: i,\r\n        right: s,\r\n        bottom: n\r\n      }\r\n    }\r\n    drawBackground() {\r\n      const {\r\n        backgroundColor: t,\r\n        grid: {\r\n          circular: e\r\n        }\r\n      } = this.options;\r\n      if (t) {\r\n        const i = this.ctx;\r\n        i.save(), i.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore()\r\n      }\r\n    }\r\n    drawGrid() {\r\n      const t = this.ctx,\r\n        e = this.options,\r\n        {\r\n          angleLines: i,\r\n          grid: s,\r\n          border: n\r\n        } = e,\r\n        o = this._pointLabels.length;\r\n      let a, r, l;\r\n      if (e.pointLabels.display &amp;&amp; function(t, e) {\r\n          const {\r\n            ctx: i,\r\n            options: {\r\n              pointLabels: s\r\n            }\r\n          } = t;\r\n          for (let n = e - 1; n &gt;= 0; n--) {\r\n            const e = t._pointLabelItems[n];\r\n            if (!e.visible) continue;\r\n            const o = s.setContext(t.getPointLabelContext(n));\r\n            To(i, o, e);\r\n            const a = Si(o.font),\r\n              {\r\n                x: r,\r\n                y: l,\r\n                textAlign: h\r\n              } = e;\r\n            Ne(i, t._pointLabels[n], r, l + a.lineHeight \/ 2, a, {\r\n              color: o.color,\r\n              textAlign: h,\r\n              textBaseline: &quot;middle&quot;\r\n            })\r\n          }\r\n        }(this, o), s.display &amp;&amp; this.ticks.forEach(((t, e) =&gt; {\r\n          if (0 !== e || 0 === e &amp;&amp; this.min &lt; 0) {\r\n            r = this.getDistanceFromCenterForValue(t.value);\r\n            const i = this.getContext(e),\r\n              a = s.setContext(i),\r\n              l = n.setContext(i);\r\n            ! function(t, e, i, s, n) {\r\n              const o = t.ctx,\r\n                a = e.circular,\r\n                {\r\n                  color: r,\r\n                  lineWidth: l\r\n                } = e;\r\n              !a &amp;&amp; !s || !r || !l || i &lt; 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash), o.lineDashOffset = n.dashOffset, o.beginPath(), Lo(t, i, a, s), o.closePath(), o.stroke(), o.restore())\r\n            }(this, a, r, o, l)\r\n          }\r\n        })), i.display) {\r\n        for (t.save(), a = o - 1; a &gt;= 0; a--) {\r\n          const s = i.setContext(this.getPointLabelContext(a)),\r\n            {\r\n              color: n,\r\n              lineWidth: o\r\n            } = s;\r\n          o &amp;&amp; n &amp;&amp; (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke())\r\n        }\r\n        t.restore()\r\n      }\r\n    }\r\n    drawBorder() {}\r\n    drawLabels() {\r\n      const t = this.ctx,\r\n        e = this.options,\r\n        i = e.ticks;\r\n      if (!i.display) return;\r\n      const s = this.getIndexAngle(0);\r\n      let n, o;\r\n      t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = &quot;center&quot;, t.textBaseline = &quot;middle&quot;, this.ticks.forEach(((s, a) =&gt; {\r\n        if (0 === a &amp;&amp; this.min &gt;= 0 &amp;&amp; !e.reverse) return;\r\n        const r = i.setContext(this.getContext(a)),\r\n          l = Si(r.font);\r\n        if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {\r\n          t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;\r\n          const e = ki(r.backdropPadding);\r\n          t.fillRect(-o \/ 2 - e.left, -n - l.size \/ 2 - e.top, o + e.width, l.size + e.height)\r\n        }\r\n        Ne(t, s.label, 0, -n, l, {\r\n          color: r.color,\r\n          strokeColor: r.textStrokeColor,\r\n          strokeWidth: r.textStrokeWidth\r\n        })\r\n      })), t.restore()\r\n    }\r\n    drawTitle() {}\r\n  }\r\n  const Ro = {\r\n      millisecond: {\r\n        common: !0,\r\n        size: 1,\r\n        steps: 1e3\r\n      },\r\n      second: {\r\n        common: !0,\r\n        size: 1e3,\r\n        steps: 60\r\n      },\r\n      minute: {\r\n        common: !0,\r\n        size: 6e4,\r\n        steps: 60\r\n      },\r\n      hour: {\r\n        common: !0,\r\n        size: 36e5,\r\n        steps: 24\r\n      },\r\n      day: {\r\n        common: !0,\r\n        size: 864e5,\r\n        steps: 30\r\n      },\r\n      week: {\r\n        common: !1,\r\n        size: 6048e5,\r\n        steps: 4\r\n      },\r\n      month: {\r\n        common: !0,\r\n        size: 2628e6,\r\n        steps: 12\r\n      },\r\n      quarter: {\r\n        common: !1,\r\n        size: 7884e6,\r\n        steps: 4\r\n      },\r\n      year: {\r\n        common: !0,\r\n        size: 3154e7\r\n      }\r\n    },\r\n    Io = Object.keys(Ro);\r\n\r\n  function zo(t, e) {\r\n    return t - e\r\n  }\r\n\r\n  function Fo(t, e) {\r\n    if (s(e)) return null;\r\n    const i = t._adapter,\r\n      {\r\n        parser: n,\r\n        round: o,\r\n        isoWeekday: r\r\n      } = t._parseOpts;\r\n    let l = e;\r\n    return &quot;function&quot; == typeof n &amp;&amp; (l = n(l)), a(l) || (l = &quot;string&quot; == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o &amp;&amp; (l = &quot;week&quot; !== o || !N(r) &amp;&amp; !0 !== r ? i.startOf(l, o) : i.startOf(l, &quot;isoWeek&quot;, r)), +l)\r\n  }\r\n\r\n  function Vo(t, e, i, s) {\r\n    const n = Io.length;\r\n    for (let o = Io.indexOf(t); o &lt; n - 1; ++o) {\r\n      const t = Ro[Io[o]],\r\n        n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;\r\n      if (t.common &amp;&amp; Math.ceil((i - e) \/ (n * t.size)) &lt;= s) return Io[o]\r\n    }\r\n    return Io[n - 1]\r\n  }\r\n\r\n  function Bo(t, e, i) {\r\n    if (i) {\r\n      if (i.length) {\r\n        const {\r\n          lo: s,\r\n          hi: n\r\n        } = et(i, e);\r\n        t[i[s] &gt;= e ? i[s] : i[n]] = !0\r\n      }\r\n    } else t[e] = !0\r\n  }\r\n\r\n  function Wo(t, e, i) {\r\n    const s = [],\r\n      n = {},\r\n      o = e.length;\r\n    let a, r;\r\n    for (a = 0; a &lt; o; ++a) r = e[a], n[r] = a, s.push({\r\n      value: r,\r\n      major: !1\r\n    });\r\n    return 0 !== o &amp;&amp; i ? function(t, e, i, s) {\r\n      const n = t._adapter,\r\n        o = +n.startOf(e[0].value, s),\r\n        a = e[e.length - 1].value;\r\n      let r, l;\r\n      for (r = o; r &lt;= a; r = +n.add(r, 1, s)) l = i[r], l &gt;= 0 &amp;&amp; (e[l].major = !0);\r\n      return e\r\n    }(t, s, n, i) : s\r\n  }\r\n  class No extends Js {\r\n    static id = &quot;time&quot;;\r\n    static defaults = {\r\n      bounds: &quot;data&quot;,\r\n      adapters: {},\r\n      time: {\r\n        parser: !1,\r\n        unit: !1,\r\n        round: !1,\r\n        isoWeekday: !1,\r\n        minUnit: &quot;millisecond&quot;,\r\n        displayFormats: {}\r\n      },\r\n      ticks: {\r\n        source: &quot;auto&quot;,\r\n        callback: !1,\r\n        major: {\r\n          enabled: !1\r\n        }\r\n      }\r\n    };\r\n    constructor(t) {\r\n      super(t), this._cache = {\r\n        data: [],\r\n        labels: [],\r\n        all: []\r\n      }, this._unit = &quot;day&quot;, this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0\r\n    }\r\n    init(t, e = {}) {\r\n      const i = t.time || (t.time = {}),\r\n        s = this._adapter = new Rn._date(t.adapters.date);\r\n      s.init(e), b(i.displayFormats, s.formats()), this._parseOpts = {\r\n        parser: i.parser,\r\n        round: i.round,\r\n        isoWeekday: i.isoWeekday\r\n      }, super.init(t), this._normalized = e.normalized\r\n    }\r\n    parse(t, e) {\r\n      return void 0 === t ? null : Fo(this, t)\r\n    }\r\n    beforeLayout() {\r\n      super.beforeLayout(), this._cache = {\r\n        data: [],\r\n        labels: [],\r\n        all: []\r\n      }\r\n    }\r\n    determineDataLimits() {\r\n      const t = this.options,\r\n        e = this._adapter,\r\n        i = t.time.unit || &quot;day&quot;;\r\n      let {\r\n        min: s,\r\n        max: n,\r\n        minDefined: o,\r\n        maxDefined: r\r\n      } = this.getUserBounds();\r\n\r\n      function l(t) {\r\n        o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max))\r\n      }\r\n      o &amp;&amp; r || (l(this._getLabelBounds()), &quot;ticks&quot; === t.bounds &amp;&amp; &quot;labels&quot; === t.ticks.source || l(this.getMinMax(!1))), s = a(s) &amp;&amp; !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) &amp;&amp; !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n)\r\n    }\r\n    _getLabelBounds() {\r\n      const t = this.getLabelTimestamps();\r\n      let e = Number.POSITIVE_INFINITY,\r\n        i = Number.NEGATIVE_INFINITY;\r\n      return t.length &amp;&amp; (e = t[0], i = t[t.length - 1]), {\r\n        min: e,\r\n        max: i\r\n      }\r\n    }\r\n    buildTicks() {\r\n      const t = this.options,\r\n        e = t.time,\r\n        i = t.ticks,\r\n        s = &quot;labels&quot; === i.source ? this.getLabelTimestamps() : this._generate();\r\n      &quot;ticks&quot; === t.bounds &amp;&amp; s.length &amp;&amp; (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);\r\n      const n = this.min,\r\n        o = nt(s, n, this.max);\r\n      return this._unit = e.unit || (i.autoSkip ? Vo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function(t, e, i, s, n) {\r\n        for (let o = Io.length - 1; o &gt;= Io.indexOf(i); o--) {\r\n          const i = Io[o];\r\n          if (Ro[i].common &amp;&amp; t._adapter.diff(n, s, i) &gt;= e - 1) return i\r\n        }\r\n        return Io[i ? Io.indexOf(i) : 0]\r\n      }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled &amp;&amp; &quot;year&quot; !== this._unit ? function(t) {\r\n        for (let e = Io.indexOf(t) + 1, i = Io.length; e &lt; i; ++e)\r\n          if (Ro[Io[e]].common) return Io[e]\r\n      }(this._unit) : void 0, this.initOffsets(s), t.reverse &amp;&amp; o.reverse(), Wo(this, o, this._majorUnit)\r\n    }\r\n    afterAutoSkip() {\r\n      this.options.offsetAfterAutoskip &amp;&amp; this.initOffsets(this.ticks.map((t =&gt; +t.value)))\r\n    }\r\n    initOffsets(t = []) {\r\n      let e, i, s = 0,\r\n        n = 0;\r\n      this.options.offset &amp;&amp; t.length &amp;&amp; (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) \/ 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) \/ 2);\r\n      const o = t.length &lt; 3 ? .5 : .25;\r\n      s = J(s, 0, o), n = J(n, 0, o), this._offsets = {\r\n        start: s,\r\n        end: n,\r\n        factor: 1 \/ (s + 1 + n)\r\n      }\r\n    }\r\n    _generate() {\r\n      const t = this._adapter,\r\n        e = this.min,\r\n        i = this.max,\r\n        s = this.options,\r\n        n = s.time,\r\n        o = n.unit || Vo(n.minUnit, e, i, this._getLabelCapacity(e)),\r\n        a = l(s.ticks.stepSize, 1),\r\n        r = &quot;week&quot; === o &amp;&amp; n.isoWeekday,\r\n        h = N(r) || !0 === r,\r\n        c = {};\r\n      let d, u, f = e;\r\n      if (h &amp;&amp; (f = +t.startOf(f, &quot;isoWeek&quot;, r)), f = +t.startOf(f, h ? &quot;day&quot; : o), t.diff(i, e, o) &gt; 1e5 * a) throw new Error(e + &quot; and &quot; + i + &quot; are too far apart with stepSize of &quot; + a + &quot; &quot; + o);\r\n      const g = &quot;data&quot; === s.ticks.source &amp;&amp; this.getDataTimestamps();\r\n      for (d = f, u = 0; d &lt; i; d = +t.add(d, a, o), u++) Bo(c, d, g);\r\n      return d !== i &amp;&amp; &quot;ticks&quot; !== s.bounds &amp;&amp; 1 !== u || Bo(c, d, g), Object.keys(c).sort(zo).map((t =&gt; +t))\r\n    }\r\n    getLabelForValue(t) {\r\n      const e = this._adapter,\r\n        i = this.options.time;\r\n      return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)\r\n    }\r\n    format(t, e) {\r\n      const i = this.options.time.displayFormats,\r\n        s = this._unit,\r\n        n = e || i[s];\r\n      return this._adapter.format(t, n)\r\n    }\r\n    _tickFormatFunction(t, e, i, s) {\r\n      const n = this.options,\r\n        o = n.ticks.callback;\r\n      if (o) return d(o, [t, e, i], this);\r\n      const a = n.time.displayFormats,\r\n        r = this._unit,\r\n        l = this._majorUnit,\r\n        h = r &amp;&amp; a[r],\r\n        c = l &amp;&amp; a[l],\r\n        u = i[e],\r\n        f = l &amp;&amp; c &amp;&amp; u &amp;&amp; u.major;\r\n      return this._adapter.format(t, s || (f ? c : h))\r\n    }\r\n    generateTickLabels(t) {\r\n      let e, i, s;\r\n      for (e = 0, i = t.length; e &lt; i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t)\r\n    }\r\n    getDecimalForValue(t) {\r\n      return null === t ? NaN : (t - this.min) \/ (this.max - this.min)\r\n    }\r\n    getPixelForValue(t) {\r\n      const e = this._offsets,\r\n        i = this.getDecimalForValue(t);\r\n      return this.getPixelForDecimal((e.start + i) * e.factor)\r\n    }\r\n    getValueForPixel(t) {\r\n      const e = this._offsets,\r\n        i = this.getDecimalForPixel(t) \/ e.factor - e.end;\r\n      return this.min + i * (this.max - this.min)\r\n    }\r\n    _getLabelSize(t) {\r\n      const e = this.options.ticks,\r\n        i = this.ctx.measureText(t).width,\r\n        s = $(this.isHorizontal() ? e.maxRotation : e.minRotation),\r\n        n = Math.cos(s),\r\n        o = Math.sin(s),\r\n        a = this._resolveTickFontOptions(0).size;\r\n      return {\r\n        w: i * n + a * o,\r\n        h: i * o + a * n\r\n      }\r\n    }\r\n    _getLabelCapacity(t) {\r\n      const e = this.options.time,\r\n        i = e.displayFormats,\r\n        s = i[e.unit] || i.millisecond,\r\n        n = this._tickFormatFunction(t, 0, Wo(this, [t], this._majorUnit), s),\r\n        o = this._getLabelSize(n),\r\n        a = Math.floor(this.isHorizontal() ? this.width \/ o.w : this.height \/ o.h) - 1;\r\n      return a &gt; 0 ? a : 1\r\n    }\r\n    getDataTimestamps() {\r\n      let t, e, i = this._cache.data || [];\r\n      if (i.length) return i;\r\n      const s = this.getMatchingVisibleMetas();\r\n      if (this._normalized &amp;&amp; s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);\r\n      for (t = 0, e = s.length; t &lt; e; ++t) i = i.concat(s[t].controller.getAllParsedValues(this));\r\n      return this._cache.data = this.normalize(i)\r\n    }\r\n    getLabelTimestamps() {\r\n      const t = this._cache.labels || [];\r\n      let e, i;\r\n      if (t.length) return t;\r\n      const s = this.getLabels();\r\n      for (e = 0, i = s.length; e &lt; i; ++e) t.push(Fo(this, s[e]));\r\n      return this._cache.labels = this._normalized ? t : this.normalize(t)\r\n    }\r\n    normalize(t) {\r\n      return lt(t.sort(zo))\r\n    }\r\n  }\r\n\r\n  function Ho(t, e, i) {\r\n    let s, n, o, a, r = 0,\r\n      l = t.length - 1;\r\n    i ? (e &gt;= t[r].pos &amp;&amp; e &lt;= t[l].pos &amp;&amp; ({\r\n      lo: r,\r\n      hi: l\r\n    } = it(t, &quot;pos&quot;, e)), ({\r\n      pos: s,\r\n      time: o\r\n    } = t[r]), ({\r\n      pos: n,\r\n      time: a\r\n    } = t[l])) : (e &gt;= t[r].time &amp;&amp; e &lt;= t[l].time &amp;&amp; ({\r\n      lo: r,\r\n      hi: l\r\n    } = it(t, &quot;time&quot;, e)), ({\r\n      time: s,\r\n      pos: o\r\n    } = t[r]), ({\r\n      time: n,\r\n      pos: a\r\n    } = t[l]));\r\n    const h = n - s;\r\n    return h ? o + (a - o) * (e - s) \/ h : o\r\n  }\r\n  var jo = Object.freeze({\r\n    __proto__: null,\r\n    CategoryScale: class extends Js {\r\n      static id = &quot;category&quot;;\r\n      static defaults = {\r\n        ticks: {\r\n          callback: po\r\n        }\r\n      };\r\n      constructor(t) {\r\n        super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []\r\n      }\r\n      init(t) {\r\n        const e = this._addedLabels;\r\n        if (e.length) {\r\n          const t = this.getLabels();\r\n          for (const {\r\n              index: i,\r\n              label: s\r\n            }\r\n            of e) t[i] === s &amp;&amp; t.splice(i, 1);\r\n          this._addedLabels = []\r\n        }\r\n        super.init(t)\r\n      }\r\n      parse(t, e) {\r\n        if (s(t)) return null;\r\n        const i = this.getLabels();\r\n        return ((t, e) =&gt; null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) &amp;&amp; i[e] === t ? e : go(i, t, l(e, t), this._addedLabels), i.length - 1)\r\n      }\r\n      determineDataLimits() {\r\n        const {\r\n          minDefined: t,\r\n          maxDefined: e\r\n        } = this.getUserBounds();\r\n        let {\r\n          min: i,\r\n          max: s\r\n        } = this.getMinMax(!0);\r\n        &quot;ticks&quot; === this.options.bounds &amp;&amp; (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s\r\n      }\r\n      buildTicks() {\r\n        const t = this.min,\r\n          e = this.max,\r\n          i = this.options.offset,\r\n          s = [];\r\n        let n = this.getLabels();\r\n        n = 0 === t &amp;&amp; e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);\r\n        for (let i = t; i &lt;= e; i++) s.push({\r\n          value: i\r\n        });\r\n        return s\r\n      }\r\n      getLabelForValue(t) {\r\n        return po.call(this, t)\r\n      }\r\n      configure() {\r\n        super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)\r\n      }\r\n      getPixelForValue(t) {\r\n        return &quot;number&quot; != typeof t &amp;&amp; (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) \/ this._valueRange)\r\n      }\r\n      getPixelForTick(t) {\r\n        const e = this.ticks;\r\n        return t &lt; 0 || t &gt; e.length - 1 ? null : this.getPixelForValue(e[t].value)\r\n      }\r\n      getValueForPixel(t) {\r\n        return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)\r\n      }\r\n      getBasePixel() {\r\n        return this.bottom\r\n      }\r\n    },\r\n    LinearScale: bo,\r\n    LogarithmicScale: ko,\r\n    RadialLinearScale: Eo,\r\n    TimeScale: No,\r\n    TimeSeriesScale: class extends No {\r\n      static id = &quot;timeseries&quot;;\r\n      static defaults = No.defaults;\r\n      constructor(t) {\r\n        super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0\r\n      }\r\n      initOffsets() {\r\n        const t = this._getTimestampsForTable(),\r\n          e = this._table = this.buildLookupTable(t);\r\n        this._minPos = Ho(e, this.min), this._tableRange = Ho(e, this.max) - this._minPos, super.initOffsets(t)\r\n      }\r\n      buildLookupTable(t) {\r\n        const {\r\n          min: e,\r\n          max: i\r\n        } = this, s = [], n = [];\r\n        let o, a, r, l, h;\r\n        for (o = 0, a = t.length; o &lt; a; ++o) l = t[o], l &gt;= e &amp;&amp; l &lt;= i &amp;&amp; s.push(l);\r\n        if (s.length &lt; 2) return [{\r\n          time: e,\r\n          pos: 0\r\n        }, {\r\n          time: i,\r\n          pos: 1\r\n        }];\r\n        for (o = 0, a = s.length; o &lt; a; ++o) h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) \/ 2) !== l &amp;&amp; n.push({\r\n          time: l,\r\n          pos: o \/ (a - 1)\r\n        });\r\n        return n\r\n      }\r\n      _generate() {\r\n        const t = this.min,\r\n          e = this.max;\r\n        let i = super.getDataTimestamps();\r\n        return i.includes(t) &amp;&amp; i.length || i.splice(0, 0, t), i.includes(e) &amp;&amp; 1 !== i.length || i.push(e), i.sort(((t, e) =&gt; t - e))\r\n      }\r\n      _getTimestampsForTable() {\r\n        let t = this._cache.all || [];\r\n        if (t.length) return t;\r\n        const e = this.getDataTimestamps(),\r\n          i = this.getLabelTimestamps();\r\n        return t = e.length &amp;&amp; i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t\r\n      }\r\n      getDecimalForValue(t) {\r\n        return (Ho(this._table, t) - this._minPos) \/ this._tableRange\r\n      }\r\n      getValueForPixel(t) {\r\n        const e = this._offsets,\r\n          i = this.getDecimalForPixel(t) \/ e.factor - e.end;\r\n        return Ho(this._table, i * this._tableRange + this._minPos, !0)\r\n      }\r\n    }\r\n  });\r\n  const $o = [&quot;rgb(54, 162, 235)&quot;, &quot;rgb(255, 99, 132)&quot;, &quot;rgb(255, 159, 64)&quot;, &quot;rgb(255, 205, 86)&quot;, &quot;rgb(75, 192, 192)&quot;, &quot;rgb(153, 102, 255)&quot;, &quot;rgb(201, 203, 207)&quot;],\r\n    Yo = $o.map((t =&gt; t.replace(&quot;rgb(&quot;, &quot;rgba(&quot;).replace(&quot;)&quot;, &quot;, 0.5)&quot;)));\r\n\r\n  function Uo(t) {\r\n    return $o[t % $o.length]\r\n  }\r\n\r\n  function Xo(t) {\r\n    return Yo[t % Yo.length]\r\n  }\r\n\r\n  function qo(t) {\r\n    let e = 0;\r\n    return (i, s) =&gt; {\r\n      const n = t.getDatasetMeta(s).controller;\r\n      n instanceof jn ? e = function(t, e) {\r\n        return t.backgroundColor = t.data.map((() =&gt; Uo(e++))), e\r\n      }(i, e) : n instanceof $n ? e = function(t, e) {\r\n        return t.backgroundColor = t.data.map((() =&gt; Xo(e++))), e\r\n      }(i, e) : n &amp;&amp; (e = function(t, e) {\r\n        return t.borderColor = Uo(e), t.backgroundColor = Xo(e), ++e\r\n      }(i, e))\r\n    }\r\n  }\r\n\r\n  function Ko(t) {\r\n    let e;\r\n    for (e in t)\r\n      if (t[e].borderColor || t[e].backgroundColor) return !0;\r\n    return !1\r\n  }\r\n  var Go = {\r\n    id: &quot;colors&quot;,\r\n    defaults: {\r\n      enabled: !0,\r\n      forceOverride: !1\r\n    },\r\n    beforeLayout(t, e, i) {\r\n      if (!i.enabled) return;\r\n      const {\r\n        data: {\r\n          datasets: s\r\n        },\r\n        options: n\r\n      } = t.config, {\r\n        elements: o\r\n      } = n;\r\n      if (!i.forceOverride &amp;&amp; (Ko(s) || (a = n) &amp;&amp; (a.borderColor || a.backgroundColor) || o &amp;&amp; Ko(o))) return;\r\n      var a;\r\n      const r = qo(t);\r\n      s.forEach(r)\r\n    }\r\n  };\r\n\r\n  function Zo(t) {\r\n    if (t._decimated) {\r\n      const e = t._data;\r\n      delete t._decimated, delete t._data, Object.defineProperty(t, &quot;data&quot;, {\r\n        configurable: !0,\r\n        enumerable: !0,\r\n        writable: !0,\r\n        value: e\r\n      })\r\n    }\r\n  }\r\n\r\n  function Jo(t) {\r\n    t.data.datasets.forEach((t =&gt; {\r\n      Zo(t)\r\n    }))\r\n  }\r\n  var Qo = {\r\n    id: &quot;decimation&quot;,\r\n    defaults: {\r\n      algorithm: &quot;min-max&quot;,\r\n      enabled: !1\r\n    },\r\n    beforeElementsUpdate: (t, e, i) =&gt; {\r\n      if (!i.enabled) return void Jo(t);\r\n      const n = t.width;\r\n      t.data.datasets.forEach(((e, o) =&gt; {\r\n        const {\r\n          _data: a,\r\n          indexAxis: r\r\n        } = e, l = t.getDatasetMeta(o), h = a || e.data;\r\n        if (&quot;y&quot; === Pi([r, t.options.indexAxis])) return;\r\n        if (!l.controller.supportsDecimation) return;\r\n        const c = t.scales[l.xAxisID];\r\n        if (&quot;linear&quot; !== c.type &amp;&amp; &quot;time&quot; !== c.type) return;\r\n        if (t.options.parsing) return;\r\n        let {\r\n          start: d,\r\n          count: u\r\n        } = function(t, e) {\r\n          const i = e.length;\r\n          let s, n = 0;\r\n          const {\r\n            iScale: o\r\n          } = t, {\r\n            min: a,\r\n            max: r,\r\n            minDefined: l,\r\n            maxDefined: h\r\n          } = o.getUserBounds();\r\n          return l &amp;&amp; (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n : i - n, {\r\n            start: n,\r\n            count: s\r\n          }\r\n        }(l, h);\r\n        if (u &lt;= (i.threshold || 4 * n)) return void Zo(e);\r\n        let f;\r\n        switch (s(a) &amp;&amp; (e._data = h, delete e.data, Object.defineProperty(e, &quot;data&quot;, {\r\n            configurable: !0,\r\n            enumerable: !0,\r\n            get: function() {\r\n              return this._decimated\r\n            },\r\n            set: function(t) {\r\n              this._data = t\r\n            }\r\n          })), i.algorithm) {\r\n          case &quot;lttb&quot;:\r\n            f = function(t, e, i, s, n) {\r\n              const o = n.samples || s;\r\n              if (o &gt;= i) return t.slice(e, e + i);\r\n              const a = [],\r\n                r = (i - 2) \/ (o - 2);\r\n              let l = 0;\r\n              const h = e + i - 1;\r\n              let c, d, u, f, g, p = e;\r\n              for (a[l++] = t[p], c = 0; c &lt; o - 2; c++) {\r\n                let s, n = 0,\r\n                  o = 0;\r\n                const h = Math.floor((c + 1) * r) + 1 + e,\r\n                  m = Math.min(Math.floor((c + 2) * r) + 1, i) + e,\r\n                  x = m - h;\r\n                for (s = h; s &lt; m; s++) n += t[s].x, o += t[s].y;\r\n                n \/= x, o \/= x;\r\n                const b = Math.floor(c * r) + 1 + e,\r\n                  _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e,\r\n                  {\r\n                    x: y,\r\n                    y: v\r\n                  } = t[p];\r\n                for (u = f = -1, s = b; s &lt; _; s++) f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f &gt; u &amp;&amp; (u = f, d = t[s], g = s);\r\n                a[l++] = d, p = g\r\n              }\r\n              return a[l++] = t[h], a\r\n            }(h, d, u, n, i);\r\n            break;\r\n          case &quot;min-max&quot;:\r\n            f = function(t, e, i, n) {\r\n              let o, a, r, l, h, c, d, u, f, g, p = 0,\r\n                m = 0;\r\n              const x = [],\r\n                b = e + i - 1,\r\n                _ = t[e].x,\r\n                y = t[b].x - _;\r\n              for (o = e; o &lt; e + i; ++o) {\r\n                a = t[o], r = (a.x - _) \/ y * n, l = a.y;\r\n                const e = 0 | r;\r\n                if (e === h) l &lt; f ? (f = l, c = o) : l &gt; g &amp;&amp; (g = l, d = o), p = (m * p + a.x) \/ ++m;\r\n                else {\r\n                  const i = o - 1;\r\n                  if (!s(c) &amp;&amp; !s(d)) {\r\n                    const e = Math.min(c, d),\r\n                      s = Math.max(c, d);\r\n                    e !== u &amp;&amp; e !== i &amp;&amp; x.push({\r\n                      ...t[e],\r\n                      x: p\r\n                    }), s !== u &amp;&amp; s !== i &amp;&amp; x.push({\r\n                      ...t[s],\r\n                      x: p\r\n                    })\r\n                  }\r\n                  o &gt; 0 &amp;&amp; i !== u &amp;&amp; x.push(t[i]), x.push(a), h = e, m = 0, f = g = l, c = d = u = o\r\n                }\r\n              }\r\n              return x\r\n            }(h, d, u, n);\r\n            break;\r\n          default:\r\n            throw new Error(`Unsupported decimation algorithm &#039;${i.algorithm}&#039;`)\r\n        }\r\n        e._decimated = f\r\n      }))\r\n    },\r\n    destroy(t) {\r\n      Jo(t)\r\n    }\r\n  };\r\n\r\n  function ta(t, e, i, s) {\r\n    if (s) return;\r\n    let n = e[t],\r\n      o = i[t];\r\n    return &quot;angle&quot; === t &amp;&amp; (n = G(n), o = G(o)), {\r\n      property: t,\r\n      start: n,\r\n      end: o\r\n    }\r\n  }\r\n\r\n  function ea(t, e, i) {\r\n    for (; e &gt; t; e--) {\r\n      const t = i[e];\r\n      if (!isNaN(t.x) &amp;&amp; !isNaN(t.y)) break\r\n    }\r\n    return e\r\n  }\r\n\r\n  function ia(t, e, i, s) {\r\n    return t &amp;&amp; e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0\r\n  }\r\n\r\n  function sa(t, e) {\r\n    let i = [],\r\n      s = !1;\r\n    return n(t) ? (s = !0, i = t) : i = function(t, e) {\r\n      const {\r\n        x: i = null,\r\n        y: s = null\r\n      } = t || {}, n = e.points, o = [];\r\n      return e.segments.forEach((({\r\n        start: t,\r\n        end: e\r\n      }) =&gt; {\r\n        e = ea(t, e, n);\r\n        const a = n[t],\r\n          r = n[e];\r\n        null !== s ? (o.push({\r\n          x: a.x,\r\n          y: s\r\n        }), o.push({\r\n          x: r.x,\r\n          y: s\r\n        })) : null !== i &amp;&amp; (o.push({\r\n          x: i,\r\n          y: a.y\r\n        }), o.push({\r\n          x: i,\r\n          y: r.y\r\n        }))\r\n      })), o\r\n    }(t, e), i.length ? new no({\r\n      points: i,\r\n      options: {\r\n        tension: 0\r\n      },\r\n      _loop: s,\r\n      _fullLoop: s\r\n    }) : null\r\n  }\r\n\r\n  function na(t) {\r\n    return t &amp;&amp; !1 !== t.fill\r\n  }\r\n\r\n  function oa(t, e, i) {\r\n    let s = t[e].fill;\r\n    const n = [e];\r\n    let o;\r\n    if (!i) return s;\r\n    for (; !1 !== s &amp;&amp; -1 === n.indexOf(s);) {\r\n      if (!a(s)) return s;\r\n      if (o = t[s], !o) return !1;\r\n      if (o.visible) return s;\r\n      n.push(s), s = o.fill\r\n    }\r\n    return !1\r\n  }\r\n\r\n  function aa(t, e, i) {\r\n    const s = function(t) {\r\n      const e = t.options,\r\n        i = e.fill;\r\n      let s = l(i &amp;&amp; i.target, i);\r\n      void 0 === s &amp;&amp; (s = !!e.backgroundColor);\r\n      if (!1 === s || null === s) return !1;\r\n      if (!0 === s) return &quot;origin&quot;;\r\n      return s\r\n    }(t);\r\n    if (o(s)) return !isNaN(s.value) &amp;&amp; s;\r\n    let n = parseFloat(s);\r\n    return a(n) &amp;&amp; Math.floor(n) === n ? function(t, e, i, s) {\r\n      &quot;-&quot; !== t &amp;&amp; &quot;+&quot; !== t || (i = e + i);\r\n      if (i === e || i &lt; 0 || i &gt;= s) return !1;\r\n      return i\r\n    }(s[0], e, n, i) : [&quot;origin&quot;, &quot;start&quot;, &quot;end&quot;, &quot;stack&quot;, &quot;shape&quot;].indexOf(s) &gt;= 0 &amp;&amp; s\r\n  }\r\n\r\n  function ra(t, e, i) {\r\n    const s = [];\r\n    for (let n = 0; n &lt; i.length; n++) {\r\n      const o = i[n],\r\n        {\r\n          first: a,\r\n          last: r,\r\n          point: l\r\n        } = la(o, e, &quot;x&quot;);\r\n      if (!(!l || a &amp;&amp; r))\r\n        if (a) s.unshift(l);\r\n        else if (t.push(l), !r) break\r\n    }\r\n    t.push(...s)\r\n  }\r\n\r\n  function la(t, e, i) {\r\n    const s = t.interpolate(e, i);\r\n    if (!s) return {};\r\n    const n = s[i],\r\n      o = t.segments,\r\n      a = t.points;\r\n    let r = !1,\r\n      l = !1;\r\n    for (let t = 0; t &lt; o.length; t++) {\r\n      const e = o[t],\r\n        s = a[e.start][i],\r\n        h = a[e.end][i];\r\n      if (tt(n, s, h)) {\r\n        r = n === s, l = n === h;\r\n        break\r\n      }\r\n    }\r\n    return {\r\n      first: r,\r\n      last: l,\r\n      point: s\r\n    }\r\n  }\r\n  class ha {\r\n    constructor(t) {\r\n      this.x = t.x, this.y = t.y, this.radius = t.radius\r\n    }\r\n    pathSegment(t, e, i) {\r\n      const {\r\n        x: s,\r\n        y: n,\r\n        radius: o\r\n      } = this;\r\n      return e = e || {\r\n        start: 0,\r\n        end: O\r\n      }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds\r\n    }\r\n    interpolate(t) {\r\n      const {\r\n        x: e,\r\n        y: i,\r\n        radius: s\r\n      } = this, n = t.angle;\r\n      return {\r\n        x: e + Math.cos(n) * s,\r\n        y: i + Math.sin(n) * s,\r\n        angle: n\r\n      }\r\n    }\r\n  }\r\n\r\n  function ca(t) {\r\n    const {\r\n      chart: e,\r\n      fill: i,\r\n      line: s\r\n    } = t;\r\n    if (a(i)) return function(t, e) {\r\n      const i = t.getDatasetMeta(e),\r\n        s = i &amp;&amp; t.isDatasetVisible(e);\r\n      return s ? i.dataset : null\r\n    }(e, i);\r\n    if (&quot;stack&quot; === i) return function(t) {\r\n      const {\r\n        scale: e,\r\n        index: i,\r\n        line: s\r\n      } = t, n = [], o = s.segments, a = s.points, r = function(t, e) {\r\n        const i = [],\r\n          s = t.getMatchingVisibleMetas(&quot;line&quot;);\r\n        for (let t = 0; t &lt; s.length; t++) {\r\n          const n = s[t];\r\n          if (n.index === e) break;\r\n          n.hidden || i.unshift(n.dataset)\r\n        }\r\n        return i\r\n      }(e, i);\r\n      r.push(sa({\r\n        x: null,\r\n        y: e.bottom\r\n      }, s));\r\n      for (let t = 0; t &lt; o.length; t++) {\r\n        const e = o[t];\r\n        for (let t = e.start; t &lt;= e.end; t++) ra(n, a[t], r)\r\n      }\r\n      return new no({\r\n        points: n,\r\n        options: {}\r\n      })\r\n    }(t);\r\n    if (&quot;shape&quot; === i) return !0;\r\n    const n = function(t) {\r\n      const e = t.scale || {};\r\n      if (e.getPointPositionForValue) return function(t) {\r\n        const {\r\n          scale: e,\r\n          fill: i\r\n        } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function(t, e, i) {\r\n          let s;\r\n          return s = &quot;start&quot; === t ? i : &quot;end&quot; === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s\r\n        }(i, e, a), l = [];\r\n        if (s.grid.circular) {\r\n          const t = e.getPointPositionForValue(0, a);\r\n          return new ha({\r\n            x: t.x,\r\n            y: t.y,\r\n            radius: e.getDistanceFromCenterForValue(r)\r\n          })\r\n        }\r\n        for (let t = 0; t &lt; n; ++t) l.push(e.getPointPositionForValue(t, r));\r\n        return l\r\n      }(t);\r\n      return function(t) {\r\n        const {\r\n          scale: e = {},\r\n          fill: i\r\n        } = t, s = function(t, e) {\r\n          let i = null;\r\n          return &quot;start&quot; === t ? i = e.bottom : &quot;end&quot; === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel &amp;&amp; (i = e.getBasePixel()), i\r\n        }(i, e);\r\n        if (a(s)) {\r\n          const t = e.isHorizontal();\r\n          return {\r\n            x: t ? s : null,\r\n            y: t ? null : s\r\n          }\r\n        }\r\n        return null\r\n      }(t)\r\n    }(t);\r\n    return n instanceof ha ? n : sa(n, s)\r\n  }\r\n\r\n  function da(t, e, i) {\r\n    const s = ca(e),\r\n      {\r\n        line: n,\r\n        scale: o,\r\n        axis: a\r\n      } = e,\r\n      r = n.options,\r\n      l = r.fill,\r\n      h = r.backgroundColor,\r\n      {\r\n        above: c = h,\r\n        below: d = h\r\n      } = l || {};\r\n    s &amp;&amp; n.points.length &amp;&amp; (Ie(t, i), function(t, e) {\r\n      const {\r\n        line: i,\r\n        target: s,\r\n        above: n,\r\n        below: o,\r\n        area: a,\r\n        scale: r\r\n      } = e, l = i._loop ? &quot;angle&quot; : e.axis;\r\n      t.save(), &quot;x&quot; === l &amp;&amp; o !== n &amp;&amp; (ua(t, s, a.top), fa(t, {\r\n        line: i,\r\n        target: s,\r\n        color: n,\r\n        scale: r,\r\n        property: l\r\n      }), t.restore(), t.save(), ua(t, s, a.bottom));\r\n      fa(t, {\r\n        line: i,\r\n        target: s,\r\n        color: o,\r\n        scale: r,\r\n        property: l\r\n      }), t.restore()\r\n    }(t, {\r\n      line: n,\r\n      target: s,\r\n      above: c,\r\n      below: d,\r\n      area: i,\r\n      scale: o,\r\n      axis: a\r\n    }), ze(t))\r\n  }\r\n\r\n  function ua(t, e, i) {\r\n    const {\r\n      segments: s,\r\n      points: n\r\n    } = e;\r\n    let o = !0,\r\n      a = !1;\r\n    t.beginPath();\r\n    for (const r of s) {\r\n      const {\r\n        start: s,\r\n        end: l\r\n      } = r, h = n[s], c = n[ea(s, l, n)];\r\n      o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {\r\n        move: a\r\n      }), a ? t.closePath() : t.lineTo(c.x, i)\r\n    }\r\n    t.lineTo(e.first().x, i), t.closePath(), t.clip()\r\n  }\r\n\r\n  function fa(t, e) {\r\n    const {\r\n      line: i,\r\n      target: s,\r\n      property: n,\r\n      color: o,\r\n      scale: a\r\n    } = e, r = function(t, e, i) {\r\n      const s = t.segments,\r\n        n = t.points,\r\n        o = e.points,\r\n        a = [];\r\n      for (const t of s) {\r\n        let {\r\n          start: s,\r\n          end: r\r\n        } = t;\r\n        r = ea(s, r, n);\r\n        const l = ta(i, n[s], n[r], t.loop);\r\n        if (!e.segments) {\r\n          a.push({\r\n            source: t,\r\n            target: l,\r\n            start: n[s],\r\n            end: n[r]\r\n          });\r\n          continue\r\n        }\r\n        const h = Ii(e, l);\r\n        for (const e of h) {\r\n          const s = ta(i, o[e.start], o[e.end], e.loop),\r\n            r = Ri(t, n, s);\r\n          for (const t of r) a.push({\r\n            source: t,\r\n            target: e,\r\n            start: {\r\n              [i]: ia(l, s, &quot;start&quot;, Math.max)\r\n            },\r\n            end: {\r\n              [i]: ia(l, s, &quot;end&quot;, Math.min)\r\n            }\r\n          })\r\n        }\r\n      }\r\n      return a\r\n    }(i, s, n);\r\n    for (const {\r\n        source: e,\r\n        target: l,\r\n        start: h,\r\n        end: c\r\n      }\r\n      of r) {\r\n      const {\r\n        style: {\r\n          backgroundColor: r = o\r\n        } = {}\r\n      } = e, d = !0 !== s;\r\n      t.save(), t.fillStyle = r, ga(t, a, d &amp;&amp; ta(n, h, c)), t.beginPath();\r\n      const u = !!i.pathSegment(t, e);\r\n      let f;\r\n      if (d) {\r\n        u ? t.closePath() : pa(t, s, c, n);\r\n        const e = !!s.pathSegment(t, l, {\r\n          move: u,\r\n          reverse: !0\r\n        });\r\n        f = u &amp;&amp; e, f || pa(t, s, h, n)\r\n      }\r\n      t.closePath(), t.fill(f ? &quot;evenodd&quot; : &quot;nonzero&quot;), t.restore()\r\n    }\r\n  }\r\n\r\n  function ga(t, e, i) {\r\n    const {\r\n      top: s,\r\n      bottom: n\r\n    } = e.chart.chartArea, {\r\n      property: o,\r\n      start: a,\r\n      end: r\r\n    } = i || {};\r\n    &quot;x&quot; === o &amp;&amp; (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip())\r\n  }\r\n\r\n  function pa(t, e, i, s) {\r\n    const n = e.interpolate(i, s);\r\n    n &amp;&amp; t.lineTo(n.x, n.y)\r\n  }\r\n  var ma = {\r\n    id: &quot;filler&quot;,\r\n    afterDatasetsUpdate(t, e, i) {\r\n      const s = (t.data.datasets || []).length,\r\n        n = [];\r\n      let o, a, r, l;\r\n      for (a = 0; a &lt; s; ++a) o = t.getDatasetMeta(a), r = o.dataset, l = null, r &amp;&amp; r.options &amp;&amp; r instanceof no &amp;&amp; (l = {\r\n        visible: t.isDatasetVisible(a),\r\n        index: a,\r\n        fill: aa(r, a, s),\r\n        chart: t,\r\n        axis: o.controller.options.indexAxis,\r\n        scale: o.vScale,\r\n        line: r\r\n      }), o.$filler = l, n.push(l);\r\n      for (a = 0; a &lt; s; ++a) l = n[a], l &amp;&amp; !1 !== l.fill &amp;&amp; (l.fill = oa(n, a, i.propagate))\r\n    },\r\n    beforeDraw(t, e, i) {\r\n      const s = &quot;beforeDraw&quot; === i.drawTime,\r\n        n = t.getSortedVisibleDatasetMetas(),\r\n        o = t.chartArea;\r\n      for (let e = n.length - 1; e &gt;= 0; --e) {\r\n        const i = n[e].$filler;\r\n        i &amp;&amp; (i.line.updateControlPoints(o, i.axis), s &amp;&amp; i.fill &amp;&amp; da(t.ctx, i, o))\r\n      }\r\n    },\r\n    beforeDatasetsDraw(t, e, i) {\r\n      if (&quot;beforeDatasetsDraw&quot; !== i.drawTime) return;\r\n      const s = t.getSortedVisibleDatasetMetas();\r\n      for (let e = s.length - 1; e &gt;= 0; --e) {\r\n        const i = s[e].$filler;\r\n        na(i) &amp;&amp; da(t.ctx, i, t.chartArea)\r\n      }\r\n    },\r\n    beforeDatasetDraw(t, e, i) {\r\n      const s = e.meta.$filler;\r\n      na(s) &amp;&amp; &quot;beforeDatasetDraw&quot; === i.drawTime &amp;&amp; da(t.ctx, s, t.chartArea)\r\n    },\r\n    defaults: {\r\n      propagate: !0,\r\n      drawTime: &quot;beforeDatasetDraw&quot;\r\n    }\r\n  };\r\n  const xa = (t, e) =&gt; {\r\n    let {\r\n      boxHeight: i = e,\r\n      boxWidth: s = e\r\n    } = t;\r\n    return t.usePointStyle &amp;&amp; (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {\r\n      boxWidth: s,\r\n      boxHeight: i,\r\n      itemHeight: Math.max(e, i)\r\n    }\r\n  };\r\n  class ba extends Hs {\r\n    constructor(t) {\r\n      super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0\r\n    }\r\n    update(t, e, i) {\r\n      this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit()\r\n    }\r\n    setDimensions() {\r\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)\r\n    }\r\n    buildLabels() {\r\n      const t = this.options.labels || {};\r\n      let e = d(t.generateLabels, [this.chart], this) || [];\r\n      t.filter &amp;&amp; (e = e.filter((e =&gt; t.filter(e, this.chart.data)))), t.sort &amp;&amp; (e = e.sort(((e, i) =&gt; t.sort(e, i, this.chart.data)))), this.options.reverse &amp;&amp; e.reverse(), this.legendItems = e\r\n    }\r\n    fit() {\r\n      const {\r\n        options: t,\r\n        ctx: e\r\n      } = this;\r\n      if (!t.display) return void(this.width = this.height = 0);\r\n      const i = t.labels,\r\n        s = Si(i.font),\r\n        n = s.size,\r\n        o = this._computeTitleHeight(),\r\n        {\r\n          boxWidth: a,\r\n          itemHeight: r\r\n        } = xa(i, n);\r\n      let l, h;\r\n      e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight)\r\n    }\r\n    _fitRows(t, e, i, s) {\r\n      const {\r\n        ctx: n,\r\n        maxWidth: o,\r\n        options: {\r\n          labels: {\r\n            padding: a\r\n          }\r\n        }\r\n      } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [0], h = s + a;\r\n      let c = t;\r\n      n.textAlign = &quot;left&quot;, n.textBaseline = &quot;middle&quot;;\r\n      let d = -1,\r\n        u = -h;\r\n      return this.legendItems.forEach(((t, f) =&gt; {\r\n        const g = i + e \/ 2 + n.measureText(t.text).width;\r\n        (0 === f || l[l.length - 1] + g + 2 * a &gt; o) &amp;&amp; (c += h, l[l.length - (f &gt; 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {\r\n          left: 0,\r\n          top: u,\r\n          row: d,\r\n          width: g,\r\n          height: s\r\n        }, l[l.length - 1] += g + a\r\n      })), c\r\n    }\r\n    _fitCols(t, e, i, s) {\r\n      const {\r\n        ctx: n,\r\n        maxHeight: o,\r\n        options: {\r\n          labels: {\r\n            padding: a\r\n          }\r\n        }\r\n      } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;\r\n      let c = a,\r\n        d = 0,\r\n        u = 0,\r\n        f = 0,\r\n        g = 0;\r\n      return this.legendItems.forEach(((t, o) =&gt; {\r\n        const {\r\n          itemWidth: p,\r\n          itemHeight: m\r\n        } = function(t, e, i, s, n) {\r\n          const o = function(t, e, i, s) {\r\n              let n = t.text;\r\n              n &amp;&amp; &quot;string&quot; != typeof n &amp;&amp; (n = n.reduce(((t, e) =&gt; t.length &gt; e.length ? t : e)));\r\n              return e + i.size \/ 2 + s.measureText(n).width\r\n            }(s, t, e, i),\r\n            a = function(t, e, i) {\r\n              let s = t;\r\n              &quot;string&quot; != typeof e.text &amp;&amp; (s = _a(e, i));\r\n              return s\r\n            }(n, s, e.lineHeight);\r\n          return {\r\n            itemWidth: o,\r\n            itemHeight: a\r\n          }\r\n        }(i, e, n, t, s);\r\n        o &gt; 0 &amp;&amp; u + m + 2 * a &gt; h &amp;&amp; (c += d + a, l.push({\r\n          width: d,\r\n          height: u\r\n        }), f += d + a, g++, d = u = 0), r[o] = {\r\n          left: f,\r\n          top: u,\r\n          col: g,\r\n          width: p,\r\n          height: m\r\n        }, d = Math.max(d, p), u += m + a\r\n      })), c += d, l.push({\r\n        width: d,\r\n        height: u\r\n      }), c\r\n    }\r\n    adjustHitBoxes() {\r\n      if (!this.options.display) return;\r\n      const t = this._computeTitleHeight(),\r\n        {\r\n          legendHitBoxes: e,\r\n          options: {\r\n            align: i,\r\n            labels: {\r\n              padding: s\r\n            },\r\n            rtl: n\r\n          }\r\n        } = this,\r\n        o = Oi(n, this.left, this.width);\r\n      if (this.isHorizontal()) {\r\n        let n = 0,\r\n          a = ft(i, this.left + s, this.right - this.lineWidths[n]);\r\n        for (const r of e) n !== r.row &amp;&amp; (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s\r\n      } else {\r\n        let n = 0,\r\n          a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height);\r\n        for (const r of e) r.col !== n &amp;&amp; (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s\r\n      }\r\n    }\r\n    isHorizontal() {\r\n      return &quot;top&quot; === this.options.position || &quot;bottom&quot; === this.options.position\r\n    }\r\n    draw() {\r\n      if (this.options.display) {\r\n        const t = this.ctx;\r\n        Ie(t, this), this._draw(), ze(t)\r\n      }\r\n    }\r\n    _draw() {\r\n      const {\r\n        options: t,\r\n        columnSizes: e,\r\n        lineWidths: i,\r\n        ctx: s\r\n      } = this, {\r\n        align: n,\r\n        labels: o\r\n      } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), {\r\n        padding: c\r\n      } = o, d = h.size, u = d \/ 2;\r\n      let f;\r\n      this.drawTitle(), s.textAlign = r.textAlign(&quot;left&quot;), s.textBaseline = &quot;middle&quot;, s.lineWidth = .5, s.font = h.string;\r\n      const {\r\n        boxWidth: g,\r\n        boxHeight: p,\r\n        itemHeight: m\r\n      } = xa(o, d), x = this.isHorizontal(), b = this._computeTitleHeight();\r\n      f = x ? {\r\n        x: ft(n, this.left + c, this.right - i[0]),\r\n        y: this.top + c + b,\r\n        line: 0\r\n      } : {\r\n        x: this.left + c,\r\n        y: ft(n, this.top + b + c, this.bottom - e[0].height),\r\n        line: 0\r\n      }, Ai(this.ctx, t.textDirection);\r\n      const _ = m + c;\r\n      this.legendItems.forEach(((y, v) =&gt; {\r\n        s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor;\r\n        const M = s.measureText(y.text).width,\r\n          w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)),\r\n          k = g + u + M;\r\n        let S = f.x,\r\n          P = f.y;\r\n        r.setWidth(this.width), x ? v &gt; 0 &amp;&amp; S + k + c &gt; this.right &amp;&amp; (P = f.y += _, f.line++, S = f.x = ft(n, this.left + c, this.right - i[f.line])) : v &gt; 0 &amp;&amp; P + _ &gt; this.bottom &amp;&amp; (S = f.x = S + e[f.line].width + c, f.line++, P = f.y = ft(n, this.top + b + c, this.bottom - e[f.line].height));\r\n        if (function(t, e, i) {\r\n            if (isNaN(g) || g &lt;= 0 || isNaN(p) || p &lt; 0) return;\r\n            s.save();\r\n            const n = l(i.lineWidth, 1);\r\n            if (s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, &quot;butt&quot;), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, &quot;miter&quot;), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle) {\r\n              const a = {\r\n                  radius: p * Math.SQRT2 \/ 2,\r\n                  pointStyle: i.pointStyle,\r\n                  rotation: i.rotation,\r\n                  borderWidth: n\r\n                },\r\n                l = r.xPlus(t, g \/ 2);\r\n              Ee(s, a, l, e + u, o.pointStyleWidth &amp;&amp; g)\r\n            } else {\r\n              const o = e + Math.max((d - p) \/ 2, 0),\r\n                a = r.leftForLtr(t, g),\r\n                l = wi(i.borderRadius);\r\n              s.beginPath(), Object.values(l).some((t =&gt; 0 !== t)) ? He(s, {\r\n                x: a,\r\n                y: o,\r\n                w: g,\r\n                h: p,\r\n                radius: l\r\n              }) : s.rect(a, o, g, p), s.fill(), 0 !== n &amp;&amp; s.stroke()\r\n            }\r\n            s.restore()\r\n          }(r.x(S), P, y), S = gt(w, S + g + u, x ? S + k : this.right, t.rtl), function(t, e, i) {\r\n            Ne(s, i.text, t, e + m \/ 2, h, {\r\n              strikethrough: i.hidden,\r\n              textAlign: r.textAlign(i.textAlign)\r\n            })\r\n          }(r.x(S), P, y), x) f.x += k + c;\r\n        else if (&quot;string&quot; != typeof y.text) {\r\n          const t = h.lineHeight;\r\n          f.y += _a(y, t) + c\r\n        } else f.y += _\r\n      })), Ti(this.ctx, t.textDirection)\r\n    }\r\n    drawTitle() {\r\n      const t = this.options,\r\n        e = t.title,\r\n        i = Si(e.font),\r\n        s = ki(e.padding);\r\n      if (!e.display) return;\r\n      const n = Oi(t.rtl, this.left, this.width),\r\n        o = this.ctx,\r\n        a = e.position,\r\n        r = i.size \/ 2,\r\n        l = s.top + r;\r\n      let h, c = this.left,\r\n        d = this.width;\r\n      if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);\r\n      else {\r\n        const e = this.columnSizes.reduce(((t, e) =&gt; Math.max(t, e.height)), 0);\r\n        h = l + ft(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight())\r\n      }\r\n      const u = ft(a, c, c + d);\r\n      o.textAlign = n.textAlign(ut(a)), o.textBaseline = &quot;middle&quot;, o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i)\r\n    }\r\n    _computeTitleHeight() {\r\n      const t = this.options.title,\r\n        e = Si(t.font),\r\n        i = ki(t.padding);\r\n      return t.display ? e.lineHeight + i.height : 0\r\n    }\r\n    _getLegendItemAt(t, e) {\r\n      let i, s, n;\r\n      if (tt(t, this.left, this.right) &amp;&amp; tt(e, this.top, this.bottom))\r\n        for (n = this.legendHitBoxes, i = 0; i &lt; n.length; ++i)\r\n          if (s = n[i], tt(t, s.left, s.left + s.width) &amp;&amp; tt(e, s.top, s.top + s.height)) return this.legendItems[i];\r\n      return null\r\n    }\r\n    handleEvent(t) {\r\n      const e = this.options;\r\n      if (! function(t, e) {\r\n          if ((&quot;mousemove&quot; === t || &quot;mouseout&quot; === t) &amp;&amp; (e.onHover || e.onLeave)) return !0;\r\n          if (e.onClick &amp;&amp; (&quot;click&quot; === t || &quot;mouseup&quot; === t)) return !0;\r\n          return !1\r\n        }(t.type, e)) return;\r\n      const i = this._getLegendItemAt(t.x, t.y);\r\n      if (&quot;mousemove&quot; === t.type || &quot;mouseout&quot; === t.type) {\r\n        const o = this._hoveredItem,\r\n          a = (n = i, null !== (s = o) &amp;&amp; null !== n &amp;&amp; s.datasetIndex === n.datasetIndex &amp;&amp; s.index === n.index);\r\n        o &amp;&amp; !a &amp;&amp; d(e.onLeave, [t, o, this], this), this._hoveredItem = i, i &amp;&amp; !a &amp;&amp; d(e.onHover, [t, i, this], this)\r\n      } else i &amp;&amp; d(e.onClick, [t, i, this], this);\r\n      var s, n\r\n    }\r\n  }\r\n\r\n  function _a(t, e) {\r\n    return e * (t.text ? t.text.length : 0)\r\n  }\r\n  var ya = {\r\n    id: &quot;legend&quot;,\r\n    _element: ba,\r\n    start(t, e, i) {\r\n      const s = t.legend = new ba({\r\n        ctx: t.ctx,\r\n        options: i,\r\n        chart: t\r\n      });\r\n      as.configure(t, s, i), as.addBox(t, s)\r\n    },\r\n    stop(t) {\r\n      as.removeBox(t, t.legend), delete t.legend\r\n    },\r\n    beforeUpdate(t, e, i) {\r\n      const s = t.legend;\r\n      as.configure(t, s, i), s.options = i\r\n    },\r\n    afterUpdate(t) {\r\n      const e = t.legend;\r\n      e.buildLabels(), e.adjustHitBoxes()\r\n    },\r\n    afterEvent(t, e) {\r\n      e.replay || t.legend.handleEvent(e.event)\r\n    },\r\n    defaults: {\r\n      display: !0,\r\n      position: &quot;top&quot;,\r\n      align: &quot;center&quot;,\r\n      fullSize: !0,\r\n      reverse: !1,\r\n      weight: 1e3,\r\n      onClick(t, e, i) {\r\n        const s = e.datasetIndex,\r\n          n = i.chart;\r\n        n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1)\r\n      },\r\n      onHover: null,\r\n      onLeave: null,\r\n      labels: {\r\n        color: t =&gt; t.chart.options.color,\r\n        boxWidth: 40,\r\n        padding: 10,\r\n        generateLabels(t) {\r\n          const e = t.data.datasets,\r\n            {\r\n              labels: {\r\n                usePointStyle: i,\r\n                pointStyle: s,\r\n                textAlign: n,\r\n                color: o,\r\n                useBorderRadius: a,\r\n                borderRadius: r\r\n              }\r\n            } = t.legend.options;\r\n          return t._getSortedDatasetMetas().map((t =&gt; {\r\n            const l = t.controller.getStyle(i ? 0 : void 0),\r\n              h = ki(l.borderWidth);\r\n            return {\r\n              text: e[t.index].label,\r\n              fillStyle: l.backgroundColor,\r\n              fontColor: o,\r\n              hidden: !t.visible,\r\n              lineCap: l.borderCapStyle,\r\n              lineDash: l.borderDash,\r\n              lineDashOffset: l.borderDashOffset,\r\n              lineJoin: l.borderJoinStyle,\r\n              lineWidth: (h.width + h.height) \/ 4,\r\n              strokeStyle: l.borderColor,\r\n              pointStyle: s || l.pointStyle,\r\n              rotation: l.rotation,\r\n              textAlign: n || l.textAlign,\r\n              borderRadius: a &amp;&amp; (r || l.borderRadius),\r\n              datasetIndex: t.index\r\n            }\r\n          }), this)\r\n        }\r\n      },\r\n      title: {\r\n        color: t =&gt; t.chart.options.color,\r\n        display: !1,\r\n        position: &quot;center&quot;,\r\n        text: &quot;&quot;\r\n      }\r\n    },\r\n    descriptors: {\r\n      _scriptable: t =&gt; !t.startsWith(&quot;on&quot;),\r\n      labels: {\r\n        _scriptable: t =&gt; ![&quot;generateLabels&quot;, &quot;filter&quot;, &quot;sort&quot;].includes(t)\r\n      }\r\n    }\r\n  };\r\n  class va extends Hs {\r\n    constructor(t) {\r\n      super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0\r\n    }\r\n    update(t, e) {\r\n      const i = this.options;\r\n      if (this.left = 0, this.top = 0, !i.display) return void(this.width = this.height = this.right = this.bottom = 0);\r\n      this.width = this.right = t, this.height = this.bottom = e;\r\n      const s = n(i.text) ? i.text.length : 1;\r\n      this._padding = ki(i.padding);\r\n      const o = s * Si(i.font).lineHeight + this._padding.height;\r\n      this.isHorizontal() ? this.height = o : this.width = o\r\n    }\r\n    isHorizontal() {\r\n      const t = this.options.position;\r\n      return &quot;top&quot; === t || &quot;bottom&quot; === t\r\n    }\r\n    _drawArgs(t) {\r\n      const {\r\n        top: e,\r\n        left: i,\r\n        bottom: s,\r\n        right: n,\r\n        options: o\r\n      } = this, a = o.align;\r\n      let r, l, h, c = 0;\r\n      return this.isHorizontal() ? (l = ft(a, i, n), h = e + t, r = n - i) : (&quot;left&quot; === o.position ? (l = i + t, h = ft(a, s, e), c = -.5 * C) : (l = n - t, h = ft(a, e, s), c = .5 * C), r = s - e), {\r\n        titleX: l,\r\n        titleY: h,\r\n        maxWidth: r,\r\n        rotation: c\r\n      }\r\n    }\r\n    draw() {\r\n      const t = this.ctx,\r\n        e = this.options;\r\n      if (!e.display) return;\r\n      const i = Si(e.font),\r\n        s = i.lineHeight \/ 2 + this._padding.top,\r\n        {\r\n          titleX: n,\r\n          titleY: o,\r\n          maxWidth: a,\r\n          rotation: r\r\n        } = this._drawArgs(s);\r\n      Ne(t, e.text, 0, 0, i, {\r\n        color: e.color,\r\n        maxWidth: a,\r\n        rotation: r,\r\n        textAlign: ut(e.align),\r\n        textBaseline: &quot;middle&quot;,\r\n        translation: [n, o]\r\n      })\r\n    }\r\n  }\r\n  var Ma = {\r\n    id: &quot;title&quot;,\r\n    _element: va,\r\n    start(t, e, i) {\r\n      ! function(t, e) {\r\n        const i = new va({\r\n          ctx: t.ctx,\r\n          options: e,\r\n          chart: t\r\n        });\r\n        as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i\r\n      }(t, i)\r\n    },\r\n    stop(t) {\r\n      const e = t.titleBlock;\r\n      as.removeBox(t, e), delete t.titleBlock\r\n    },\r\n    beforeUpdate(t, e, i) {\r\n      const s = t.titleBlock;\r\n      as.configure(t, s, i), s.options = i\r\n    },\r\n    defaults: {\r\n      align: &quot;center&quot;,\r\n      display: !1,\r\n      font: {\r\n        weight: &quot;bold&quot;\r\n      },\r\n      fullSize: !0,\r\n      padding: 10,\r\n      position: &quot;top&quot;,\r\n      text: &quot;&quot;,\r\n      weight: 2e3\r\n    },\r\n    defaultRoutes: {\r\n      color: &quot;color&quot;\r\n    },\r\n    descriptors: {\r\n      _scriptable: !0,\r\n      _indexable: !1\r\n    }\r\n  };\r\n  const wa = new WeakMap;\r\n  var ka = {\r\n    id: &quot;subtitle&quot;,\r\n    start(t, e, i) {\r\n      const s = new va({\r\n        ctx: t.ctx,\r\n        options: i,\r\n        chart: t\r\n      });\r\n      as.configure(t, s, i), as.addBox(t, s), wa.set(t, s)\r\n    },\r\n    stop(t) {\r\n      as.removeBox(t, wa.get(t)), wa.delete(t)\r\n    },\r\n    beforeUpdate(t, e, i) {\r\n      const s = wa.get(t);\r\n      as.configure(t, s, i), s.options = i\r\n    },\r\n    defaults: {\r\n      align: &quot;center&quot;,\r\n      display: !1,\r\n      font: {\r\n        weight: &quot;normal&quot;\r\n      },\r\n      fullSize: !0,\r\n      padding: 0,\r\n      position: &quot;top&quot;,\r\n      text: &quot;&quot;,\r\n      weight: 1500\r\n    },\r\n    defaultRoutes: {\r\n      color: &quot;color&quot;\r\n    },\r\n    descriptors: {\r\n      _scriptable: !0,\r\n      _indexable: !1\r\n    }\r\n  };\r\n  const Sa = {\r\n    average(t) {\r\n      if (!t.length) return !1;\r\n      let e, i, s = new Set,\r\n        n = 0,\r\n        o = 0;\r\n      for (e = 0, i = t.length; e &lt; i; ++e) {\r\n        const i = t[e].element;\r\n        if (i &amp;&amp; i.hasValue()) {\r\n          const t = i.tooltipPosition();\r\n          s.add(t.x), n += t.y, ++o\r\n        }\r\n      }\r\n      return {\r\n        x: [...s].reduce(((t, e) =&gt; t + e)) \/ s.size,\r\n        y: n \/ o\r\n      }\r\n    },\r\n    nearest(t, e) {\r\n      if (!t.length) return !1;\r\n      let i, s, n, o = e.x,\r\n        a = e.y,\r\n        r = Number.POSITIVE_INFINITY;\r\n      for (i = 0, s = t.length; i &lt; s; ++i) {\r\n        const s = t[i].element;\r\n        if (s &amp;&amp; s.hasValue()) {\r\n          const t = q(e, s.getCenterPoint());\r\n          t &lt; r &amp;&amp; (r = t, n = s)\r\n        }\r\n      }\r\n      if (n) {\r\n        const t = n.tooltipPosition();\r\n        o = t.x, a = t.y\r\n      }\r\n      return {\r\n        x: o,\r\n        y: a\r\n      }\r\n    }\r\n  };\r\n\r\n  function Pa(t, e) {\r\n    return e &amp;&amp; (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t\r\n  }\r\n\r\n  function Da(t) {\r\n    return (&quot;string&quot; == typeof t || t instanceof String) &amp;&amp; t.indexOf(&quot;\\n&quot;) &gt; -1 ? t.split(&quot;\\n&quot;) : t\r\n  }\r\n\r\n  function Ca(t, e) {\r\n    const {\r\n      element: i,\r\n      datasetIndex: s,\r\n      index: n\r\n    } = e, o = t.getDatasetMeta(s).controller, {\r\n      label: a,\r\n      value: r\r\n    } = o.getLabelAndValue(n);\r\n    return {\r\n      chart: t,\r\n      label: a,\r\n      parsed: o.getParsed(n),\r\n      raw: t.data.datasets[s].data[n],\r\n      formattedValue: r,\r\n      dataset: o.getDataset(),\r\n      dataIndex: n,\r\n      datasetIndex: s,\r\n      element: i\r\n    }\r\n  }\r\n\r\n  function Oa(t, e) {\r\n    const i = t.chart.ctx,\r\n      {\r\n        body: s,\r\n        footer: n,\r\n        title: o\r\n      } = t,\r\n      {\r\n        boxWidth: a,\r\n        boxHeight: r\r\n      } = e,\r\n      l = Si(e.bodyFont),\r\n      h = Si(e.titleFont),\r\n      c = Si(e.footerFont),\r\n      d = o.length,\r\n      f = n.length,\r\n      g = s.length,\r\n      p = ki(e.padding);\r\n    let m = p.height,\r\n      x = 0,\r\n      b = s.reduce(((t, e) =&gt; t + e.before.length + e.lines.length + e.after.length), 0);\r\n    if (b += t.beforeBody.length + t.afterBody.length, d &amp;&amp; (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), b) {\r\n      m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (b - g) * l.lineHeight + (b - 1) * e.bodySpacing\r\n    }\r\n    f &amp;&amp; (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);\r\n    let _ = 0;\r\n    const y = function(t) {\r\n      x = Math.max(x, i.measureText(t).width + _)\r\n    };\r\n    return i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t =&gt; {\r\n      u(t.before, y), u(t.lines, y), u(t.after, y)\r\n    })), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), x += p.width, {\r\n      width: x,\r\n      height: m\r\n    }\r\n  }\r\n\r\n  function Aa(t, e, i, s) {\r\n    const {\r\n      x: n,\r\n      width: o\r\n    } = i, {\r\n      width: a,\r\n      chartArea: {\r\n        left: r,\r\n        right: l\r\n      }\r\n    } = t;\r\n    let h = &quot;center&quot;;\r\n    return &quot;center&quot; === s ? h = n &lt;= (r + l) \/ 2 ? &quot;left&quot; : &quot;right&quot; : n &lt;= o \/ 2 ? h = &quot;left&quot; : n &gt;= a - o \/ 2 &amp;&amp; (h = &quot;right&quot;),\r\n      function(t, e, i, s) {\r\n        const {\r\n          x: n,\r\n          width: o\r\n        } = s, a = i.caretSize + i.caretPadding;\r\n        return &quot;left&quot; === t &amp;&amp; n + o + a &gt; e.width || &quot;right&quot; === t &amp;&amp; n - o - a &lt; 0 || void 0\r\n      }(h, t, e, i) &amp;&amp; (h = &quot;center&quot;), h\r\n  }\r\n\r\n  function Ta(t, e, i) {\r\n    const s = i.yAlign || e.yAlign || function(t, e) {\r\n      const {\r\n        y: i,\r\n        height: s\r\n      } = e;\r\n      return i &lt; s \/ 2 ? &quot;top&quot; : i &gt; t.height - s \/ 2 ? &quot;bottom&quot; : &quot;center&quot;\r\n    }(t, i);\r\n    return {\r\n      xAlign: i.xAlign || e.xAlign || Aa(t, e, i, s),\r\n      yAlign: s\r\n    }\r\n  }\r\n\r\n  function La(t, e, i, s) {\r\n    const {\r\n      caretSize: n,\r\n      caretPadding: o,\r\n      cornerRadius: a\r\n    } = t, {\r\n      xAlign: r,\r\n      yAlign: l\r\n    } = i, h = n + o, {\r\n      topLeft: c,\r\n      topRight: d,\r\n      bottomLeft: u,\r\n      bottomRight: f\r\n    } = wi(a);\r\n    let g = function(t, e) {\r\n      let {\r\n        x: i,\r\n        width: s\r\n      } = t;\r\n      return &quot;right&quot; === e ? i -= s : &quot;center&quot; === e &amp;&amp; (i -= s \/ 2), i\r\n    }(e, r);\r\n    const p = function(t, e, i) {\r\n      let {\r\n        y: s,\r\n        height: n\r\n      } = t;\r\n      return &quot;top&quot; === e ? s += i : s -= &quot;bottom&quot; === e ? n + i : n \/ 2, s\r\n    }(e, l, h);\r\n    return &quot;center&quot; === l ? &quot;left&quot; === r ? g += h : &quot;right&quot; === r &amp;&amp; (g -= h) : &quot;left&quot; === r ? g -= Math.max(c, u) + n : &quot;right&quot; === r &amp;&amp; (g += Math.max(d, f) + n), {\r\n      x: J(g, 0, s.width - e.width),\r\n      y: J(p, 0, s.height - e.height)\r\n    }\r\n  }\r\n\r\n  function Ea(t, e, i) {\r\n    const s = ki(i.padding);\r\n    return &quot;center&quot; === e ? t.x + t.width \/ 2 : &quot;right&quot; === e ? t.x + t.width - s.right : t.x + s.left\r\n  }\r\n\r\n  function Ra(t) {\r\n    return Pa([], Da(t))\r\n  }\r\n\r\n  function Ia(t, e) {\r\n    const i = e &amp;&amp; e.dataset &amp;&amp; e.dataset.tooltip &amp;&amp; e.dataset.tooltip.callbacks;\r\n    return i ? t.override(i) : t\r\n  }\r\n  const za = {\r\n    beforeTitle: e,\r\n    title(t) {\r\n      if (t.length &gt; 0) {\r\n        const e = t[0],\r\n          i = e.chart.data.labels,\r\n          s = i ? i.length : 0;\r\n        if (this &amp;&amp; this.options &amp;&amp; &quot;dataset&quot; === this.options.mode) return e.dataset.label || &quot;&quot;;\r\n        if (e.label) return e.label;\r\n        if (s &gt; 0 &amp;&amp; e.dataIndex &lt; s) return i[e.dataIndex]\r\n      }\r\n      return &quot;&quot;\r\n    },\r\n    afterTitle: e,\r\n    beforeBody: e,\r\n    beforeLabel: e,\r\n    label(t) {\r\n      if (this &amp;&amp; this.options &amp;&amp; &quot;dataset&quot; === this.options.mode) return t.label + &quot;: &quot; + t.formattedValue || t.formattedValue;\r\n      let e = t.dataset.label || &quot;&quot;;\r\n      e &amp;&amp; (e += &quot;: &quot;);\r\n      const i = t.formattedValue;\r\n      return s(i) || (e += i), e\r\n    },\r\n    labelColor(t) {\r\n      const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\r\n      return {\r\n        borderColor: e.borderColor,\r\n        backgroundColor: e.backgroundColor,\r\n        borderWidth: e.borderWidth,\r\n        borderDash: e.borderDash,\r\n        borderDashOffset: e.borderDashOffset,\r\n        borderRadius: 0\r\n      }\r\n    },\r\n    labelTextColor() {\r\n      return this.options.bodyColor\r\n    },\r\n    labelPointStyle(t) {\r\n      const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\r\n      return {\r\n        pointStyle: e.pointStyle,\r\n        rotation: e.rotation\r\n      }\r\n    },\r\n    afterLabel: e,\r\n    afterBody: e,\r\n    beforeFooter: e,\r\n    footer: e,\r\n    afterFooter: e\r\n  };\r\n\r\n  function Fa(t, e, i, s) {\r\n    const n = t[e].call(i, s);\r\n    return void 0 === n ? za[e].call(i, s) : n\r\n  }\r\n  class Va extends Hs {\r\n    static positioners = Sa;\r\n    constructor(t) {\r\n      super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0\r\n    }\r\n    initialize(t) {\r\n      this.options = t, this._cachedAnimations = void 0, this.$context = void 0\r\n    }\r\n    _resolveAnimations() {\r\n      const t = this._cachedAnimations;\r\n      if (t) return t;\r\n      const e = this.chart,\r\n        i = this.options.setContext(this.getContext()),\r\n        s = i.enabled &amp;&amp; e.options.animation &amp;&amp; i.animations,\r\n        n = new Os(this.chart, s);\r\n      return s._cacheable &amp;&amp; (this._cachedAnimations = Object.freeze(n)), n\r\n    }\r\n    getContext() {\r\n      return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ci(t, {\r\n        tooltip: e,\r\n        tooltipItems: i,\r\n        type: &quot;tooltip&quot;\r\n      })));\r\n      var t, e, i\r\n    }\r\n    getTitle(t, e) {\r\n      const {\r\n        callbacks: i\r\n      } = e, s = Fa(i, &quot;beforeTitle&quot;, this, t), n = Fa(i, &quot;title&quot;, this, t), o = Fa(i, &quot;afterTitle&quot;, this, t);\r\n      let a = [];\r\n      return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a\r\n    }\r\n    getBeforeBody(t, e) {\r\n      return Ra(Fa(e.callbacks, &quot;beforeBody&quot;, this, t))\r\n    }\r\n    getBody(t, e) {\r\n      const {\r\n        callbacks: i\r\n      } = e, s = [];\r\n      return u(t, (t =&gt; {\r\n        const e = {\r\n            before: [],\r\n            lines: [],\r\n            after: []\r\n          },\r\n          n = Ia(i, t);\r\n        Pa(e.before, Da(Fa(n, &quot;beforeLabel&quot;, this, t))), Pa(e.lines, Fa(n, &quot;label&quot;, this, t)), Pa(e.after, Da(Fa(n, &quot;afterLabel&quot;, this, t))), s.push(e)\r\n      })), s\r\n    }\r\n    getAfterBody(t, e) {\r\n      return Ra(Fa(e.callbacks, &quot;afterBody&quot;, this, t))\r\n    }\r\n    getFooter(t, e) {\r\n      const {\r\n        callbacks: i\r\n      } = e, s = Fa(i, &quot;beforeFooter&quot;, this, t), n = Fa(i, &quot;footer&quot;, this, t), o = Fa(i, &quot;afterFooter&quot;, this, t);\r\n      let a = [];\r\n      return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a\r\n    }\r\n    _createItems(t) {\r\n      const e = this._active,\r\n        i = this.chart.data,\r\n        s = [],\r\n        n = [],\r\n        o = [];\r\n      let a, r, l = [];\r\n      for (a = 0, r = e.length; a &lt; r; ++a) l.push(Ca(this.chart, e[a]));\r\n      return t.filter &amp;&amp; (l = l.filter(((e, s, n) =&gt; t.filter(e, s, n, i)))), t.itemSort &amp;&amp; (l = l.sort(((e, s) =&gt; t.itemSort(e, s, i)))), u(l, (e =&gt; {\r\n        const i = Ia(t.callbacks, e);\r\n        s.push(Fa(i, &quot;labelColor&quot;, this, e)), n.push(Fa(i, &quot;labelPointStyle&quot;, this, e)), o.push(Fa(i, &quot;labelTextColor&quot;, this, e))\r\n      })), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l\r\n    }\r\n    update(t, e) {\r\n      const i = this.options.setContext(this.getContext()),\r\n        s = this._active;\r\n      let n, o = [];\r\n      if (s.length) {\r\n        const t = Sa[i.position].call(this, s, this._eventPosition);\r\n        o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);\r\n        const e = this._size = Oa(this, i),\r\n          a = Object.assign({}, t, e),\r\n          r = Ta(this.chart, i, a),\r\n          l = La(i, a, r, this.chart);\r\n        this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {\r\n          opacity: 1,\r\n          x: l.x,\r\n          y: l.y,\r\n          width: e.width,\r\n          height: e.height,\r\n          caretX: t.x,\r\n          caretY: t.y\r\n        }\r\n      } else 0 !== this.opacity &amp;&amp; (n = {\r\n        opacity: 0\r\n      });\r\n      this._tooltipItems = o, this.$context = void 0, n &amp;&amp; this._resolveAnimations().update(this, n), t &amp;&amp; i.external &amp;&amp; i.external.call(this, {\r\n        chart: this.chart,\r\n        tooltip: this,\r\n        replay: e\r\n      })\r\n    }\r\n    drawCaret(t, e, i, s) {\r\n      const n = this.getCaretPosition(t, i, s);\r\n      e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3)\r\n    }\r\n    getCaretPosition(t, e, i) {\r\n      const {\r\n        xAlign: s,\r\n        yAlign: n\r\n      } = this, {\r\n        caretSize: o,\r\n        cornerRadius: a\r\n      } = i, {\r\n        topLeft: r,\r\n        topRight: l,\r\n        bottomLeft: h,\r\n        bottomRight: c\r\n      } = wi(a), {\r\n        x: d,\r\n        y: u\r\n      } = t, {\r\n        width: f,\r\n        height: g\r\n      } = e;\r\n      let p, m, x, b, _, y;\r\n      return &quot;center&quot; === n ? (_ = u + g \/ 2, &quot;left&quot; === s ? (p = d, m = p - o, b = _ + o, y = _ - o) : (p = d + f, m = p + o, b = _ - o, y = _ + o), x = p) : (m = &quot;left&quot; === s ? d + Math.max(r, h) + o : &quot;right&quot; === s ? d + f - Math.max(l, c) - o : this.caretX, &quot;top&quot; === n ? (b = u, _ = b - o, p = m - o, x = m + o) : (b = u + g, _ = b + o, p = m + o, x = m - o), y = b), {\r\n        x1: p,\r\n        x2: m,\r\n        x3: x,\r\n        y1: b,\r\n        y2: _,\r\n        y3: y\r\n      }\r\n    }\r\n    drawTitle(t, e, i) {\r\n      const s = this.title,\r\n        n = s.length;\r\n      let o, a, r;\r\n      if (n) {\r\n        const l = Oi(i.rtl, this.x, this.width);\r\n        for (t.x = Ea(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = &quot;middle&quot;, o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r &lt; n; ++r) e.fillText(s[r], l.x(t.x), t.y + o.lineHeight \/ 2), t.y += o.lineHeight + a, r + 1 === n &amp;&amp; (t.y += i.titleMarginBottom - a)\r\n      }\r\n    }\r\n    _drawColorBox(t, e, i, s, n) {\r\n      const a = this.labelColors[i],\r\n        r = this.labelPointStyles[i],\r\n        {\r\n          boxHeight: l,\r\n          boxWidth: h\r\n        } = n,\r\n        c = Si(n.bodyFont),\r\n        d = Ea(this, &quot;left&quot;, n),\r\n        u = s.x(d),\r\n        f = l &lt; c.lineHeight ? (c.lineHeight - l) \/ 2 : 0,\r\n        g = e.y + f;\r\n      if (n.usePointStyle) {\r\n        const e = {\r\n            radius: Math.min(h, l) \/ 2,\r\n            pointStyle: r.pointStyle,\r\n            rotation: r.rotation,\r\n            borderWidth: 1\r\n          },\r\n          i = s.leftForLtr(u, h) + h \/ 2,\r\n          o = g + l \/ 2;\r\n        t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o)\r\n      } else {\r\n        t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;\r\n        const e = s.leftForLtr(u, h),\r\n          i = s.leftForLtr(s.xPlus(u, 1), h - 2),\r\n          r = wi(a.borderRadius);\r\n        Object.values(r).some((t =&gt; 0 !== t)) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, {\r\n          x: e,\r\n          y: g,\r\n          w: h,\r\n          h: l,\r\n          radius: r\r\n        }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, {\r\n          x: i,\r\n          y: g + 1,\r\n          w: h - 2,\r\n          h: l - 2,\r\n          radius: r\r\n        }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2))\r\n      }\r\n      t.fillStyle = this.labelTextColors[i]\r\n    }\r\n    drawBody(t, e, i) {\r\n      const {\r\n        body: s\r\n      } = this, {\r\n        bodySpacing: n,\r\n        bodyAlign: o,\r\n        displayColors: a,\r\n        boxHeight: r,\r\n        boxWidth: l,\r\n        boxPadding: h\r\n      } = i, c = Si(i.bodyFont);\r\n      let d = c.lineHeight,\r\n        f = 0;\r\n      const g = Oi(i.rtl, this.x, this.width),\r\n        p = function(i) {\r\n          e.fillText(i, g.x(t.x + f), t.y + d \/ 2), t.y += d + n\r\n        },\r\n        m = g.textAlign(o);\r\n      let x, b, _, y, v, M, w;\r\n      for (e.textAlign = o, e.textBaseline = &quot;middle&quot;, e.font = c.string, t.x = Ea(this, m, i), e.fillStyle = i.bodyColor, u(this.beforeBody, p), f = a &amp;&amp; &quot;right&quot; !== m ? &quot;center&quot; === o ? l \/ 2 + h : l + 2 + h : 0, y = 0, M = s.length; y &lt; M; ++y) {\r\n        for (x = s[y], b = this.labelTextColors[y], e.fillStyle = b, u(x.before, p), _ = x.lines, a &amp;&amp; _.length &amp;&amp; (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.length; v &lt; w; ++v) p(_[v]), d = c.lineHeight;\r\n        u(x.after, p)\r\n      }\r\n      f = 0, d = c.lineHeight, u(this.afterBody, p), t.y -= n\r\n    }\r\n    drawFooter(t, e, i) {\r\n      const s = this.footer,\r\n        n = s.length;\r\n      let o, a;\r\n      if (n) {\r\n        const r = Oi(i.rtl, this.x, this.width);\r\n        for (t.x = Ea(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = &quot;middle&quot;, o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a &lt; n; ++a) e.fillText(s[a], r.x(t.x), t.y + o.lineHeight \/ 2), t.y += o.lineHeight + i.footerSpacing\r\n      }\r\n    }\r\n    drawBackground(t, e, i, s) {\r\n      const {\r\n        xAlign: n,\r\n        yAlign: o\r\n      } = this, {\r\n        x: a,\r\n        y: r\r\n      } = t, {\r\n        width: l,\r\n        height: h\r\n      } = i, {\r\n        topLeft: c,\r\n        topRight: d,\r\n        bottomLeft: u,\r\n        bottomRight: f\r\n      } = wi(s.cornerRadius);\r\n      e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), &quot;top&quot; === o &amp;&amp; this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), &quot;center&quot; === o &amp;&amp; &quot;right&quot; === n &amp;&amp; this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), &quot;bottom&quot; === o &amp;&amp; this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), &quot;center&quot; === o &amp;&amp; &quot;left&quot; === n &amp;&amp; this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth &gt; 0 &amp;&amp; e.stroke()\r\n    }\r\n    _updateAnimationTarget(t) {\r\n      const e = this.chart,\r\n        i = this.$animations,\r\n        s = i &amp;&amp; i.x,\r\n        n = i &amp;&amp; i.y;\r\n      if (s || n) {\r\n        const i = Sa[t.position].call(this, this._active, this._eventPosition);\r\n        if (!i) return;\r\n        const o = this._size = Oa(this, t),\r\n          a = Object.assign({}, i, this._size),\r\n          r = Ta(e, t, a),\r\n          l = La(t, a, r, e);\r\n        s._to === l.x &amp;&amp; n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l))\r\n      }\r\n    }\r\n    _willRender() {\r\n      return !!this.opacity\r\n    }\r\n    draw(t) {\r\n      const e = this.options.setContext(this.getContext());\r\n      let i = this.opacity;\r\n      if (!i) return;\r\n      this._updateAnimationTarget(e);\r\n      const s = {\r\n          width: this.width,\r\n          height: this.height\r\n        },\r\n        n = {\r\n          x: this.x,\r\n          y: this.y\r\n        };\r\n      i = Math.abs(i) &lt; .001 ? 0 : i;\r\n      const o = ki(e.padding),\r\n        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\r\n      e.enabled &amp;&amp; a &amp;&amp; (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore())\r\n    }\r\n    getActiveElements() {\r\n      return this._active || []\r\n    }\r\n    setActiveElements(t, e) {\r\n      const i = this._active,\r\n        s = t.map((({\r\n          datasetIndex: t,\r\n          index: e\r\n        }) =&gt; {\r\n          const i = this.chart.getDatasetMeta(t);\r\n          if (!i) throw new Error(&quot;Cannot find a dataset at index &quot; + t);\r\n          return {\r\n            datasetIndex: t,\r\n            element: i.data[e],\r\n            index: e\r\n          }\r\n        })),\r\n        n = !f(i, s),\r\n        o = this._positionChanged(s, e);\r\n      (n || o) &amp;&amp; (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0))\r\n    }\r\n    handleEvent(t, e, i = !0) {\r\n      if (e &amp;&amp; this._ignoreReplayEvents) return !1;\r\n      this._ignoreReplayEvents = !1;\r\n      const s = this.options,\r\n        n = this._active || [],\r\n        o = this._getActiveElements(t, n, e, i),\r\n        a = this._positionChanged(o, t),\r\n        r = e || !f(o, n) || a;\r\n      return r &amp;&amp; (this._active = o, (s.enabled || s.external) &amp;&amp; (this._eventPosition = {\r\n        x: t.x,\r\n        y: t.y\r\n      }, this.update(!0, e))), r\r\n    }\r\n    _getActiveElements(t, e, i, s) {\r\n      const n = this.options;\r\n      if (&quot;mouseout&quot; === t.type) return [];\r\n      if (!s) return e.filter((t =&gt; this.chart.data.datasets[t.datasetIndex] &amp;&amp; void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)));\r\n      const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);\r\n      return n.reverse &amp;&amp; o.reverse(), o\r\n    }\r\n    _positionChanged(t, e) {\r\n      const {\r\n        caretX: i,\r\n        caretY: s,\r\n        options: n\r\n      } = this, o = Sa[n.position].call(this, t, e);\r\n      return !1 !== o &amp;&amp; (i !== o.x || s !== o.y)\r\n    }\r\n  }\r\n  var Ba = {\r\n    id: &quot;tooltip&quot;,\r\n    _element: Va,\r\n    positioners: Sa,\r\n    afterInit(t, e, i) {\r\n      i &amp;&amp; (t.tooltip = new Va({\r\n        chart: t,\r\n        options: i\r\n      }))\r\n    },\r\n    beforeUpdate(t, e, i) {\r\n      t.tooltip &amp;&amp; t.tooltip.initialize(i)\r\n    },\r\n    reset(t, e, i) {\r\n      t.tooltip &amp;&amp; t.tooltip.initialize(i)\r\n    },\r\n    afterDraw(t) {\r\n      const e = t.tooltip;\r\n      if (e &amp;&amp; e._willRender()) {\r\n        const i = {\r\n          tooltip: e\r\n        };\r\n        if (!1 === t.notifyPlugins(&quot;beforeTooltipDraw&quot;, {\r\n            ...i,\r\n            cancelable: !0\r\n          })) return;\r\n        e.draw(t.ctx), t.notifyPlugins(&quot;afterTooltipDraw&quot;, i)\r\n      }\r\n    },\r\n    afterEvent(t, e) {\r\n      if (t.tooltip) {\r\n        const i = e.replay;\r\n        t.tooltip.handleEvent(e.event, i, e.inChartArea) &amp;&amp; (e.changed = !0)\r\n      }\r\n    },\r\n    defaults: {\r\n      enabled: !0,\r\n      external: null,\r\n      position: &quot;average&quot;,\r\n      backgroundColor: &quot;rgba(0,0,0,0.8)&quot;,\r\n      titleColor: &quot;#fff&quot;,\r\n      titleFont: {\r\n        weight: &quot;bold&quot;\r\n      },\r\n      titleSpacing: 2,\r\n      titleMarginBottom: 6,\r\n      titleAlign: &quot;left&quot;,\r\n      bodyColor: &quot;#fff&quot;,\r\n      bodySpacing: 2,\r\n      bodyFont: {},\r\n      bodyAlign: &quot;left&quot;,\r\n      footerColor: &quot;#fff&quot;,\r\n      footerSpacing: 2,\r\n      footerMarginTop: 6,\r\n      footerFont: {\r\n        weight: &quot;bold&quot;\r\n      },\r\n      footerAlign: &quot;left&quot;,\r\n      padding: 6,\r\n      caretPadding: 2,\r\n      caretSize: 5,\r\n      cornerRadius: 6,\r\n      boxHeight: (t, e) =&gt; e.bodyFont.size,\r\n      boxWidth: (t, e) =&gt; e.bodyFont.size,\r\n      multiKeyBackground: &quot;#fff&quot;,\r\n      displayColors: !0,\r\n      boxPadding: 0,\r\n      borderColor: &quot;rgba(0,0,0,0)&quot;,\r\n      borderWidth: 0,\r\n      animation: {\r\n        duration: 400,\r\n        easing: &quot;easeOutQuart&quot;\r\n      },\r\n      animations: {\r\n        numbers: {\r\n          type: &quot;number&quot;,\r\n          properties: [&quot;x&quot;, &quot;y&quot;, &quot;width&quot;, &quot;height&quot;, &quot;caretX&quot;, &quot;caretY&quot;]\r\n        },\r\n        opacity: {\r\n          easing: &quot;linear&quot;,\r\n          duration: 200\r\n        }\r\n      },\r\n      callbacks: za\r\n    },\r\n    defaultRoutes: {\r\n      bodyFont: &quot;font&quot;,\r\n      footerFont: &quot;font&quot;,\r\n      titleFont: &quot;font&quot;\r\n    },\r\n    descriptors: {\r\n      _scriptable: t =&gt; &quot;filter&quot; !== t &amp;&amp; &quot;itemSort&quot; !== t &amp;&amp; &quot;external&quot; !== t,\r\n      _indexable: !1,\r\n      callbacks: {\r\n        _scriptable: !1,\r\n        _indexable: !1\r\n      },\r\n      animation: {\r\n        _fallback: !1\r\n      },\r\n      animations: {\r\n        _fallback: &quot;animation&quot;\r\n      }\r\n    },\r\n    additionalOptionScopes: [&quot;interaction&quot;]\r\n  };\r\n  return An.register(Yn, jo, fo, t), An.helpers = {\r\n    ...Wi\r\n  }, An._adapters = Rn, An.Animation = Cs, An.Animations = Os, An.animator = bt, An.controllers = en.controllers.items, An.DatasetController = Ns, An.Element = Hs, An.elements = fo, An.Interaction = Xi, An.layouts = as, An.platforms = Ss, An.Scale = Js, An.Ticks = ae, Object.assign(An, Yn, jo, fo, t, Ss), An.Chart = An, &quot;undefined&quot; != typeof window &amp;&amp; (window.Chart = An), An\r\n}));\r\n\/\/# sourceMappingURL=chart.umd.js.map","Category":"Extension","Chats":[],"Created":"2024-10-02 04:19:44PM","Description":"Allows the rendering of charts throughout the GUI.","Forums":[],"ForumPosts":[],"Members":[],"Modified":"2025-05-20 01:17:15AM","ModifiedBy":{"2025-05-16 01:58:44AM":"Mike","2025-05-18 03:45:27PM":"Mike","2025-05-20 01:17:15AM":"Mike"},"Polls":[],"Products":[],"Purge":0,"Shops":[],"Title":"Web UI: Charts","UN":"Mike","Updates":[]}